import { cache } from '@cornerstonejs/core';
import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';
import vtkAppendPolyData from '@kitware/vtk.js/Filters/General/AppendPolyData';
import { getConfigCache, setConfigCache } from './contourConfigCache';
import { getPolyData } from './utils';
export function updateContourSets(viewport, geometryIds, contourRepresentation, contourRepresentationConfig, contourActorUID) {
    const { segmentationRepresentationUID, segmentsHidden } = contourRepresentation;
    const newContourConfig = contourRepresentationConfig.representations.CONTOUR;
    const cachedConfig = getConfigCache(segmentationRepresentationUID);
    const contourSetsActor = viewport.getActor(contourActorUID);
    if (!contourSetsActor) {
        console.warn(`No contour actor found for actorUID ${contourActorUID}. Skipping render.`);
        return;
    }
    const { actor } = contourSetsActor;
    const newOutlineWithActive = newContourConfig.outlineWidthActive;
    if (cachedConfig?.outlineWidthActive !== newOutlineWithActive) {
        actor.getProperty().setLineWidth(newOutlineWithActive);
        setConfigCache(segmentationRepresentationUID, Object.assign({}, cachedConfig, {
            outlineWidthActive: newOutlineWithActive,
        }));
    }
    const mapper = actor.getMapper();
    const lut = mapper.getLookupTable();
    const segmentsToSetToInvisible = [];
    const segmentsToSetToVisible = [];
    for (const segmentIndex of segmentsHidden) {
        if (!cachedConfig?.segmentsHidden.has(segmentIndex)) {
            segmentsToSetToInvisible.push(segmentIndex);
        }
    }
    for (const segmentIndex of cachedConfig.segmentsHidden) {
        if (!segmentsHidden.has(segmentIndex)) {
            segmentsToSetToVisible.push(segmentIndex);
        }
    }
    if (segmentsToSetToInvisible.length || segmentsToSetToVisible.length) {
        const appendPolyData = vtkAppendPolyData.newInstance();
        geometryIds.forEach((geometryId) => {
            const geometry = cache.getGeometry(geometryId);
            const { data: contourSet } = geometry;
            const segmentIndex = contourSet.getSegmentIndex();
            const color = contourSet.getColor();
            const visibility = segmentsToSetToInvisible.includes(segmentIndex)
                ? 0
                : 255;
            const polyData = getPolyData(contourSet);
            const size = polyData.getPoints().getNumberOfPoints();
            const scalars = vtkDataArray.newInstance({
                size: size * 4,
                numberOfComponents: 4,
                dataType: 'Uint8Array',
            });
            for (let i = 0; i < size; ++i) {
                scalars.setTuple(i, [...color, visibility]);
            }
            polyData.getPointData().setScalars(scalars);
            segmentIndex === 0
                ? appendPolyData.setInputData(polyData)
                : appendPolyData.addInputData(polyData);
        });
        const polyDataOutput = appendPolyData.getOutputData();
        mapper.setInputData(polyDataOutput);
        setConfigCache(segmentationRepresentationUID, Object.assign({}, cachedConfig, {
            segmentsHidden: new Set(segmentsHidden),
        }));
        mapper.setLookupTable(lut);
    }
    viewport.render();
}
//# sourceMappingURL=updateContourSets.js.map