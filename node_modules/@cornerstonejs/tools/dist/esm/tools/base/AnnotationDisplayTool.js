import { utilities, getEnabledElement, VolumeViewport, StackViewport, cache, } from '@cornerstonejs/core';
import { vec4 } from 'gl-matrix';
import BaseTool from './BaseTool';
import { getAnnotationManager } from '../../stateManagement/annotation/annotationState';
import triggerAnnotationRender from '../../utilities/triggerAnnotationRender';
import filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';
import { getStyleProperty } from '../../stateManagement/annotation/config/helpers';
import { getState } from '../../stateManagement/annotation/config';
class AnnotationDisplayTool extends BaseTool {
    constructor() {
        super(...arguments);
        this.onImageSpacingCalibrated = (evt) => {
            const { element, rowScale, columnScale, imageId, imageData: calibratedImageData, worldToIndex: noneCalibratedWorldToIndex, } = evt.detail;
            const { viewport } = getEnabledElement(element);
            if (viewport instanceof VolumeViewport) {
                throw new Error('Cannot calibrate a volume viewport');
            }
            const calibratedIndexToWorld = calibratedImageData.getIndexToWorld();
            const imageURI = utilities.imageIdToURI(imageId);
            const stateManager = getAnnotationManager();
            const framesOfReference = stateManager.getFramesOfReference();
            framesOfReference.forEach((frameOfReference) => {
                const frameOfReferenceSpecificAnnotations = stateManager.getAnnotations(frameOfReference);
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];
                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {
                    return;
                }
                toolSpecificAnnotations.forEach((annotation) => {
                    const referencedImageURI = utilities.imageIdToURI(annotation.metadata.referencedImageId);
                    if (referencedImageURI === imageURI) {
                        annotation.invalidated = true;
                        annotation.data.cachedStats = {};
                        annotation.data.handles.points = annotation.data.handles.points.map((point) => {
                            const p = vec4.fromValues(...point, 1);
                            const pCalibrated = vec4.fromValues(0, 0, 0, 1);
                            const nonCalibratedIndexVec4 = vec4.create();
                            vec4.transformMat4(nonCalibratedIndexVec4, p, noneCalibratedWorldToIndex);
                            const calibratedIndex = [
                                columnScale * nonCalibratedIndexVec4[0],
                                rowScale * nonCalibratedIndexVec4[1],
                                nonCalibratedIndexVec4[2],
                            ];
                            vec4.transformMat4(pCalibrated, vec4.fromValues(calibratedIndex[0], calibratedIndex[1], calibratedIndex[2], 1), calibratedIndexToWorld);
                            return pCalibrated.slice(0, 3);
                        });
                    }
                });
                triggerAnnotationRender(element);
            });
        };
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations || !annotations.length) {
            return;
        }
        const enabledElement = getEnabledElement(element);
        const { viewport } = enabledElement;
        return filterAnnotationsForDisplay(viewport, annotations);
    }
    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId;
        if (viewport instanceof StackViewport) {
            referencedImageId = targetId.split('imageId:')[1];
        }
        else {
            const volumeId = targetId.split('volumeId:')[1];
            const imageVolume = cache.getVolume(volumeId);
            referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal, viewUp);
        }
        return referencedImageId;
    }
    getStyle(property, specifications, annotation) {
        return getStyleProperty(property, specifications, getState(annotation), this.mode);
    }
}
AnnotationDisplayTool.toolName = 'AnnotationDisplayTool';
export default AnnotationDisplayTool;
//# sourceMappingURL=AnnotationDisplayTool.js.map