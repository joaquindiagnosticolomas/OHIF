import { CONSTANTS, getEnabledElement, triggerEvent, eventTarget, StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';
import { vec3 } from 'gl-matrix';
import { Events } from '../../enums';
import { AnnotationTool } from '../base';
import { addAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';
import { polyline } from '../../utilities/math';
import { filterAnnotationsForDisplay } from '../../utilities/planar';
import { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';
import triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';
import registerDrawLoop from './planarFreehandROITool/drawLoop';
import registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';
import registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';
import registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';
import registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';
import registerRenderMethods from './planarFreehandROITool/renderMethods';
const { pointCanProjectOnLine } = polyline;
const { EPSILON } = CONSTANTS;
const PARALLEL_THRESHOLD = 1 - EPSILON;
class PlanarFreehandROITool extends AnnotationTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            alwaysRenderOpenContourHandles: {
                enabled: false,
                radius: 2,
            },
            allowOpenContours: true,
            closeContourProximity: 10,
            checkCanvasEditFallbackProximity: 6,
            subPixelResolution: 4,
            interpolation: {
                interpolateOnAdd: false,
                interpolateOnEdit: false,
                knotsRatioPercentageOnAdd: 40,
                knotsRatioPercentageOnEdit: 40,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isEditingClosed = false;
        this.isEditingOpen = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = getEnabledElement(element);
            const { viewport, renderingEngine } = enabledElement;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                },
                data: {
                    handles: {
                        points: [],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    polyline: [[...worldPos]],
                    label: '',
                },
            };
            addAnnotation(annotation, element);
            this.activateDraw(evt, annotation, viewportIdsToRender);
            evt.preventDefault();
            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
            return annotation;
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
            if (annotation.data.isOpenContour) {
                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);
            }
            else {
                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);
            }
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = getEnabledElement(element);
            const { viewport } = enabledElement;
            const points = annotation.data.polyline;
            let previousPoint = viewport.worldToCanvas(points[0]);
            for (let i = 1; i < points.length; i++) {
                const p1 = previousPoint;
                const p2 = viewport.worldToCanvas(points[i]);
                const distance = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);
                if (distance === true) {
                    return true;
                }
                previousPoint = p2;
            }
            if (annotation.data.isOpenContour) {
                return false;
            }
            const pStart = viewport.worldToCanvas(points[0]);
            const pEnd = viewport.worldToCanvas(points[points.length - 1]);
            const distance = pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);
            if (distance === true) {
                return true;
            }
            return false;
        };
        this.cancel = (element) => {
            const isDrawing = this.isDrawing;
            const isEditingOpen = this.isEditingOpen;
            const isEditingClosed = this.isEditingClosed;
            if (isDrawing) {
                this.cancelDrawing(element);
            }
            else if (isEditingOpen) {
                this.cancelOpenContourEdit(element);
            }
            else if (isEditingClosed) {
                this.cancelClosedContourEdit(element);
            }
        };
        this.triggerAnnotationModified = (annotation, enabledElement) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
            };
            triggerEvent(eventTarget, eventType, eventDetail);
        };
        this.triggerAnnotationCompleted = (annotation) => {
            const eventType = Events.ANNOTATION_COMPLETED;
            const eventDetail = {
                annotation,
            };
            triggerEvent(eventTarget, eventType, eventDetail);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (getAnnotations(this.getToolName(), element));
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const isDrawing = this.isDrawing;
            const isEditingOpen = this.isEditingOpen;
            const isEditingClosed = this.isEditingClosed;
            if (!(isDrawing || isEditingOpen || isEditingClosed)) {
                annotations.forEach((annotation) => {
                    if (!annotation)
                        return;
                    this.renderContour(enabledElement, svgDrawingHelper, annotation);
                });
                return renderStatus;
            }
            const activeAnnotationUID = this.commonData.annotation.annotationUID;
            annotations.forEach((annotation) => {
                if (annotation.annotationUID === activeAnnotationUID) {
                    if (isDrawing) {
                        this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);
                    }
                    else if (isEditingClosed) {
                        this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                    }
                    else if (isEditingOpen) {
                        this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                    }
                    else {
                        throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);
                    }
                }
                else {
                    this.renderContour(enabledElement, svgDrawingHelper, annotation);
                }
            });
            return true;
        };
        registerDrawLoop(this);
        registerEditLoopCommon(this);
        registerClosedContourEditLoop(this);
        registerOpenContourEditLoop(this);
        registerOpenContourEndEditLoop(this);
        registerRenderMethods(this);
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations || !annotations.length) {
            return;
        }
        const enabledElement = getEnabledElement(element);
        const { viewport } = enabledElement;
        let annotationsToDisplay;
        if (viewport instanceof StackViewport) {
            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);
        }
        else if (viewport instanceof VolumeViewport) {
            const camera = viewport.getCamera();
            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);
            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);
        }
        else {
            throw new Error(`Viewport Type ${viewport.type} not supported`);
        }
        return annotationsToDisplay;
    }
    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
        const { viewPlaneNormal } = camera;
        const annotationsWithParallelNormals = annotations.filter((td) => {
            const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;
            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >
                PARALLEL_THRESHOLD;
            return annotationViewPlaneNormal && isParallel;
        });
        if (!annotationsWithParallelNormals.length) {
            return [];
        }
        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
        const { focalPoint } = camera;
        const annotationsWithinSlice = [];
        for (const annotation of annotationsWithParallelNormals) {
            const data = annotation.data;
            const point = data.polyline[0];
            if (!annotation.isVisible) {
                continue;
            }
            const dir = vec3.create();
            vec3.sub(dir, focalPoint, point);
            const dot = vec3.dot(dir, viewPlaneNormal);
            if (Math.abs(dot) < halfSpacingInNormalDirection) {
                annotationsWithinSlice.push(annotation);
            }
        }
        return annotationsWithinSlice;
    }
}
PlanarFreehandROITool.toolName = 'PlanarFreehandROI';
export default PlanarFreehandROITool;
//# sourceMappingURL=PlanarFreehandROITool.js.map