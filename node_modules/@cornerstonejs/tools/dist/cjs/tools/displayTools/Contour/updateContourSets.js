"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateContourSets = void 0;
const core_1 = require("@cornerstonejs/core");
const DataArray_1 = __importDefault(require("@kitware/vtk.js/Common/Core/DataArray"));
const AppendPolyData_1 = __importDefault(require("@kitware/vtk.js/Filters/General/AppendPolyData"));
const contourConfigCache_1 = require("./contourConfigCache");
const utils_1 = require("./utils");
function updateContourSets(viewport, geometryIds, contourRepresentation, contourRepresentationConfig, contourActorUID) {
    const { segmentationRepresentationUID, segmentsHidden } = contourRepresentation;
    const newContourConfig = contourRepresentationConfig.representations.CONTOUR;
    const cachedConfig = (0, contourConfigCache_1.getConfigCache)(segmentationRepresentationUID);
    const contourSetsActor = viewport.getActor(contourActorUID);
    if (!contourSetsActor) {
        console.warn(`No contour actor found for actorUID ${contourActorUID}. Skipping render.`);
        return;
    }
    const { actor } = contourSetsActor;
    const newOutlineWithActive = newContourConfig.outlineWidthActive;
    if ((cachedConfig === null || cachedConfig === void 0 ? void 0 : cachedConfig.outlineWidthActive) !== newOutlineWithActive) {
        actor.getProperty().setLineWidth(newOutlineWithActive);
        (0, contourConfigCache_1.setConfigCache)(segmentationRepresentationUID, Object.assign({}, cachedConfig, {
            outlineWidthActive: newOutlineWithActive,
        }));
    }
    const mapper = actor.getMapper();
    const lut = mapper.getLookupTable();
    const segmentsToSetToInvisible = [];
    const segmentsToSetToVisible = [];
    for (const segmentIndex of segmentsHidden) {
        if (!(cachedConfig === null || cachedConfig === void 0 ? void 0 : cachedConfig.segmentsHidden.has(segmentIndex))) {
            segmentsToSetToInvisible.push(segmentIndex);
        }
    }
    for (const segmentIndex of cachedConfig.segmentsHidden) {
        if (!segmentsHidden.has(segmentIndex)) {
            segmentsToSetToVisible.push(segmentIndex);
        }
    }
    if (segmentsToSetToInvisible.length || segmentsToSetToVisible.length) {
        const appendPolyData = AppendPolyData_1.default.newInstance();
        geometryIds.forEach((geometryId) => {
            const geometry = core_1.cache.getGeometry(geometryId);
            const { data: contourSet } = geometry;
            const segmentIndex = contourSet.getSegmentIndex();
            const color = contourSet.getColor();
            const visibility = segmentsToSetToInvisible.includes(segmentIndex)
                ? 0
                : 255;
            const polyData = (0, utils_1.getPolyData)(contourSet);
            const size = polyData.getPoints().getNumberOfPoints();
            const scalars = DataArray_1.default.newInstance({
                size: size * 4,
                numberOfComponents: 4,
                dataType: 'Uint8Array',
            });
            for (let i = 0; i < size; ++i) {
                scalars.setTuple(i, [...color, visibility]);
            }
            polyData.getPointData().setScalars(scalars);
            segmentIndex === 0
                ? appendPolyData.setInputData(polyData)
                : appendPolyData.addInputData(polyData);
        });
        const polyDataOutput = appendPolyData.getOutputData();
        mapper.setInputData(polyDataOutput);
        (0, contourConfigCache_1.setConfigCache)(segmentationRepresentationUID, Object.assign({}, cachedConfig, {
            segmentsHidden: new Set(segmentsHidden),
        }));
        mapper.setLookupTable(lut);
    }
    viewport.render();
}
exports.updateContourSets = updateContourSets;
//# sourceMappingURL=updateContourSets.js.map