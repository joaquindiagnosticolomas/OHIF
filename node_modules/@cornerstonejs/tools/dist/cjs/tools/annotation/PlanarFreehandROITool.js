"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cornerstonejs/core");
const gl_matrix_1 = require("gl-matrix");
const enums_1 = require("../../enums");
const base_1 = require("../base");
const annotationState_1 = require("../../stateManagement/annotation/annotationState");
const math_1 = require("../../utilities/math");
const planar_1 = require("../../utilities/planar");
const viewportFilters_1 = require("../../utilities/viewportFilters");
const triggerAnnotationRenderForViewportIds_1 = __importDefault(require("../../utilities/triggerAnnotationRenderForViewportIds"));
const drawLoop_1 = __importDefault(require("./planarFreehandROITool/drawLoop"));
const editLoopCommon_1 = __importDefault(require("./planarFreehandROITool/editLoopCommon"));
const closedContourEditLoop_1 = __importDefault(require("./planarFreehandROITool/closedContourEditLoop"));
const openContourEditLoop_1 = __importDefault(require("./planarFreehandROITool/openContourEditLoop"));
const openContourEndEditLoop_1 = __importDefault(require("./planarFreehandROITool/openContourEndEditLoop"));
const renderMethods_1 = __importDefault(require("./planarFreehandROITool/renderMethods"));
const { pointCanProjectOnLine } = math_1.polyline;
const { EPSILON } = core_1.CONSTANTS;
const PARALLEL_THRESHOLD = 1 - EPSILON;
class PlanarFreehandROITool extends base_1.AnnotationTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            alwaysRenderOpenContourHandles: {
                enabled: false,
                radius: 2,
            },
            allowOpenContours: true,
            closeContourProximity: 10,
            checkCanvasEditFallbackProximity: 6,
            subPixelResolution: 4,
            interpolation: {
                interpolateOnAdd: false,
                interpolateOnEdit: false,
                knotsRatioPercentageOnAdd: 40,
                knotsRatioPercentageOnEdit: 40,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isEditingClosed = false;
        this.isEditingOpen = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, this.getToolName());
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                },
                data: {
                    handles: {
                        points: [],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    polyline: [[...worldPos]],
                    label: '',
                },
            };
            (0, annotationState_1.addAnnotation)(annotation, element);
            this.activateDraw(evt, annotation, viewportIdsToRender);
            evt.preventDefault();
            (0, triggerAnnotationRenderForViewportIds_1.default)(renderingEngine, viewportIdsToRender);
            return annotation;
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, this.getToolName());
            if (annotation.data.isOpenContour) {
                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);
            }
            else {
                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);
            }
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const points = annotation.data.polyline;
            let previousPoint = viewport.worldToCanvas(points[0]);
            for (let i = 1; i < points.length; i++) {
                const p1 = previousPoint;
                const p2 = viewport.worldToCanvas(points[i]);
                const distance = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);
                if (distance === true) {
                    return true;
                }
                previousPoint = p2;
            }
            if (annotation.data.isOpenContour) {
                return false;
            }
            const pStart = viewport.worldToCanvas(points[0]);
            const pEnd = viewport.worldToCanvas(points[points.length - 1]);
            const distance = pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);
            if (distance === true) {
                return true;
            }
            return false;
        };
        this.cancel = (element) => {
            const isDrawing = this.isDrawing;
            const isEditingOpen = this.isEditingOpen;
            const isEditingClosed = this.isEditingClosed;
            if (isDrawing) {
                this.cancelDrawing(element);
            }
            else if (isEditingOpen) {
                this.cancelOpenContourEdit(element);
            }
            else if (isEditingClosed) {
                this.cancelClosedContourEdit(element);
            }
        };
        this.triggerAnnotationModified = (annotation, enabledElement) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = enums_1.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
            };
            (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
        };
        this.triggerAnnotationCompleted = (annotation) => {
            const eventType = enums_1.Events.ANNOTATION_COMPLETED;
            const eventDetail = {
                annotation,
            };
            (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = ((0, annotationState_1.getAnnotations)(this.getToolName(), element));
            if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
                return renderStatus;
            }
            const isDrawing = this.isDrawing;
            const isEditingOpen = this.isEditingOpen;
            const isEditingClosed = this.isEditingClosed;
            if (!(isDrawing || isEditingOpen || isEditingClosed)) {
                annotations.forEach((annotation) => {
                    if (!annotation)
                        return;
                    this.renderContour(enabledElement, svgDrawingHelper, annotation);
                });
                return renderStatus;
            }
            const activeAnnotationUID = this.commonData.annotation.annotationUID;
            annotations.forEach((annotation) => {
                if (annotation.annotationUID === activeAnnotationUID) {
                    if (isDrawing) {
                        this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);
                    }
                    else if (isEditingClosed) {
                        this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                    }
                    else if (isEditingOpen) {
                        this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                    }
                    else {
                        throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);
                    }
                }
                else {
                    this.renderContour(enabledElement, svgDrawingHelper, annotation);
                }
            });
            return true;
        };
        (0, drawLoop_1.default)(this);
        (0, editLoopCommon_1.default)(this);
        (0, closedContourEditLoop_1.default)(this);
        (0, openContourEditLoop_1.default)(this);
        (0, openContourEndEditLoop_1.default)(this);
        (0, renderMethods_1.default)(this);
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations || !annotations.length) {
            return;
        }
        const enabledElement = (0, core_1.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let annotationsToDisplay;
        if (viewport instanceof core_1.StackViewport) {
            annotationsToDisplay = (0, planar_1.filterAnnotationsForDisplay)(viewport, annotations);
        }
        else if (viewport instanceof core_1.VolumeViewport) {
            const camera = viewport.getCamera();
            const { spacingInNormalDirection } = core_1.utilities.getTargetVolumeAndSpacingInNormalDir(viewport, camera);
            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);
        }
        else {
            throw new Error(`Viewport Type ${viewport.type} not supported`);
        }
        return annotationsToDisplay;
    }
    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
        const { viewPlaneNormal } = camera;
        const annotationsWithParallelNormals = annotations.filter((td) => {
            const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;
            const isParallel = Math.abs(gl_matrix_1.vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >
                PARALLEL_THRESHOLD;
            return annotationViewPlaneNormal && isParallel;
        });
        if (!annotationsWithParallelNormals.length) {
            return [];
        }
        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
        const { focalPoint } = camera;
        const annotationsWithinSlice = [];
        for (const annotation of annotationsWithParallelNormals) {
            const data = annotation.data;
            const point = data.polyline[0];
            if (!annotation.isVisible) {
                continue;
            }
            const dir = gl_matrix_1.vec3.create();
            gl_matrix_1.vec3.sub(dir, focalPoint, point);
            const dot = gl_matrix_1.vec3.dot(dir, viewPlaneNormal);
            if (Math.abs(dot) < halfSpacingInNormalDirection) {
                annotationsWithinSlice.push(annotation);
            }
        }
        return annotationsWithinSlice;
    }
}
PlanarFreehandROITool.toolName = 'PlanarFreehandROI';
exports.default = PlanarFreehandROITool;
//# sourceMappingURL=PlanarFreehandROITool.js.map