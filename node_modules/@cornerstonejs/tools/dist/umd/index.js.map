{"version":3,"file":"index.js","mappings":"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CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,K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","sources":["webpack://cornerstoneTools3D/webpack/universalModuleDefinition","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/regenerator/index.js","webpack://cornerstoneTools3D/../../node_modules/lodash.clonedeep/index.js","webpack://cornerstoneTools3D/../../node_modules/lodash.get/index.js","webpack://cornerstoneTools3D/../../node_modules/regenerator-runtime/runtime.js","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/CellArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/DataArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/Math\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/MatrixBuilder\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/Points\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/AppendPolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/Actor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/Mapper\"","webpack://cornerstoneTools3D/external umd {\"root\":\"cornerstone3D\",\"commonjs\":\"@cornerstonejs/core\",\"commonjs2\":\"@cornerstonejs/core\",\"amd\":\"@cornerstonejs/core\"}","webpack://cornerstoneTools3D/external umd {\"root\":\"window\",\"commonjs\":\"gl-matrix\",\"commonjs2\":\"gl-matrix\",\"amd\":\"gl-matrix\"}","webpack://cornerstoneTools3D/webpack/bootstrap","webpack://cornerstoneTools3D/webpack/runtime/compat get default export","webpack://cornerstoneTools3D/webpack/runtime/define property getters","webpack://cornerstoneTools3D/webpack/runtime/global","webpack://cornerstoneTools3D/webpack/runtime/hasOwnProperty shorthand","webpack://cornerstoneTools3D/webpack/runtime/make namespace object","webpack://cornerstoneTools3D/webpack/runtime/node module decorator","webpack://cornerstoneTools3D/./src/enums/Events.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/createClass.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationLocking.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationSelection.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationVisibility.ts","webpack://cornerstoneTools3D/./src/enums/ToolModes.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.ts","webpack://cornerstoneTools3D/./src/store/svgNodeCache.ts","webpack://cornerstoneTools3D/./src/store/state.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationState.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/helpers/state.ts","webpack://cornerstoneTools3D/./src/constants/COLOR_LUT.ts","webpack://cornerstoneTools3D/./src/enums/SegmentationRepresentations.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourConfig.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/SegmentationStateManager.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/triggerSegmentationEvents.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentationState.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/normalizeSegmentationInput.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/getMouseEventPoints.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseDoubleClickListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseMoveListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseDownListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/wheelListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/normalizeWheel.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/preventGhostClick.js","webpack://cornerstoneTools3D/./src/enums/Touch.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://cornerstoneTools3D/./src/eventListeners/touch/getTouchEventPoints.ts","webpack://cornerstoneTools3D/./src/utilities/touch/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/touchStartListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/keyboard/keyDownListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/keyboard/index.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://cornerstoneTools3D/./src/drawingSvg/getSvgDrawingHelper.ts","webpack://cornerstoneTools3D/./src/drawingSvg/draw.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroupForViewport.ts","webpack://cornerstoneTools3D/./src/utilities/getToolsWithModesForElement.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRender.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/imageRenderedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithModesForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/cameraModifiedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/imageSpacingCalibratedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/customCallbackHandler.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseClick.ts","webpack://cornerstoneTools3D/./src/enums/ToolBindings.ts","webpack://cornerstoneTools3D/./src/store/filterToolsWithMoveableHandles.ts","webpack://cornerstoneTools3D/./src/store/filterToolsWithAnnotationsForElement.ts","webpack://cornerstoneTools3D/./src/store/filterMoveableAnnotationTools.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getMouseModifier.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDown.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDownActivate.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDoubleClick.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDrag.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseMove.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseUp.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseWheel.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForKeyboardEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardEventHandlers/keyDown.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardEventHandlers/keyUp.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForTouchEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithModesForTouchEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchStart.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchStartActivate.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchDrag.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchEnd.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchTap.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchPress.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/store/addEnabledElement.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getSynchronizersForViewport.ts","webpack://cornerstoneTools3D/./src/store/removeEnabledElement.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRenderForViewportIds.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationModifiedListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationSelectionListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroup.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/inherits.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationVisibility.ts","webpack://cornerstoneTools3D/./src/tools/base/BaseTool.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/utils.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourConfigCache.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/addContourSetsToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/updateContourSets.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/addOrUpdateContourSets.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/removeContourFromElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/addLabelmapToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/removeLabelmapFromElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/labelmapDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/SegmentationDisplayTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/triggerSegmentationRender.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationDataModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/removeSegmentationsFromToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/destroyToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/destroy.ts","webpack://cornerstoneTools3D/./src/init.ts","webpack://cornerstoneTools3D/./src/store/addTool.ts","webpack://cornerstoneTools3D/./src/store/cancelActiveManipulations.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/Synchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/createSynchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/destroy.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getSynchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getAllSynchronizers.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/destroySynchronizer.ts","webpack://cornerstoneTools3D/./src/cursors/MouseCursor.ts","webpack://cornerstoneTools3D/./src/enums/AnnotationStyleStates.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/superPropBase.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/get.js","webpack://cornerstoneTools3D/./src/cursors/ImageMouseCursor.ts","webpack://cornerstoneTools3D/./src/cursors/SVGCursorDescriptor.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/ToolStyle.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/helpers.ts","webpack://cornerstoneTools3D/./src/cursors/SVGMouseCursor.ts","webpack://cornerstoneTools3D/./src/cursors/elementCursor.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/ToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/createToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getAllToolGroups.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/cameraSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createCameraPositionSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/voiSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createVOISynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/zoomPanSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createZoomPanSynchronizer.ts","webpack://cornerstoneTools3D/./src/utilities/clip.js","webpack://cornerstoneTools3D/./src/utilities/scroll.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/jumpToSlice.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/areViewportsCoplanar .ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/stackImageSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createStackImageSynchronizer.ts","webpack://cornerstoneTools3D/./src/drawingSvg/_getHash.ts","webpack://cornerstoneTools3D/./src/drawingSvg/_setAttributesIfNecessary.ts","webpack://cornerstoneTools3D/./src/drawingSvg/_setNewAttributesIfValid.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawCircle.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawEllipse.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawHandles.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLine.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawPolyline.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawTextBox.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec2/findClosestPoint.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLink.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLinkedTextBox.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawRect.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawArrow.ts","webpack://cornerstoneTools3D/./src/utilities/getAnnotationNearPoint.ts","webpack://cornerstoneTools3D/./src/utilities/isObject.js","webpack://cornerstoneTools3D/./src/utilities/debounce.js","webpack://cornerstoneTools3D/./src/utilities/throttle.js","webpack://cornerstoneTools3D/./src/utilities/calibrateImageSpacing.ts","webpack://cornerstoneTools3D/./src/utilities/pointInShapeCallback.ts","webpack://cornerstoneTools3D/./src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack://cornerstoneTools3D/./src/utilities/pointInSurroundingSphereCallback.ts","webpack://cornerstoneTools3D/./src/utilities/math/sphere/pointInSphere.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillSphere.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseSphere.ts","webpack://cornerstoneTools3D/./src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack://cornerstoneTools3D/./src/utilities/math/ellipse/pointInEllipse.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillCircle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseCircle.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/activeSegmentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentLocking.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentIndex.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationColor.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/BrushTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/utilities.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/thresholdVolumeByRange.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack://cornerstoneTools3D/./src/utilities/planar/filterAnnotationsWithinSlice.ts","webpack://cornerstoneTools3D/./src/utilities/planar/filterAnnotationsForDisplay.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/getState.ts","webpack://cornerstoneTools3D/./src/tools/base/AnnotationDisplayTool.ts","webpack://cornerstoneTools3D/./src/tools/base/AnnotationTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/rectangle/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getWorldWidthAndHeightFromCorners.ts","webpack://cornerstoneTools3D/./src/utilities/getModalityUnit.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/isViewportPreScaled.ts","webpack://cornerstoneTools3D/./src/tools/annotation/RectangleROITool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleROIThresholdTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack://cornerstoneTools3D/./src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack://cornerstoneTools3D/./src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/isValidRepresentationConfig.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/floodFill.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/brushSizeForToolGroup.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec2/liangBarksyClip.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/intersectLine.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getIntersectionWithPolyline.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/calculateAreaOfPoints.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getPointInLineOfSightWithCriteria.ts","webpack://cornerstoneTools3D/./src/utilities/cine/events.ts","webpack://cornerstoneTools3D/./src/utilities/planar/index.ts","webpack://cornerstoneTools3D/./src/utilities/orientation/getOrientationStringLPS.ts","webpack://cornerstoneTools3D/./src/utilities/orientation/invertOrientationStringLPS.ts","webpack://cornerstoneTools3D/./src/utilities/cine/state.ts","webpack://cornerstoneTools3D/./src/utilities/cine/playClip.ts","webpack://cornerstoneTools3D/../../node_modules/d3-interpolate/src/basis.js","webpack://cornerstoneTools3D/../../node_modules/d3-interpolate/src/quantize.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/transpose.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/min.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/zip.js","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolation/algorithms/bspline.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolatePoints.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/drawLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/editLoopCommon.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/closedContourEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/openContourEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/openContourEndEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/renderMethods.ts","webpack://cornerstoneTools3D/./src/tools/annotation/PlanarFreehandROITool.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolateAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/index.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/state.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackPrefetch.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/jumpToWorld.ts","webpack://cornerstoneTools3D/./src/utilities/dynamicVolume/getDataInTime.ts","webpack://cornerstoneTools3D/./src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack://cornerstoneTools3D/./src/cursors/setCursorForElement.ts","webpack://cornerstoneTools3D/./src/cursors/index.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/getFont.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/validateSegmentationInput.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/validateRepresentationData.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentations.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentationRepresentations.ts","webpack://cornerstoneTools3D/./src/tools/PanTool.ts","webpack://cornerstoneTools3D/./src/tools/TrackballRotateTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/ProbeTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/DragProbeTool.ts","webpack://cornerstoneTools3D/./src/tools/WindowLevelTool.ts","webpack://cornerstoneTools3D/./src/tools/ZoomTool.ts","webpack://cornerstoneTools3D/./src/tools/StackScrollTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/angle/angleBetweenLines.ts","webpack://cornerstoneTools3D/./src/tools/PlanarRotateTool.ts","webpack://cornerstoneTools3D/./src/tools/StackScrollToolMouseWheelTool.ts","webpack://cornerstoneTools3D/./src/tools/VolumeRotateMouseWheelTool.ts","webpack://cornerstoneTools3D/./src/tools/MIPJumpToClickTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/LengthTool.ts","webpack://cornerstoneTools3D/./src/tools/CrosshairsTool.ts","webpack://cornerstoneTools3D/./src/tools/ReferenceLinesTool.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getWorldWidthAndHeightFromTwoPoints.ts","webpack://cornerstoneTools3D/./src/tools/annotation/EllipticalROITool.ts","webpack://cornerstoneTools3D/./src/utilities/math/circle/getCanvasCircleRadius.ts","webpack://cornerstoneTools3D/./src/utilities/math/circle/getCanvasCircleCorners.ts","webpack://cornerstoneTools3D/./src/tools/annotation/CircleROITool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/BidirectionalTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/ArrowAnnotateTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/AngleTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/midPoint.ts","webpack://cornerstoneTools3D/./src/tools/annotation/CobbAngleTool.ts","webpack://cornerstoneTools3D/./src/tools/MagnifyTool.ts","webpack://cornerstoneTools3D/./src/tools/ReferenceCursors.ts","webpack://cornerstoneTools3D/./src/tools/ScaleOverlayTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillRectangle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseRectangle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/CircleScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/SphereScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/PaintFillTool.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"), require(\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@kitware/vtk.js/Filters/General/AppendPolyData\"), require(\"@kitware/vtk.js/Common/Core/CellArray\"), require(\"@kitware/vtk.js/Common/Core/Points\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Rendering/Core/Actor\"), require(\"@kitware/vtk.js/Rendering/Core/Mapper\"), require(\"gl-matrix\"), require(\"@kitware/vtk.js/Common/Core/Math\"), require(\"@kitware/vtk.js/Common/Core/MatrixBuilder\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@cornerstonejs/core\", \"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\", \"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\", \"@kitware/vtk.js/Common/Core/DataArray\", \"@kitware/vtk.js/Filters/General/AppendPolyData\", \"@kitware/vtk.js/Common/Core/CellArray\", \"@kitware/vtk.js/Common/Core/Points\", \"@kitware/vtk.js/Common/DataModel/PolyData\", \"@kitware/vtk.js/Rendering/Core/Actor\", \"@kitware/vtk.js/Rendering/Core/Mapper\", \"gl-matrix\", \"@kitware/vtk.js/Common/Core/Math\", \"@kitware/vtk.js/Common/Core/MatrixBuilder\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneTools3D\"] = factory(require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"), require(\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@kitware/vtk.js/Filters/General/AppendPolyData\"), require(\"@kitware/vtk.js/Common/Core/CellArray\"), require(\"@kitware/vtk.js/Common/Core/Points\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Rendering/Core/Actor\"), require(\"@kitware/vtk.js/Rendering/Core/Mapper\"), require(\"gl-matrix\"), require(\"@kitware/vtk.js/Common/Core/Math\"), require(\"@kitware/vtk.js/Common/Core/MatrixBuilder\"));\n\telse\n\t\troot[\"cornerstoneTools3D\"] = factory(root[\"cornerstone3D\"], root[\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"], root[\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"], root[\"@kitware/vtk.js/Common/Core/DataArray\"], root[\"@kitware/vtk.js/Filters/General/AppendPolyData\"], root[\"@kitware/vtk.js/Common/Core/CellArray\"], root[\"@kitware/vtk.js/Common/Core/Points\"], root[\"@kitware/vtk.js/Common/DataModel/PolyData\"], root[\"@kitware/vtk.js/Rendering/Core/Actor\"], root[\"@kitware/vtk.js/Rendering/Core/Mapper\"], root[\"window\"], root[\"@kitware/vtk.js/Common/Core/Math\"], root[\"@kitware/vtk.js/Common/Core/MatrixBuilder\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__953__, __WEBPACK_EXTERNAL_MODULE__441__, __WEBPACK_EXTERNAL_MODULE__795__, __WEBPACK_EXTERNAL_MODULE__785__, __WEBPACK_EXTERNAL_MODULE__127__, __WEBPACK_EXTERNAL_MODULE__396__, __WEBPACK_EXTERNAL_MODULE__348__, __WEBPACK_EXTERNAL_MODULE__70__, __WEBPACK_EXTERNAL_MODULE__474__, __WEBPACK_EXTERNAL_MODULE__610__, __WEBPACK_EXTERNAL_MODULE__976__, __WEBPACK_EXTERNAL_MODULE__807__, __WEBPACK_EXTERNAL_MODULE__847__) {\nreturn ","module.exports = require(\"regenerator-runtime\");\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__396__;","module.exports = __WEBPACK_EXTERNAL_MODULE__785__;","module.exports = __WEBPACK_EXTERNAL_MODULE__807__;","module.exports = __WEBPACK_EXTERNAL_MODULE__847__;","module.exports = __WEBPACK_EXTERNAL_MODULE__348__;","module.exports = __WEBPACK_EXTERNAL_MODULE__441__;","module.exports = __WEBPACK_EXTERNAL_MODULE__70__;","module.exports = __WEBPACK_EXTERNAL_MODULE__127__;","module.exports = __WEBPACK_EXTERNAL_MODULE__474__;","module.exports = __WEBPACK_EXTERNAL_MODULE__795__;","module.exports = __WEBPACK_EXTERNAL_MODULE__610__;","module.exports = __WEBPACK_EXTERNAL_MODULE__953__;","module.exports = __WEBPACK_EXTERNAL_MODULE__976__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/**\n *  The events for cornerstoneTools3D Tools. Native Mouse and Keyboard events are\n *  captured, normalized, and re-triggered with a `CORNERSTONE_TOOLS` prefix. This\n *  allows us to handle events consistently across different browsers.\n *\n */\nenum Events {\n  ///////////////////////////////////////\n  //            Annotations\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new annotation is added to the state.\n   *\n   * Make use of {@link EventTypes.AnnotationAddedEventType | Annotation Added Event Type  }\n   * for typing your event listeners for this annotation added event, and see what event\n   * detail is included in {@link EventTypes.AnnotationAddedEventDetail | Annotation Added Event Detail}.\n   */\n  ANNOTATION_ADDED = 'CORNERSTONE_TOOLS_ANNOTATION_ADDED',\n\n  /**\n   * Triggers on the eventTarget when a new annotation is completed its drawing\n   * Make use of {@link EventTypes.AnnotationCompletedEventType | Annotation Completed Event Type }\n   * for typing your event listeners for this annotation completed event, and see what event\n   * detail is included in {@link EventTypes.AnnotationCompletedEventDetail | Annotation Completed Event Detail}.\n   */\n  ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is modified (e.g. a handle is modified).\n   * Make use of {@link EventTypes.AnnotationModifiedEventType | Annotation Modified Event Type}\n   * for typing your event listeners for this annotation modified event, and see what\n   * event detail is included in {@link EventTypes.AnnotationModifiedEventDetail | Annotation Modified Event Detail}.\n   */\n  ANNOTATION_MODIFIED = 'CORNERSTONE_TOOLS_ANNOTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is removed from the annotations manager.\n   * Make use of {@link EventTypes.AnnotationRemovedEventType | Annotation Removed Event Type}\n   * for typing your event listeners for this annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRemovedEventDetail | Annotation Removed Event Detail}.\n   */\n  ANNOTATION_REMOVED = 'CORNERSTONE_TOOLS_ANNOTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when an annotation selection status is changed.\n   * Make use of {@link EventTypes.AnnotationSelectionChangeEventType | Annotation Selection Change Event Type}\n   * for typing your event listeners for this annotation selection change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationSelectionChangeEventDetail | Annotation Selection Change Event Detail}.\n   */\n  ANNOTATION_SELECTION_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation locked status is changed.\n   * Make use of {@link EventTypes.AnnotationLockChangeEventType | Annotation Lock Change Event Type}\n   * for typing your event listeners for this annotation lock change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationLockChangeEventDetail | Annotation Lock Change Event Detail}.\n   */\n  ANNOTATION_LOCK_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation visible status is changed.\n   * Make use of {@link EventTypes.AnnotationVisibilityChangeEventType | Annotation Visible Change Event Type}\n   * for typing your event listeners for this annotation Hide change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationVisibilityChangeEventDetail | Annotation Visible Change Event Detail}.\n   */\n  ANNOTATION_VISIBILITY_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation is rendered.\n   * Make use of {@link EventTypes.AnnotationRenderedEventType | Annotation Rendered Event Type}\n   * for typing your event listeners for this annotation rendered event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRenderedEventDetail | Annotation Rendered Event Detail}.\n   */\n  ANNOTATION_RENDERED = 'CORNERSTONE_TOOLS_ANNOTATION_RENDERED',\n\n  ///////////////////////////////////////\n  //        Segmentations Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is updated in the state manager.\n   * Make use of {@link EventTypes.SegmentationModifiedEventType | Segmentation Modified Event Type}\n   * for typing your event listeners for this segmentation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationModifiedEventDetail | Segmentation Modified Event Detail}.\n   */\n  SEGMENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is rendered by the Segmentation Rendering Engine.\n   * Make use of {@link EventTypes.SegmentationRenderedEventType | Segmentation Rendered Event Type}\n   * for typing your event listeners for this segmentation rendered event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRenderedEventDetail | Segmentation Rendered Event Detail}.\n   */\n  SEGMENTATION_RENDERED = 'CORNERSTONE_TOOLS_SEGMENTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is modified in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationModifiedEventType | Segmentation Representation Modified Event Type}\n   * for typing your event listeners for this segmentation representation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationModifiedEventDetail | Segmentation Representation Modified Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is removed from the state manager.\n   * Make use of {@link EventTypes.SegmentationRemovedEventType | Segmentation Removed Event Type}\n   * for typing your event listeners for this segmentation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRemovedEventDetail | Segmentation Removed Event Detail}.\n   */\n  SEGMENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is removed in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationRemovedEventType | Segmentation Representation Removed Event Type}\n   * for typing your event listeners for this segmentation representation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationRemovedEventDetail | Segmentation Representation Removed Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation data is modified (e.g., by brush tool).\n   * Make use of {@link EventTypes.SegmentationDataModifiedEventType | Segmentation Data Modified Event Type}\n   * for typing your event listeners for this segmentation data modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationDataModifiedEventDetail | Segmentation Data Modified Event Detail}.\n   */\n  SEGMENTATION_DATA_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED',\n\n  ///////////////////////////////////////\n  //         Keyboard Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is pressed.\n   * Make use of {@link EventTypes.KeyDownEventType | Key Down Event Type}\n   * for typing your event listeners for this key down event, and see what\n   * event detail is included in {@link EventTypes.KeyDownEventDetail | Key Down Event Detail}.\n   */\n  KEY_DOWN = 'CORNERSTONE_TOOLS_KEY_DOWN',\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is released.\n   * Make use of {@link EventTypes.KeyUpEventType | Key Up Event Type}\n   * for typing your event listeners for this key up event, and see what\n   * event detail is included in {@link EventTypes.KeyUpEventDetail | Key Up Event Detail}.\n   */\n  KEY_UP = 'CORNERSTONE_TOOLS_KEY_UP',\n\n  ///////////////////////////////////////\n  //      Mouse Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when the mouse is pressed down, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDownEventType | Mouse Down Event Type}\n   * for typing your event listeners for this mouse down event, and see what\n   * event detail is included in {@link EventTypes.MouseDownEventDetail | Mouse Down Event Detail}.\n   */\n  MOUSE_DOWN = 'CORNERSTONE_TOOLS_MOUSE_DOWN',\n\n  /**\n   * Triggers on the eventTarget when the mouse is released, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseUpEventType | Mouse Up Event Type}\n   * for typing your event listeners for this mouse up event, and see what\n   * event detail is included in {@link EventTypes.MouseUpEventDetail | Mouse Up Event Detail}.\n   */\n  MOUSE_UP = 'CORNERSTONE_TOOLS_MOUSE_UP',\n\n  /**\n   * Triggers on the eventTarget when a handled `MOUSE_DOWN` event does not `stopPropagation`. The hook\n   * we use to create new annotation for mouse events.\n   * Make use of {@link EventTypes.MouseDownActivateEventType | Mouse Down Activate Event Type}\n   * for typing your event listeners for this mouse down activate event, and see what\n   * event detail is included in {@link EventTypes.MouseDownActivateEventDetail | Mouse Down Activate Event Detail}.\n   */\n  MOUSE_DOWN_ACTIVATE = 'CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE',\n\n  /**\n   * Triggers on the event target when mouse is dragging an annotation or textBox.\n   * Make use of {@link EventTypes.MouseDragEventType | Mouse Drag Event Type}\n   * for typing your event listeners for this mouse drag event, and see what\n   * event detail is included in {@link EventTypes.MouseDragEventDetail | Mouse Drag Event Detail}.\n   */\n  MOUSE_DRAG = 'CORNERSTONE_TOOLS_MOUSE_DRAG',\n\n  /**\n   * Triggers on the eventTarget, when the mouse is moved, it is CornerstoneTools normalized event.\n   * It can be just a mouse move or when double click is performed and annotation\n   * drawing can be performed with just mouse move.\n   * Make use of {@link EventTypes.MouseMoveEventType | Mouse Move Event Type}\n   * for typing your event listeners for this mouse move event, and see what\n   * event detail is included in {@link EventTypes.MouseMoveEventDetail | Mouse Move Event Detail}.\n   */\n  MOUSE_MOVE = 'CORNERSTONE_TOOLS_MOUSE_MOVE',\n\n  /**\n   * Triggers on the eventTarget when a mouse click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseClickEventType | Mouse Click Event Type}\n   * for typing your event listeners for this mouse click event, and see what\n   * event detail is included in {@link EventTypes.MouseClickEventDetail | Mouse Click Event Detail}.\n   */\n  MOUSE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse double click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDoubleClickEventType | Mouse Double Click Event Type}\n   * for typing your event listeners for this mouse double click event, and see what\n   * event detail is included in {@link EventTypes.MouseDoubleClickEventDetail | Mouse Double Click Event Detail}.\n   */\n  MOUSE_DOUBLE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse wheel event is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseWheelEventType | Mouse Wheel Event Type}\n   * for typing your event listeners for this mouse wheel event, and see what\n   * event detail is included in {@link EventTypes.MouseWheelEventDetail | Mouse Wheel Event Detail}.\n   */\n  MOUSE_WHEEL = 'CORNERSTONE_TOOLS_MOUSE_WHEEL',\n\n  // Todo: not being fired as of now\n  // ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n  // Todo: not implemented yet\n  // KEY_PRESS = 'CORNERSTONE_TOOLS_KEY_PRESS',\n\n  //////////////////////\n  //   Touch Events   //\n  //////////////////////\n  // The event flow looks like the following\n  // Touch Start -> (optional) Touch Press -> Touch Drag -> (optional) Touch Swipe -> Touch End\n  // Touch Tap\n  // mousedown\n  // mousedown, Touch Start, and Tap are mutually exclusive events\n  TOUCH_START = 'CORNERSTONE_TOOLS_TOUCH_START',\n  TOUCH_START_ACTIVATE = 'CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE',\n  TOUCH_PRESS = 'CORNERSTONE_TOOLS_TOUCH_PRESS',\n  TOUCH_DRAG = 'CORNERSTONE_TOOLS_TOUCH_DRAG',\n  TOUCH_END = 'CORNERSTONE_TOOLS_TOUCH_END',\n  TOUCH_TAP = 'CORNERSTONE_TOOLS_TAP',\n  TOUCH_SWIPE = 'CORNERSTONE_TOOLS_SWIPE',\n}\n\nexport default Events;\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationLockChangeEventDetail } from '../../types/EventTypes';\n\n/*\n * Constants\n */\nconst globalLockedAnnotationsSet: Set<Annotation> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"Locked\" state of a given annotation instance.\n *\n * @triggers ANNOTATION_LOCK_CHANGE\n *\n * @param annotation - The annotation instance which will have\n * its locked state changed. An event will only be triggered if the locked state\n * of the given annotation instance changed.\n * @param locked - A boolean value indicating if the instance should\n * be locked (true) or not (false)\n */\nfunction setAnnotationLocked(annotation: Annotation, locked = true): void {\n  const detail = makeEventDetail();\n  if (annotation) {\n    if (locked) {\n      lock(annotation, globalLockedAnnotationsSet, detail);\n    } else {\n      unlock(annotation, globalLockedAnnotationsSet, detail);\n    }\n  }\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Clears all the locked annotation\n *\n */\nfunction unlockAllAnnotations(): void {\n  const detail = makeEventDetail();\n  clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Returns an array of all the annotation that is currently locked\n * @returns An array of tool specific annotation objects.\n *\n */\nfunction getAnnotationsLocked(): Array<Annotation> {\n  return Array.from(globalLockedAnnotationsSet);\n}\n\n/**\n * Given a Annotation object, return true if it is locked.\n * @param annotation - Annotation\n * @returns A boolean value.\n */\nfunction isAnnotationLocked(annotation: Annotation): boolean {\n  return globalLockedAnnotationsSet.has(annotation);\n}\n\n/**\n * Get the number of locked annotation objects in the global set of locked annotation\n * objects.\n * @returns The number of locked annotation objects.\n *\n */\nfunction getAnnotationsLockedCount(): number {\n  return globalLockedAnnotationsSet.size;\n}\n\n/**\n * Properly initialize the isLocked on annotation, and set it as locked if\n * isLocked is true.\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsLockedProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isLocked = !!annotation.isLocked;\n    if (shouldDefineIsLockedProperty(annotation)) {\n      Object.defineProperty(annotation, 'isLocked', {\n        configurable: false,\n        enumerable: true,\n        set: setIsLocked,\n        get: getIsLocked,\n      });\n    }\n    setAnnotationLocked(annotation, isLocked);\n  }\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationLockChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    locked: [],\n  });\n}\n\nfunction lock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (!lockedAnnotationsSet.has(annotation)) {\n    lockedAnnotationsSet.add(annotation);\n    detail.added.push(annotation);\n  }\n}\n\nfunction unlock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (lockedAnnotationsSet.delete(annotation)) {\n    detail.removed.push(annotation);\n  }\n}\n\nfunction clearLockedAnnotationsSet(\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  lockedAnnotationsSet.forEach((annotation) => {\n    unlock(annotation, lockedAnnotationsSet, detail);\n  });\n}\n\nfunction publish(\n  detail: AnnotationLockChangeEventDetail,\n  lockedAnnotationsSet: Set<Annotation>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsLockedProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsLocked(locked: boolean) {\n  setAnnotationLocked(this as Annotation, locked);\n}\n\nfunction getIsLocked() {\n  return isAnnotationLocked(this as Annotation);\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationLocked,\n  getAnnotationsLocked,\n  getAnnotationsLockedCount,\n  unlockAllAnnotations,\n  isAnnotationLocked,\n  checkAndDefineIsLockedProperty,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { AnnotationSelectionChangeEventDetail } from '../../types/EventTypes';\nimport { getAnnotation } from './annotationState';\n\n/*\n * Constants\n */\n\nconst selectedAnnotationUIDs: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set a given annotationUID as selected or deselected based on the provided\n * selected value.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param selected - When true, the annotation is selected. When false, the annotation is deselected.\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction setAnnotationSelected(\n  annotationUID: string,\n  selected = true,\n  preserveSelected = false\n): void {\n  if (selected) {\n    selectAnnotation(annotationUID, preserveSelected);\n  } else {\n    deselectAnnotation(annotationUID);\n  }\n}\n\n/**\n * Set a given annotation as selected.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction selectAnnotation(\n  annotationUID: string,\n  preserveSelected = false\n): void {\n  const detail = makeEventDetail();\n  if (!preserveSelected) {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n    selectedAnnotationUIDs.add(annotationUID);\n    detail.added.push(annotationUID);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Deselect one or all annotations.\n *\n * @param annotationUID - If an annotation is provided that instance will be removed from\n * the internal selection set. If none is given, ALL selections will be cleared.\n */\nfunction deselectAnnotation(annotationUID?: string): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (selectedAnnotationUIDs.delete(annotationUID)) {\n      detail.removed.push(annotationUID);\n    }\n  } else {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Return an array of ALL the selected annotationUIDs\n * @returns An array of Annotation UIDs\n */\nfunction getAnnotationsSelected(): Array<string> {\n  return Array.from(selectedAnnotationUIDs);\n}\n\n/**\n * Given a tool name, return ALL the annotationUIDs for that tool that are selected\n * @param toolName - The name of the tool you want to get the selected annotation for\n * @returns An array of annotationUIDs\n */\nfunction getAnnotationsSelectedByToolName(toolName: string): Array<string> {\n  return getAnnotationsSelected().filter((annotationUID) => {\n    const annotation = getAnnotation(annotationUID);\n    return annotation.metadata.toolName === toolName;\n  });\n}\n\n/**\n * Given an annotationUID, return true if it is selected, false\n * otherwise.\n * @param annotationUID - Annotation UID\n * @returns A boolean value.\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return selectedAnnotationUIDs.has(annotationUID);\n}\n\n/**\n * Return the number of the selected annotation\n * @returns The size of the selected annotation set\n */\nfunction getAnnotationsSelectedCount(): number {\n  return selectedAnnotationUIDs.size;\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationSelectionChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    selection: [],\n  });\n}\n\nfunction clearSelectionSet(\n  selectionSet: Set<string>,\n  detail: AnnotationSelectionChangeEventDetail\n): void {\n  selectionSet.forEach((value) => {\n    if (selectionSet.delete(value)) {\n      detail.removed.push(value);\n    }\n  });\n}\n\nfunction publish(\n  detail: AnnotationSelectionChangeEventDetail,\n  selectionSet: Set<string>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    selectionSet.forEach((item) => void detail.selection.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n  }\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationSelected,\n  getAnnotationsSelected,\n  getAnnotationsSelectedByToolName,\n  getAnnotationsSelectedCount,\n  deselectAnnotation,\n  isAnnotationSelected,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotation } from './annotationState';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationVisibilityChangeEventDetail } from '../../types/EventTypes';\nimport {\n  isAnnotationSelected,\n  deselectAnnotation,\n} from './annotationSelection';\n\n/*\n * It stores all hidden annotation uids.\n */\nconst globalHiddenAnnotationUIDsSet: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"visible\" state of a given annotation instance.\n *\n * @event ANNOTATION_VISIBILITY_CHANGE\n *\n * @param annotationUID - The annotation uid which will have\n * its visible state changed. An event will only be triggered if the visible state\n * of the given annotation instance changed.\n * @param visible - A boolean value indicating if the instance should\n * be visible (true) or not (false)\n */\nfunction setAnnotationVisibility(annotationUID: string, visible = true): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (visible) {\n      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    } else {\n      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    }\n  }\n  publish(detail);\n}\n\n/**\n * Clears all the hidden annotations.\n *\n */\nfunction showAllAnnotations(): void {\n  const detail = makeEventDetail();\n  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n  });\n  publish(detail);\n}\n\n/**\n * Given an annotation UID, return true if it is visible, false if hidden and undefined if does not exist.\n * @param annotationUID - The annotation uid to tell if is visible or not.\n * @returns A boolean value or value if does not exist.\n */\nfunction isAnnotationVisible(annotationUID: string): boolean | undefined {\n  const annotation = getAnnotation(annotationUID);\n\n  if (annotation) {\n    return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n  }\n}\n/**\n * It decorates given annotation with isVisible property.\n * It properly initializes the isVisible on annotation(the property will be create if does not exist yet)\n *\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsVisibleProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isVisible = annotation.isVisible ?? true;\n    if (shouldDefineIsVisibleProperty(annotation)) {\n      Object.defineProperty(annotation, 'isVisible', {\n        configurable: false,\n        enumerable: true,\n        set: setIsVisible,\n        get: getIsVisible,\n      });\n    }\n    setAnnotationVisibility(annotation.annotationUID, isVisible);\n  }\n}\n\n/*\n * Private Helpers\n */\nfunction makeEventDetail(): AnnotationVisibilityChangeEventDetail {\n  return Object.freeze({\n    lastVisible: [],\n    lastHidden: [],\n    hidden: [],\n  });\n}\n\nfunction show(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (annotationUIDsSet.delete(annotationUID)) {\n    detail.lastVisible.push(annotationUID);\n  }\n}\n\nfunction hide(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (!annotationUIDsSet.has(annotationUID)) {\n    annotationUIDsSet.add(annotationUID);\n    if (isAnnotationSelected(annotationUID)) {\n      deselectAnnotation(annotationUID);\n    }\n    detail.lastHidden.push(annotationUID);\n  }\n}\n\nfunction publish(detail: AnnotationVisibilityChangeEventDetail) {\n  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n    globalHiddenAnnotationUIDsSet.forEach(\n      (item) => void detail.hidden.push(item)\n    );\n    triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsVisibleProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsVisible(hidden: boolean) {\n  setAnnotationVisibility((this as Annotation).annotationUID, hidden);\n}\n\nfunction getIsVisible() {\n  return isAnnotationVisible((this as Annotation).annotationUID);\n}\n\nexport {\n  setAnnotationVisibility,\n  showAllAnnotations,\n  isAnnotationVisible,\n  checkAndDefineIsVisibleProperty,\n};\n","/**\n * ToolModes - This enum defines the 4 tool states which are available.\n */\nenum ToolModes {\n  /**\n   * Active:\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Active = 'Active',\n  /**\n   * Passive:\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Passive = 'Passive',\n  /**\n   * Enabled:\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Enabled = 'Enabled',\n  /**\n   * Disabled:\n   * - Annotation does not render.\n   */\n  Disabled = 'Disabled',\n}\n\nexport default ToolModes;\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  Annotation,\n  Annotations,\n  AnnotationState,\n  GroupSpecificAnnotations,\n} from '../../types/AnnotationTypes';\n\nimport { AnnotationGroupSelector, IAnnotationManager } from '../../types';\n\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\n\n/**\n * This is the default annotation manager. It stores annotations by default\n * based on the FrameOfReferenceUID. However, it is possible to override the\n * getAnnotationStateKey function to store annotations based on any other\n * property of the element. When you write your custom annotation manager, you\n * can use the setAnnotationManager function to set your custom annotation.\n *\n * Note that this class is a singleton and should not be instantiated directly.\n * To get the stored annotations information you can use ToolState helpers.\n */\nclass FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {\n  private annotations: AnnotationState;\n  public readonly uid: string;\n\n  /**\n   * @param uid - The uid of the state manager. If omitted it is autogenerated.\n   */\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = utilities.uuidv4();\n    }\n    this.annotations = {};\n    this.uid = uid;\n\n    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.\n    eventTarget.addEventListener(\n      Enums.Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedHandler\n    );\n  }\n\n  /**\n   * Default annotation manager works with FrameOfReferenceUID as the key. The\n   * manager adds them under the FrameOfReferenceUID for the element being\n   * annotated.\n   *\n   * @param annotationGroupSelector - element or a string that is provided\n   * to the annotation manager to get the key.\n   * @returns - The annotation state key for the element.\n   */\n  getGroupKey = (annotationGroupSelector: AnnotationGroupSelector): string => {\n    if (typeof annotationGroupSelector === 'string') {\n      return annotationGroupSelector;\n    }\n\n    const element = annotationGroupSelector;\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      throw new Error(\n        'Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID'\n      );\n    }\n\n    return enabledElement.FrameOfReferenceUID;\n  };\n\n  /**\n   * When a volume is modified we invalidate all of the `annotations` on the\n   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations\n   * when an annotation is drawn whilst data is still loading.\n   *\n   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.\n   */\n  _imageVolumeModifiedHandler = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const eventDetail = evt.detail;\n    const { FrameOfReferenceUID } = eventDetail;\n\n    const annotations = this.annotations;\n    const frameOfReferenceSpecificAnnotations =\n      annotations[FrameOfReferenceUID];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      return;\n    }\n\n    Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      toolSpecificAnnotations.forEach((annotation) => {\n        const invalidated = annotation.invalidated;\n\n        if (invalidated !== undefined) {\n          annotation.invalidated = true;\n        }\n      });\n    });\n  };\n\n  /**\n   * Returns all the available frameOfReferences inside the state manager\n   * @returns - All the added frames of references inside the manager\n   */\n  getFramesOfReference = (): Array<string> => {\n    return Object.keys(this.annotations);\n  };\n\n  /**\n   * Returns the annotations associated with the specified frameOfReference and tool, or\n   * all annotations for the group if the tool name is not provided.\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns The annotations associated with the specified group (default FrameOfReferenceUID) and tool,\n   * or all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   */\n  getAnnotations = (\n    groupKey: string,\n    toolName?: string\n  ): GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (!annotations[groupKey]) {\n      return [];\n    }\n\n    if (toolName) {\n      return annotations[groupKey][toolName];\n    }\n\n    return annotations[groupKey];\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, returns the `annotation`\n   * from the `annotations`. Each `annotation` has a unique identifier.\n   *\n   * @param annotationUID - The unique identifier of the `annotation`.\n   * @returns The retrieved `annotation`.\n   */\n  getAnnotation = (annotationUID: string): Annotation | undefined => {\n    const annotations = this.annotations;\n\n    for (const frameOfReferenceUID in annotations) {\n      const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n\n      for (const toolName in frameOfReferenceAnnotations) {\n        const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n\n        for (const annotation of toolSpecificAnnotations) {\n          if (annotationUID === annotation.annotationUID) {\n            return annotation;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * A function that returns the number of annotations for a given tool in the\n   * specific group (default FrameOfReferenceUID) IF no groupKey (FrameOfReferenceUID) is provided,\n   * it will return the number of annotations for the tool in all groups (FrameOfReferenceUIDs)\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - The name of the tool to retrieve data for.\n   *\n   * @returns The number of annotations for a given tool in the state\n   */\n  getNumberOfAnnotations = (groupKey: string, toolName?: string): number => {\n    const annotations = this.getAnnotations(groupKey, toolName);\n\n    if (!annotations.length) {\n      return 0;\n    }\n\n    if (toolName) {\n      return (annotations as Annotations).length;\n    }\n\n    let total = 0;\n\n    for (const toolName in annotations) {\n      total += annotations[toolName].length;\n    }\n\n    return total;\n  };\n\n  /**\n   * Adds an instance of `Annotation` to the `annotations`.\n   *\n   * @param annotation - The annotation to add.\n   * @param groupKey - The annotation group key to add the annotation to (in default manager it is FrameOfReferenceUID).\n   */\n  addAnnotation = (annotation: Annotation, groupKey?: string): void => {\n    const { metadata } = annotation;\n    const { FrameOfReferenceUID, toolName } = metadata;\n\n    groupKey = groupKey || FrameOfReferenceUID;\n\n    const annotations = this.annotations;\n\n    let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      annotations[groupKey] = {};\n\n      frameOfReferenceSpecificAnnotations = annotations[groupKey];\n    }\n\n    let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n\n    if (!toolSpecificAnnotations) {\n      frameOfReferenceSpecificAnnotations[toolName] = [];\n\n      toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n    }\n\n    toolSpecificAnnotations.push(annotation);\n    checkAndDefineIsLockedProperty(annotation);\n    checkAndDefineIsVisibleProperty(annotation);\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, removes the `annotation`\n   * from the `annotations`.\n   *\n   * @param annotationUID - The unique identifier of the `annotation` to remove.\n   */\n  removeAnnotation = (annotationUID: string): void => {\n    const { annotations } = this;\n\n    for (const groupKey in annotations) {\n      const groupAnnotations = annotations[groupKey];\n\n      for (const toolName in groupAnnotations) {\n        const toolAnnotations = groupAnnotations[toolName];\n\n        const index = toolAnnotations.findIndex(\n          (annotation) => annotation.annotationUID === annotationUID\n        );\n\n        if (index !== -1) {\n          toolAnnotations.splice(index, 1);\n\n          if (toolAnnotations.length === 0) {\n            delete groupAnnotations[toolName];\n          }\n        }\n      }\n\n      if (Object.keys(groupAnnotations).length === 0) {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\n   * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   *\n   * @param groupKey - The group key to remove annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to remove annotations for.\n   */\n  removeAnnotations = (groupKey: string, toolName?: string): void => {\n    const annotations = this.annotations;\n    if (annotations[groupKey]) {\n      if (toolName) {\n        delete annotations[groupKey][toolName];\n      } else {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Returns a section of the annotations. Useful for serialization.\n   * If both groupKey (default manager is FrameOfReferenceUID) and toolName are provided, returns the corresponding Annotations instance\n   * for that groupKey (FrameOfReferenceUID) and toolName.\n   * If only groupKey is provided, returns the corresponding FrameOfReferenceSpecificAnnotations instance\n   * for that groupKey.\n   * If neither groupKey nor toolName is provided, returns the entire AnnotationState object.\n   * @param groupKey - Optional. The group key (e.g. FrameOfReferenceUID) to retrieve annotations for.\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns A section of the annotations.\n   */\n  saveAnnotations = (\n    groupKey?: string,\n    toolName?: string\n  ): AnnotationState | GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        return;\n      }\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      return cloneDeep(toolSpecificAnnotations);\n    } else if (groupKey) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      return cloneDeep(frameOfReferenceSpecificAnnotations);\n    }\n\n    return cloneDeep(annotations);\n  };\n\n  /**\n   * Restores a section of the `annotations`. Useful for loading in serialized data.\n   *\n   * - If no arguments are given, the entire `AnnotationState` instance is restored.\n   * - If the `FrameOfReferenceUID` is given, the corresponding\n   * `FrameOfReferenceSpecificAnnotations` instance is restored.\n   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the\n   * corresponding `Annotations` instance is restored.\n   *\n   * @param groupKey - A filter string for restoring only the `annotations` of a specific frame of reference.\n   * @param toolName - A filter string for restoring `annotation` for a specific tool on a specific frame of reference.\n   */\n  restoreAnnotations = (\n    state: AnnotationState | GroupSpecificAnnotations | Annotations,\n    groupKey?: string,\n    toolName?: string\n  ): void => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      // Set Annotations for FrameOfReferenceUID and toolName.\n\n      let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        annotations[groupKey] = {};\n\n        frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      }\n\n      frameOfReferenceSpecificAnnotations[toolName] = <Annotations>state;\n    } else if (groupKey) {\n      // Set FrameOfReferenceSpecificAnnotations for FrameOfReferenceUID.\n\n      annotations[groupKey] = <GroupSpecificAnnotations>state;\n    } else {\n      // Set entire annotations\n      this.annotations = <AnnotationState>cloneDeep(state);\n    }\n  };\n\n  /**\n   * A function that returns the number of all annotations in the annotation state\n   *\n   * @returns The number of all annotations in the state\n   */\n  getNumberOfAllAnnotations = (): number => {\n    let count = 0;\n    const annotations = this.annotations;\n    for (const groupKey in annotations) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      for (const toolName in frameOfReferenceSpecificAnnotations) {\n        const toolSpecificAnnotations =\n          frameOfReferenceSpecificAnnotations[toolName];\n        count += toolSpecificAnnotations.length;\n      }\n    }\n    return count;\n  };\n\n  /**\n   * Removes all annotations in the annotation state.\n   */\n  removeAllAnnotations = (): void => {\n    this.annotations = {};\n  };\n}\n\nconst defaultFrameOfReferenceSpecificAnnotationManager =\n  new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\n\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","let svgNodeCache = {};\n\nexport function resetSvgNodeCache(): void {\n  svgNodeCache = {};\n}\n\nexport default svgNodeCache;\n","import _cloneDeep from 'lodash.clonedeep';\n\nimport { IToolGroup, IToolClassReference } from '../types';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\n\ninterface ICornerstoneTools3dState {\n  isInteractingWithTool: boolean;\n  isMultiPartToolActive: boolean;\n  tools: Record<\n    string,\n    {\n      toolClass: IToolClassReference;\n    }\n  >;\n  toolGroups: Array<IToolGroup>;\n  synchronizers: Array<Synchronizer>;\n  svgNodeCache: Record<string, unknown>;\n  enabledElements: Array<unknown>;\n  handleRadius: number;\n}\n\nconst defaultState: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nlet state: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nfunction resetCornerstoneToolsState(): void {\n  resetSvgNodeCache();\n  state = _cloneDeep(defaultState);\n}\n\nexport {\n  ICornerstoneTools3dState,\n  resetCornerstoneToolsState,\n  state,\n  state as default,\n};\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\nimport { ToolModes } from '../../enums';\n\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\n\n/**\n * Returns the toolGroups that has the given toolName as active, passive\n * or enabled.\n * @param toolName - The name of the tool\n * @returns An array of tool groups.\n */\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\n  return state.toolGroups.filter(({ toolOptions }) => {\n    const toolGroupToolNames = Object.keys(toolOptions);\n\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\n      if (toolName !== toolGroupToolNames[i]) continue;\n\n      /* filter out tools that don't have options */\n      if (!toolOptions[toolName]) {\n        continue;\n      }\n\n      if (MODES.includes(toolOptions[toolName].mode)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport default getToolGroupsWithToolName;\n","import {\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { Annotations, Annotation } from '../../types/AnnotationTypes';\nimport { AnnotationRemovedEventDetail } from '../../types/EventTypes';\nimport { AnnotationGroupSelector } from '../../types';\nimport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n} from './helpers/state';\n\n// our default annotation manager\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n\n/**\n * It returns the default annotations manager.\n * @returns the singleton default annotations manager.\n */\nfunction getAnnotationManager() {\n  return defaultManager;\n}\n\n/**\n * Set the annotation manager to be used for rendering, adding, removing, etc.\n * @param annotationManager - The annotation manager to be used\n */\nfunction setAnnotationManager(annotationManager) {\n  defaultManager = annotationManager;\n}\n\n// set back to default frameOfReferenceSpecificAnnotationManager\nfunction resetAnnotationManager() {\n  defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\n\n/**\n * Returns the annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getAnnotations function will return the annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n * @returns The annotations corresponding to the Frame of Reference and the toolName.\n */\nfunction getAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): Annotations {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n  return manager.getAnnotations(groupKey, toolName) as Annotations;\n}\n\n/**\n * Add the annotation to the annotation manager along with the options that is\n * used to filter the annotation manager and the annotation group that\n * the annotation belongs to.\n *\n * As a result, our default implementation will add the annotation to the\n * default manager using the FrameOfReferenceUID as the group key.\n *\n * @param annotation - The annotation that is being added to the annotations manager.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n */\nfunction addAnnotation(\n  annotation: Annotation,\n  annotationGroupSelector: AnnotationGroupSelector\n): string {\n  if (annotation.annotationUID === undefined) {\n    annotation.annotationUID = csUtils.uuidv4() as string;\n  }\n\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  manager.addAnnotation(annotation, groupKey);\n\n  // if the annotation manager selector is an element, trigger the\n  // annotation added event for that element.\n  if (annotationGroupSelector instanceof HTMLDivElement) {\n    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n  }\n\n  // if no element is provided, render all viewports that have the\n  // same frame of reference.\n  // Todo: we should do something else here for other types of annotation managers.\n  triggerAnnotationAddedForFOR(annotation);\n\n  return annotation.annotationUID;\n}\n\n/**\n * Get the number of annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getNumberOfAnnotations function will return the number of annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n *\n */\nfunction getNumberOfAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): number {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  return manager.getNumberOfAnnotations(groupKey, toolName);\n}\n\n/**\n * Remove the annotation by UID of the annotation.\n * @param annotationUID - The unique identifier for the annotation.\n */\nfunction removeAnnotation(annotationUID: string): void {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  // no need to continue in case there is no annotation.\n  if (!annotation) {\n    return;\n  }\n\n  manager.removeAnnotation(annotationUID);\n\n  // trigger annotation removed\n  const eventType = Events.ANNOTATION_REMOVED;\n\n  const eventDetail: AnnotationRemovedEventDetail = {\n    annotation,\n    annotationManagerUID: manager.uid,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Get the Annotation object by its UID\n * @param annotationUID - The unique identifier of the annotation.\n */\nfunction getAnnotation(annotationUID: string): Annotation {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  return annotation;\n}\n\n/**\n * It removes all annotations from the default annotation manager\n */\nfunction removeAllAnnotations(): void {\n  const manager = getAnnotationManager();\n  manager.removeAllAnnotations();\n}\n\nexport {\n  getAnnotations,\n  getNumberOfAnnotations,\n  addAnnotation,\n  getAnnotation,\n  removeAnnotation,\n  removeAllAnnotations,\n  // annotation manager\n  setAnnotationManager,\n  getAnnotationManager,\n  resetAnnotationManager,\n};\n","import {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { Annotation } from '../../../types/AnnotationTypes';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nimport { AnnotationAddedEventDetail } from '../../../types/EventTypes';\n\n/**\n * It triggers an event for the element when an annotation is added\n * @param annotation - Annotation - The annotation that was added.\n * @param element - The element that the annotation was added to.\n */\nfunction triggerAnnotationAddedForElement(\n  annotation: Annotation,\n  element: HTMLDivElement\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewportId } = enabledElement;\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  const eventDetail: AnnotationAddedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId: renderingEngine.id,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * If the annotation has a FrameOfReferenceUID, it triggers the ANNOTATION_ADDED\n * event for all the viewports that has the same FrameOfReferenceUID.\n * @param annotation -  Annotation - The annotation that was added\n */\nfunction triggerAnnotationAddedForFOR(annotation: Annotation) {\n  const { toolName } = annotation.metadata;\n\n  const toolGroups = getToolGroupsWithToolName(toolName);\n\n  if (!toolGroups.length) {\n    return;\n  }\n\n  // Find the viewports in the toolGroups who has the same FrameOfReferenceUID\n  const viewportsToRender = [];\n\n  toolGroups.forEach((toolGroup) => {\n    toolGroup.viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n      const { FrameOfReferenceUID } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n        viewportsToRender.push(viewportInfo);\n      }\n    });\n  });\n\n  if (!viewportsToRender.length) {\n    return;\n  }\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n    const eventDetail: AnnotationAddedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  });\n}\n\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR };\n","/**\n * Cornerstone Color LUT used for Segmentations\n */\nconst CORNERSTONE_COLOR_LUT = [\n  [0, 0, 0, 0],\n  [221, 84, 84, 255],\n  [77, 228, 121, 255],\n  [166, 70, 235, 255],\n  [189, 180, 116, 255],\n  [109, 182, 196, 255],\n  [204, 101, 157, 255],\n  [123, 211, 94, 255],\n  [93, 87, 218, 255],\n  [225, 128, 80, 255],\n  [73, 232, 172, 255],\n  [181, 119, 186, 255],\n  [176, 193, 112, 255],\n  [105, 153, 200, 255],\n  [208, 97, 120, 255],\n  [90, 215, 101, 255],\n  [135, 83, 222, 255],\n  [229, 178, 76, 255],\n  [122, 183, 181, 255],\n  [190, 115, 171, 255],\n  [149, 197, 108, 255],\n  [100, 118, 205, 255],\n  [212, 108, 93, 255],\n  [86, 219, 141, 255],\n  [183, 79, 226, 255],\n  [233, 233, 72, 255],\n  [118, 167, 187, 255],\n  [194, 111, 146, 255],\n  [116, 201, 104, 255],\n  [115, 96, 209, 255],\n  [216, 147, 89, 255],\n  [82, 223, 188, 255],\n  [230, 75, 224, 255],\n  [163, 184, 121, 255],\n  [114, 143, 191, 255],\n  [198, 107, 114, 255],\n  [99, 206, 122, 255],\n  [153, 92, 213, 255],\n  [220, 192, 85, 255],\n  [78, 215, 227, 255],\n  [234, 71, 173, 255],\n  [141, 188, 117, 255],\n  [110, 113, 195, 255],\n  [202, 128, 103, 255],\n  [95, 210, 157, 255],\n  [195, 88, 217, 255],\n  [206, 224, 81, 255],\n  [74, 166, 231, 255],\n  [185, 120, 139, 255],\n  [113, 192, 113, 255],\n  [133, 106, 199, 255],\n  [207, 162, 98, 255],\n  [91, 214, 198, 255],\n  [221, 84, 198, 255],\n  [159, 228, 77, 255],\n  [70, 111, 235, 255],\n  [189, 119, 116, 255],\n  [109, 196, 138, 255],\n  [165, 101, 204, 255],\n  [211, 201, 94, 255],\n  [87, 191, 218, 255],\n  [225, 80, 153, 255],\n  [106, 232, 73, 255],\n  [124, 119, 186, 255],\n  [193, 142, 112, 255],\n  [105, 200, 168, 255],\n  [203, 97, 208, 255],\n  [184, 215, 90, 255],\n  [83, 147, 222, 255],\n  [229, 76, 101, 255],\n  [122, 183, 130, 255],\n  [146, 115, 190, 255],\n  [197, 171, 108, 255],\n  [100, 205, 205, 255],\n  [212, 93, 177, 255],\n  [141, 219, 86, 255],\n  [79, 97, 226, 255],\n  [233, 99, 72, 255],\n  [118, 187, 150, 255],\n  [173, 111, 194, 255],\n  [197, 201, 104, 255],\n  [96, 171, 209, 255],\n  [216, 89, 137, 255],\n  [94, 223, 82, 255],\n  [107, 75, 230, 255],\n  [184, 153, 121, 255],\n  [114, 191, 175, 255],\n  [198, 107, 191, 255],\n  [166, 206, 99, 255],\n  [92, 132, 213, 255],\n  [220, 85, 91, 255],\n  [78, 227, 115, 255],\n  [159, 71, 234, 255],\n  [188, 176, 117, 255],\n  [110, 185, 195, 255],\n  [202, 103, 161, 255],\n  [129, 210, 95, 255],\n  [88, 88, 217, 255],\n  [224, 123, 81, 255],\n  [74, 231, 166, 255],\n  [177, 120, 185, 255],\n  [179, 192, 113, 255],\n  [106, 156, 199, 255],\n  [207, 98, 125, 255],\n  [91, 214, 96, 255],\n  [130, 84, 221, 255],\n  [228, 171, 77, 255],\n  [70, 235, 221, 255],\n  [189, 116, 174, 255],\n  [153, 196, 109, 255],\n  [101, 123, 204, 255],\n  [211, 104, 94, 255],\n  [87, 218, 136, 255],\n  [177, 80, 225, 255],\n  [232, 225, 73, 255],\n  [119, 169, 186, 255],\n  [193, 112, 149, 255],\n  [121, 200, 105, 255],\n  [111, 97, 208, 255],\n  [215, 142, 90, 255],\n  [83, 222, 181, 255],\n  [229, 76, 229, 255],\n  [165, 183, 122, 255],\n  [115, 146, 190, 255],\n  [197, 108, 119, 255],\n  [100, 205, 118, 255],\n  [148, 93, 212, 255],\n  [219, 186, 86, 255],\n  [79, 220, 226, 255],\n  [233, 72, 179, 255],\n  [144, 187, 118, 255],\n  [111, 118, 194, 255],\n  [201, 124, 104, 255],\n  [96, 209, 153, 255],\n  [189, 89, 216, 255],\n  [211, 223, 82, 255],\n  [75, 172, 230, 255],\n  [184, 121, 142, 255],\n  [117, 191, 114, 255],\n  [130, 107, 198, 255],\n  [206, 157, 99, 255],\n  [92, 213, 193, 255],\n  [220, 85, 203, 255],\n  [165, 227, 78, 255],\n  [71, 118, 234, 255],\n  [188, 117, 117, 255],\n  [110, 195, 135, 255],\n  [161, 103, 202, 255],\n  [210, 195, 95, 255],\n  [88, 195, 217, 255],\n  [224, 81, 158, 255],\n  [113, 231, 74, 255],\n  [123, 120, 185, 255],\n  [192, 139, 113, 255],\n  [106, 199, 164, 255],\n  [198, 98, 207, 255],\n  [188, 214, 91, 255],\n  [84, 153, 221, 255],\n  [228, 77, 108, 255],\n  [70, 235, 84, 255],\n  [143, 116, 189, 255],\n  [196, 167, 109, 255],\n  [101, 204, 199, 255],\n  [211, 94, 182, 255],\n  [147, 218, 87, 255],\n  [80, 104, 225, 255],\n  [232, 93, 73, 255],\n  [119, 186, 147, 255],\n  [170, 112, 193, 255],\n  [200, 200, 105, 255],\n  [97, 175, 208, 255],\n  [215, 90, 142, 255],\n  [100, 222, 83, 255],\n  [101, 76, 229, 255],\n  [183, 150, 122, 255],\n  [115, 190, 171, 255],\n  [197, 108, 194, 255],\n  [170, 205, 100, 255],\n  [93, 138, 212, 255],\n  [219, 86, 97, 255],\n  [79, 226, 110, 255],\n  [153, 72, 233, 255],\n  [187, 173, 118, 255],\n  [111, 187, 194, 255],\n  [201, 104, 165, 255],\n  [134, 209, 96, 255],\n  [89, 95, 216, 255],\n  [223, 117, 82, 255],\n  [75, 230, 159, 255],\n  [174, 121, 184, 255],\n  [182, 191, 114, 255],\n  [107, 160, 198, 255],\n  [206, 99, 130, 255],\n  [92, 213, 92, 255],\n  [124, 85, 220, 255],\n  [227, 165, 78, 255],\n  [71, 234, 214, 255],\n  [188, 117, 176, 255],\n  [156, 195, 110, 255],\n  [103, 128, 202, 255],\n  [210, 100, 95, 255],\n  [88, 217, 131, 255],\n  [170, 81, 224, 255],\n  [231, 218, 74, 255],\n  [120, 172, 185, 255],\n  [192, 113, 153, 255],\n  [125, 199, 106, 255],\n  [107, 98, 207, 255],\n  [214, 137, 91, 255],\n  [84, 221, 175, 255],\n  [222, 77, 228, 255],\n  [194, 235, 70, 255],\n  [116, 149, 189, 255],\n  [196, 109, 123, 255],\n  [101, 204, 114, 255],\n  [143, 94, 211, 255],\n  [218, 180, 87, 255],\n  [80, 225, 225, 255],\n  [232, 73, 186, 255],\n  [147, 186, 119, 255],\n  [112, 122, 193, 255],\n  [200, 121, 105, 255],\n  [97, 208, 148, 255],\n  [184, 90, 215, 255],\n  [216, 222, 83, 255],\n  [76, 178, 229, 255],\n  [183, 122, 145, 255],\n  [121, 190, 115, 255],\n  [126, 108, 197, 255],\n  [205, 153, 100, 255],\n  [93, 212, 187, 255],\n  [219, 86, 208, 255],\n  [171, 226, 79, 255],\n  [72, 126, 233, 255],\n  [187, 118, 121, 255],\n  [111, 194, 132, 255],\n  [157, 104, 201, 255],\n  [209, 190, 96, 255],\n  [89, 200, 216, 255],\n  [223, 82, 164, 255],\n  [120, 230, 75, 255],\n  [121, 121, 184, 255],\n  [191, 136, 114, 255],\n  [107, 198, 160, 255],\n  [192, 99, 206, 255],\n  [193, 213, 92, 255],\n  [85, 158, 220, 255],\n  [227, 78, 115, 255],\n  [71, 234, 78, 255],\n  [141, 117, 188, 255],\n  [195, 163, 110, 255],\n  [103, 202, 194, 255],\n  [210, 95, 186, 255],\n  [153, 217, 88, 255],\n  [81, 111, 224, 255],\n];\n\nexport default CORNERSTONE_COLOR_LUT;\n","/**\n * Segmentations on viewports can be visualized in different ways. This enum\n * defines the different ways of visualizing segmentations. Currently, only\n * labelmap is supported.\n */\nenum SegmentationRepresentations {\n  Labelmap = 'LABELMAP',\n  Contour = 'CONTOUR',\n  // Todo: add more representations\n}\n\nexport default SegmentationRepresentations;\n","import { ContourConfig } from '../../../types/ContourTypes';\n\nconst defaultContourConfig: ContourConfig = {\n  renderOutline: true,\n  outlineWidthActive: 2,\n  outlineWidthInactive: 2,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultContourConfig(): ContourConfig {\n  return defaultContourConfig;\n}\n\nexport default getDefaultContourConfig;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\n\nimport { SegmentationRepresentations } from '../../enums';\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport type {\n  ColorLUT,\n  RepresentationConfig,\n  Segmentation,\n  SegmentationRepresentationConfig,\n  SegmentationState,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\n\n// Initialize the default configuration\n// Note: when we get other representations, we should set their default representations too.\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\nconst defaultContourConfig = getDefaultContourConfig();\n\nconst newGlobalConfig: SegmentationRepresentationConfig = {\n  renderInactiveSegmentations: true,\n  representations: {\n    [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\n    [SegmentationRepresentations.Contour]: defaultContourConfig,\n  },\n};\n\n/* A default initial state for the segmentation manager. */\nconst initialDefaultState: SegmentationState = {\n  colorLUT: [],\n  segmentations: [],\n  globalConfig: newGlobalConfig,\n  toolGroups: {},\n};\n\n/**\n * The SegmentationStateManager Class is responsible for managing the state of the\n * segmentations. It stores the segmentations and toolGroup specific representations\n * of the segmentation. It also stores a global config and a toolGroup specific\n * config. Note that this is a singleton state manager.\n */\nexport default class SegmentationStateManager {\n  private state: SegmentationState;\n  public readonly uid: string;\n\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = csUtils.uuidv4();\n    }\n    this.state = cloneDeep(initialDefaultState);\n    this.uid = uid;\n  }\n\n  /**\n   * It returns a copy of the current state of the segmentation\n   * @returns A deep copy of the state.\n   */\n  getState(): SegmentationState {\n    return this.state;\n  }\n\n  /**\n   * It returns an array of toolGroupIds currently in the segmentation state.\n   * @returns An array of strings.\n   */\n  getToolGroups(): string[] {\n    return Object.keys(this.state.toolGroups);\n  }\n\n  /**\n   * It returns the colorLUT at the specified index.\n   * @param lutIndex - The index of the color LUT to retrieve.\n   * @returns A ColorLUT object.\n   */\n  getColorLUT(lutIndex: number): ColorLUT | undefined {\n    return this.state.colorLUT[lutIndex];\n  }\n\n  /**\n   * Reset the state to the default state\n   */\n  resetState(): void {\n    this.state = cloneDeep(initialDefaultState);\n  }\n\n  /**\n   * Given a segmentation Id, return the segmentation state\n   * @param segmentationId - The id of the segmentation to get the data for.\n   * @returns - The segmentation data\n   */\n  getSegmentation(segmentationId: string): Segmentation | undefined {\n    return this.state.segmentations.find(\n      (segmentation) => segmentation.segmentationId === segmentationId\n    );\n  }\n\n  /**\n   * It adds a segmentation to the segmentations array.\n   * @param segmentation - Segmentation\n   */\n  addSegmentation(segmentation: Segmentation): void {\n    this._initDefaultColorLUTIfNecessary();\n\n    // Check if the segmentation already exists with the segmentationId\n    if (this.getSegmentation(segmentation.segmentationId)) {\n      throw new Error(\n        `Segmentation with id ${segmentation.segmentationId} already exists`\n      );\n    }\n\n    this.state.segmentations.push(segmentation);\n  }\n\n  /**\n   * Get the segmentation representations for a tool group\n   * @param toolGroupId - string\n   * @returns A list of segmentation representations.\n   */\n  getSegmentationRepresentations(\n    toolGroupId: string\n  ): ToolGroupSpecificRepresentations | undefined {\n    const toolGroupSegRepresentationsWithConfig =\n      this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupSegRepresentationsWithConfig) {\n      return;\n    }\n\n    return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n  }\n\n  /**\n   * Add a new segmentation representation to the toolGroup's segmentation representations.\n   * @param toolGroupId - The Id of the tool group .\n   * @param segmentationRepresentation - The segmentation representation to add.\n   */\n  addSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    // Initialize the default toolGroup state if not created yet\n    if (!this.state.toolGroups[toolGroupId]) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {} as SegmentationRepresentationConfig,\n      };\n    }\n\n    // local toolGroupSpecificSegmentationState\n    this.state.toolGroups[toolGroupId].segmentationRepresentations.push(\n      segmentationRepresentation\n    );\n\n    this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\n  }\n\n  /**\n   * Get the global config containing both representation config\n   * and render inactive segmentations config\n   * @returns The global config object.\n   */\n  getGlobalConfig(): SegmentationRepresentationConfig {\n    return this.state.globalConfig;\n  }\n\n  /**\n   * It sets the global segmentation config including both representation config\n   * and render inactive segmentations config\n   * @param config - The global configuration for the segmentations.\n   */\n  setGlobalConfig(config: SegmentationRepresentationConfig): void {\n    this.state.globalConfig = config;\n  }\n\n  /**\n   * Given a toolGroupId and a segmentationRepresentationUID, return the segmentation\n   * representation for that tool group.\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - string\n   * @returns The segmentation representation.\n   */\n  getSegmentationRepresentationByUID(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): ToolGroupSpecificRepresentation | undefined {\n    const toolGroupSegRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    const segmentationData = toolGroupSegRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    return segmentationData;\n  }\n\n  /**\n   * It removes the segmentation from the segmentation state.\n   * @param segmentationId - The id of the segmentation to remove.\n   */\n  removeSegmentation(segmentationId: string): void {\n    this.state.segmentations = this.state.segmentations.filter(\n      (segmentation) => segmentation.segmentationId !== segmentationId\n    );\n  }\n\n  /**\n   * Remove a segmentation representation from the toolGroup\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - the uid of the segmentation representation to remove\n   * @param immediate - If true, the viewport will be updated immediately.\n   */\n  removeSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      !toolGroupSegmentationRepresentations.length\n    ) {\n      throw new Error(\n        `No viewport specific segmentation state found for viewport ${toolGroupId}`\n      );\n    }\n\n    const state =\n      toolGroupSegmentationRepresentations as ToolGroupSpecificRepresentations;\n    const index = state.findIndex(\n      (segData) =>\n        segData.segmentationRepresentationUID === segmentationRepresentationUID\n    );\n\n    if (index === -1) {\n      console.warn(\n        `No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    const removedSegmentationRepresentation =\n      toolGroupSegmentationRepresentations[index];\n\n    toolGroupSegmentationRepresentations.splice(index, 1);\n\n    this._handleActiveSegmentation(\n      toolGroupId,\n      removedSegmentationRepresentation\n    );\n  }\n\n  /**\n   * Set the active segmentation data for a tool group\n   * @param toolGroupId - The Id of the tool group that owns the\n   * segmentation data.\n   * @param segmentationRepresentationUID - string\n   */\n  setActiveSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\n      throw new Error(\n        `No segmentation data found for toolGroupId: ${toolGroupId}`\n      );\n    }\n\n    const segmentationData = toolGroupSegmentations.find(\n      (segmentationData) =>\n        segmentationData.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (!segmentationData) {\n      throw new Error(\n        `No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    segmentationData.active = true;\n    this._handleActiveSegmentation(toolGroupId, segmentationData);\n  }\n\n  /**\n   * Given a tool group Id it returns the tool group specific representation config\n   *\n   * @param toolGroupId - The Id of the tool group\n   * @returns A SegmentationConfig object.\n   */\n  getToolGroupSpecificConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig | undefined {\n    const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      return;\n    }\n\n    return toolGroupStateWithConfig.config;\n  }\n\n  getSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentationRepresentationSpecificConfig;\n  }\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: RepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentationRepresentationSpecificConfig =\n      config;\n  }\n\n  getSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    segmentIndex: number\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\n  }\n\n  setSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: SegmentSpecificRepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentSpecificConfig = config;\n  }\n\n  /**\n   * Set the segmentation representations config for a given tool group. It will create a new\n   * tool group specific config if one does not exist.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation\n   * belongs to.\n   * @param config - SegmentationConfig\n   */\n  setSegmentationRepresentationConfig(\n    toolGroupId: string,\n    config: SegmentationRepresentationConfig\n  ): void {\n    let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {\n          renderInactiveSegmentations: true,\n          representations: {},\n        },\n      };\n\n      toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n    }\n\n    toolGroupStateWithConfig.config = {\n      ...toolGroupStateWithConfig.config,\n      ...config,\n    };\n  }\n\n  /**\n   * It adds a color LUT to the state.\n   * @param colorLUT - ColorLUT\n   * @param lutIndex - The index of the color LUT table to add.\n   */\n  addColorLUT(colorLUT: ColorLUT, lutIndex: number): void {\n    if (this.state.colorLUT[lutIndex]) {\n      console.log('Color LUT table already exists, overwriting');\n    }\n\n    this.state.colorLUT[lutIndex] = colorLUT;\n  }\n\n  /**\n   * Removes a color LUT to the state.\n   * @param colorLUTIndex - The index of the color LUT table to remove.\n   */\n  removeColorLUT(colorLUTIndex: number): void {\n    delete this.state.colorLUT[colorLUTIndex];\n  }\n\n  /**\n   * It handles the active segmentation representation based on the active status of the\n   * segmentation representation that was added or removed.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation representation belongs to.\n   * @param recentlyAddedOrRemovedSegmentationRepresentation - ToolGroupSpecificSegmentationData\n   */\n  _handleActiveSegmentation(\n    toolGroupId: string,\n    recentlyAddedOrRemovedSegmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    const segmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    // 1. If there is no segmentation representations, return early\n    if (segmentationRepresentations.length === 0) {\n      return;\n    }\n\n    // 2. If there is only one segmentation representation, make that one active\n    if (segmentationRepresentations.length === 1) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 3. If removed Segmentation representation was active, make the first one active\n    const activeSegmentationRepresentations =\n      segmentationRepresentations.filter(\n        (representation) => representation.active\n      );\n\n    if (activeSegmentationRepresentations.length === 0) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 4. If the added segmentation representation is active, make other segmentation\n    // representations inactive\n    if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\n      segmentationRepresentations.forEach((representation) => {\n        if (\n          representation.segmentationRepresentationUID !==\n          recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID\n        ) {\n          representation.active = false;\n        }\n      });\n    }\n\n    // 5. if added/removed segmentation is is inactive, do nothing\n  }\n\n  _initDefaultColorLUTIfNecessary() {\n    // if colorLUTTable is not specified or the default one is not found\n    if (this.state.colorLUT.length === 0 || !this.state.colorLUT[0]) {\n      this.addColorLUT(CORNERSTONE_COLOR_LUT as ColorLUT, 0);\n    }\n  }\n}\n\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { defaultSegmentationStateManager };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\n\nimport { Events } from '../../enums';\nimport {\n  getSegmentationRepresentations,\n  getSegmentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  SegmentationRepresentationModifiedEventDetail,\n  SegmentationDataModifiedEventDetail,\n  SegmentationModifiedEventDetail,\n  SegmentationRepresentationRemovedEventDetail,\n  SegmentationRemovedEventDetail,\n} from '../../types/EventTypes';\n\n/**\n * Trigger an event that a segmentation is removed\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationRemoved(segmentationId: string): void {\n  const eventDetail: SegmentationRemovedEventDetail = {\n    segmentationId,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n\n/**\n * Trigger an event that a segmentation representation was removed\n * @param toolGroupId - The id of the tool group that the segmentation\n * representation was removed from.\n * @param segmentationRepresentationUID - The UID of the segmentation\n * representation that was removed.\n */\nfunction triggerSegmentationRepresentationRemoved(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const eventDetail: SegmentationRepresentationRemovedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  triggerEvent(\n    eventTarget,\n    Events.SEGMENTATION_REPRESENTATION_REMOVED,\n    eventDetail\n  );\n}\n\n/**\n * Trigger an event on the eventTarget that the segmentation representation for\n * toolGroupId has been updated\n * @param toolGroupId - The Id of the toolGroup\n */\nfunction triggerSegmentationRepresentationModified(\n  toolGroupId: string,\n  segmentationRepresentationUID?: string\n): void {\n  const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  if (segmentationRepresentationUID) {\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n    return;\n  }\n\n  // If no segmentationRepresentationUID is provided, then we need to trigger\n  // the event for all segmentation representations in the toolGroup\n\n  // Get all segmentation representations in the toolGroup\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((segmentationRepresentation) => {\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n    const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n      toolGroupId,\n      segmentationRepresentationUID,\n    };\n\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n  });\n}\n\n/**\n * Triggers segmentation global state updated event, notifying all toolGroups\n * that the global state has been updated, If a segmentationId is provided\n * the event will only be triggered for that segmentation, otherwise it will\n * be triggered for all segmentations.\n *\n * @param segmentationId - The id of the segmentation that has been updated\n */\nfunction triggerSegmentationModified(segmentationId?: string): void {\n  let segmentationIds;\n\n  if (segmentationId) {\n    segmentationIds = [segmentationId];\n  } else {\n    // get all toolGroups\n    segmentationIds = getSegmentations().map(\n      ({ segmentationId }) => segmentationId\n    );\n  }\n\n  // 1. Trigger an event notifying all listeners about the segmentationId\n  // that has been updated.\n  segmentationIds.forEach((segmentationId) => {\n    const eventDetail: SegmentationModifiedEventDetail = {\n      segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n  });\n\n  // Todo: I don't think we need the following lines of code\n  // // 2. Notify all viewports that render the segmentationId in order to update the\n  // // rendering based on the new global state.\n  // toolGroupIds.forEach((toolGroupId) => {\n  //   triggerSegmentationRepresentationModified(toolGroupId)\n  // })\n}\n\n/**\n * Trigger an event that a segmentation data has been modified\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationDataModified(\n  segmentationId: string,\n  modifiedSlicesToUse?: number[]\n): void {\n  const eventDetail: SegmentationDataModifiedEventDetail = {\n    segmentationId,\n    modifiedSlicesToUse,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n\nexport {\n  // ToolGroup Specific\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n  // Global\n  triggerSegmentationDataModified,\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n};\n","import type {\n  ColorLUT,\n  RepresentationConfig,\n  Segmentation,\n  SegmentationPublicInput,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport {\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n} from './triggerSegmentationEvents';\n\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\n\n/**\n * It returns the defaultSegmentationStateManager.\n */\nfunction getDefaultSegmentationStateManager() {\n  return defaultSegmentationStateManager;\n}\n\n/*************************\n *\n * Segmentation State\n *\n **************************/\n\n/**\n * Get the segmentation for the given segmentationId\n * @param segmentationId - The Id of the segmentation\n * @returns A GlobalSegmentationData object\n */\nfunction getSegmentation(segmentationId: string): Segmentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentation(segmentationId);\n}\n\n/**\n * Get the segmentations inside the state\n * @returns Segmentation array\n */\nfunction getSegmentations(): Segmentation[] | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n\n  return state.segmentations;\n}\n\n/**\n * It takes a segmentation input and adds it to the segmentation state manager\n * @param segmentationInput - The segmentation to add.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction addSegmentation(\n  segmentationInput: SegmentationPublicInput,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const segmentation = normalizeSegmentationInput(segmentationInput);\n\n  segmentationStateManager.addSegmentation(segmentation);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified(segmentation.segmentationId);\n  }\n}\n\n/**\n * Get the segmentation state for a tool group. It will return an array of\n * segmentation representation objects.\n * @param toolGroupId - The unique identifier of the tool group.\n * @returns An array of segmentation representation objects.\n */\nfunction getSegmentationRepresentations(\n  toolGroupId: string\n): ToolGroupSpecificRepresentations | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n}\n\n/**\n * Get the tool group IDs that have a segmentation representation with the given\n * segmentationId\n * @param segmentationId - The id of the segmentation\n * @returns An array of tool group IDs.\n */\nfunction getToolGroupIdsWithSegmentation(segmentationId: string): string[] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n  const toolGroupIds = Object.keys(state.toolGroups);\n\n  const foundToolGroupIds = [];\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        foundToolGroupIds.push(toolGroupId);\n      }\n    });\n  });\n\n  return foundToolGroupIds;\n}\n\n/**\n * Get the segmentation representations config for a given tool group\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config belongs to.\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Set the segmentation representation config for the provided toolGroup. ToolGroup specific\n * configuration overwrites the global configuration for each representation.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config is being set for.\n * @param config - The new configuration for the tool group.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationConfig(\n    toolGroupId,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(toolGroupId);\n  }\n}\n\n/**\n * It sets the segmentation representation specific config for all the segments\n * inside the segmentation.\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @param config  - The new configuration for the segmentation representation it is an object with keys of\n * different representation types, and values of the configuration for each representation type.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the segmentation representation specific config which is the same for all the segments\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @returns - The segmentation representation specific config.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction getSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\nfunction setSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  // Todo: this can be even more performant if we create a new event for\n  // triggering a specific segment config change.\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * Add the given segmentation representation data to the given tool group state. It fires\n * SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation representation is for.\n * @param segmentationData - The data to add to the segmentation state.\n * @param suppressEvents - boolean\n */\nfunction addSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentation\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the global segmentation config. Note that the toolGroup-specific\n * configuration has higher priority than the global configuration and overwrites\n * the global configuration for each representation.\n * @returns The global segmentation configuration for all segmentations.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation configuration. It fires SEGMENTATION_MODIFIED\n * event if not suppressed.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param config - The new global segmentation config.\n * @param suppressEvents - If true, the `segmentationGlobalStateModified` event will not be triggered.\n */\nfunction setGlobalConfig(\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setGlobalConfig(config);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified();\n  }\n}\n\n/**\n * Get the segmentation data object for a given tool group and\n * segmentation data UID. It searches all the toolGroup specific segmentation\n * data objects and returns the first one that matches the UID.\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @returns Segmentation Data object.\n */\nfunction getSegmentationRepresentationByUID(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): ToolGroupSpecificRepresentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * It removes the segmentation from the segmentation state manager\n *\n * @triggers SEGMENTATION_REMOVED\n *\n * @param segmentationId - The id of the segmentation\n */\nfunction removeSegmentation(segmentationId: string): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentation(segmentationId);\n  triggerSegmentationRemoved(segmentationId);\n}\n\n/**\n * Remove a segmentation representation from the segmentation state manager for a toolGroup.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_REPRESENTATION_REMOVED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation to remove.\n * remove.\n * @param - immediate - If true, the viewports will be updated immediately.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationRemoved(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction removeColorLUT(colorLUTIndex: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n\n/**\n * Get the color lut for a given index\n * @param index - The index of the color lut to retrieve.\n * @returns A ColorLUT array.\n */\nfunction getColorLUT(index: number): ColorLUT | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getColorLUT(index);\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction addColorLUT(colorLUT: ColorLUT, index: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addColorLUT(colorLUT, index);\n  // Todo: trigger event color LUT added\n}\n\nexport {\n  getDefaultSegmentationStateManager,\n  // Segmentation\n  getSegmentation,\n  getSegmentations,\n  addSegmentation,\n  removeSegmentation,\n  // ToolGroup specific Segmentation Representation\n  getSegmentationRepresentations,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n  // config\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  getGlobalConfig,\n  setGlobalConfig,\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  getSegmentSpecificRepresentationConfig,\n  setSegmentSpecificRepresentationConfig,\n  // helpers s\n  getToolGroupIdsWithSegmentation,\n  getSegmentationRepresentationByUID,\n  // color\n  addColorLUT,\n  getColorLUT,\n  removeColorLUT,\n};\n","import {\n  SegmentationPublicInput,\n  Segmentation,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It takes in a segmentation input and returns a segmentation with default values\n * @param segmentationInput - The input to the segmentation.\n * @returns A Segmentation object.\n * @internal\n */\nfunction normalizeSegmentationInput(\n  segmentationInput: SegmentationPublicInput\n): Segmentation {\n  const { segmentationId, representation } = segmentationInput;\n\n  // Todo: we should be able to let the user pass in non-default values for\n  // cachedStats, label, activeSegmentIndex, etc.\n  return {\n    segmentationId,\n    cachedStats: {},\n    segmentLabels: {},\n    label: null,\n    segmentsLocked: new Set(),\n    type: representation.type,\n    activeSegmentIndex: 1,\n    representationData: {\n      [representation.type]: {\n        ...representation.data,\n      },\n    },\n  };\n}\n\nexport default normalizeSegmentationInput;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { IPoints } from '../../types';\n\n/**\n * Given a native mouse event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Mouse event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getMouseEventPoints(\n  evt: MouseEvent,\n  element?: HTMLDivElement\n): IPoints {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const { viewport } = getEnabledElement(elementToUse);\n  const clientPoint = _clientToPoint(evt);\n  const pagePoint = _pageToPoint(evt);\n  const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n  const worldPoint = viewport.canvasToWorld(canvasPoint);\n\n  return {\n    page: pagePoint,\n    client: clientPoint,\n    canvas: canvasPoint,\n    world: worldPoint,\n  };\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param evt - The Mouse `Event`\n */\nfunction _pageToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.pageX, evt.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Mouse `Event`\n */\nfunction _clientToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.clientX, evt.clientY];\n}\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { EventTypes, IPoints } from '../../types';\n\n/**\n * Captures and normalizes the double click event. Emits as a cornerstoneTools3D\n * double click event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseDoubleClickListener(evt: MouseEvent): void {\n  const element = <HTMLDivElement>evt.currentTarget;\n\n  const { viewportId, renderingEngineId } = getEnabledElement(element);\n\n  const startPoints = getMouseEventPoints(evt, element);\n  const deltaPoints: IPoints = {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  };\n\n  const eventDetail: EventTypes.MouseDoubleClickEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_DOUBLE_CLICK,\n    viewportId,\n    renderingEngineId,\n    camera: {},\n    element,\n    startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(\n    element,\n    Events.MOUSE_DOUBLE_CLICK,\n    eventDetail\n  );\n\n  if (consumed) {\n    // The Events.MOUSE_DOUBLE_CLICK was consumed, thus no other listener should handle this 'dblclick' event.\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseDoubleClickListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { MouseMoveEventDetail } from '../../types/EventTypes';\n\nconst eventName = Events.MOUSE_MOVE;\n\n/**\n * Captures and normalizes the mouse move event. Emits as a cornerstoneTools3D\n * mouse move event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseMoveListener(evt: MouseEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const currentPoints = getMouseEventPoints(evt);\n  const eventDetail: MouseMoveEventDetail = {\n    renderingEngineId,\n    viewportId,\n    camera: {},\n    element,\n    currentPoints,\n    eventName,\n    event: evt,\n  };\n\n  triggerEvent(element, eventName, eventDetail);\n}\n\nexport default mouseMoveListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport Events from '../../enums/Events';\nimport mouseMoveListener from './mouseMoveListener';\nimport { EventTypes, IPoints } from '../../types';\nimport getMouseEventPoints from './getMouseEventPoints';\n\nconst { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } =\n  Events;\n\n// The amount of time in milliseconds within which a browser 'dblclick' event has to occur.\n// Any mouse down, up, down and up sequence taking longer than this time is considered to\n// NOT be a double click and any browser 'dblclick' event that subsequently occurs as a result\n// of such a sequence will be ignored. It is best to set this to a value that is less\n// than the system value for detecting a double click. Setting something too large\n// might detect a double click that does not constitute a browser 'dblclick' and thus\n// no mouse events for the sequence will get fired at all.\n//\n// TODO This module should detect and fire 'dblclick' events at its discretion and\n// ignore all those generated by the browser.\n//\nconst DOUBLE_CLICK_TOLERANCE_MS = 400;\n\n// A drag (projected distance) during the double click timeout that is greater than this\n// value will cancel the timeout and suppress any double click that might occur.\n// This tolerance is particularly important on touch devices where some movement\n// might occur between the two clicks.\n//\n// TODO revisit this value for touch devices\n//\nconst DOUBLE_CLICK_DRAG_TOLERANCE = 3;\n\ninterface IMouseDownListenerState {\n  mouseButton: number;\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  isClickEvent: boolean;\n  clickDelay: number;\n  preventClickTimeout: ReturnType<typeof setTimeout>;\n  startPoints: IPoints;\n  lastPoints: IPoints;\n}\n\ninterface IDoubleClickState {\n  doubleClickTimeout: ReturnType<typeof setTimeout>;\n  mouseDownEvent: MouseEvent;\n  mouseUpEvent: MouseEvent;\n  ignoreDoubleClick: boolean;\n}\n\n// STATE\nconst defaultState: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  element: null,\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nlet state: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  element: null,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nconst doubleClickState: IDoubleClickState = {\n  doubleClickTimeout: null,\n  mouseDownEvent: null,\n  mouseUpEvent: null,\n  ignoreDoubleClick: false,\n};\n\n/**\n * Listens to mouse down events from the DOM and depending on interaction and further\n * interaction can emit the following mouse events:\n *\n * - MOUSE_DOWN\n * - MOUSE_DOWN_ACTIVATE\n * - MOUSE_DRAG (move while down)\n * - MOUSE_UP\n * - MOUSE_CLICK\n *\n * The mouse down is NOT handled immediately. Instead, a timeout is started to\n * determine if this mouse down is the first in a sequence that constitutes a\n * double click.\n *\n * @param evt - The Mouse event.\n * @private\n */\nfunction mouseDownListener(evt: MouseEvent) {\n  // Ignore any mouse down during the double click timeout because only\n  // the first mouse down has the potential of being handled.\n  if (doubleClickState.doubleClickTimeout) {\n    return;\n  }\n\n  doubleClickState.doubleClickTimeout = setTimeout(\n    _doStateMouseDownAndUp,\n    DOUBLE_CLICK_TOLERANCE_MS\n  );\n\n  // First mouse down of a potential double click. So save it and start\n  // a timeout to determine a double click.\n  doubleClickState.mouseDownEvent = evt;\n  doubleClickState.ignoreDoubleClick = false;\n\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  state.mouseButton = evt.button;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n\n  state.preventClickTimeout = setTimeout(\n    _preventClickHandler,\n    state.clickDelay\n  );\n\n  // Prevent CornerstoneToolsMouseMove while mouse is down\n  state.element.removeEventListener('mousemove', mouseMoveListener);\n\n  const startPoints = getMouseEventPoints(evt, state.element);\n  state.startPoints = _copyPoints(startPoints);\n  state.lastPoints = _copyPoints(startPoints);\n\n  document.addEventListener('mouseup', _onMouseUp);\n  document.addEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Does the actual mouse down logic if the double click timer has expired or\n * a mouse drag has started.\n * @param evt the mouse down event\n * @private\n */\nfunction _doMouseDown(evt: MouseEvent) {\n  const deltaPoints = _getDeltaPoints(state.startPoints, state.startPoints);\n\n  const eventDetail: EventTypes.MouseDownEventDetail = {\n    event: evt,\n    eventName: MOUSE_DOWN,\n    element: state.element,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPoints: state.startPoints,\n    lastPoints: state.startPoints,\n    currentPoints: state.startPoints,\n    deltaPoints,\n  };\n\n  state.lastPoints = _copyPoints(eventDetail.lastPoints);\n\n  // by triggering MOUSE_DOWN it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const notConsumed = triggerEvent(\n    eventDetail.element,\n    MOUSE_DOWN,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default behavior,\n  // create a new tool\n  if (notConsumed) {\n    triggerEvent(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);\n  }\n}\n\n/**\n *_onMouseDrag - Handle emission of drag events whilst the mouse is depressed.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseDrag(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (doubleClickState.doubleClickTimeout) {\n    if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n      // Dragging past the tolerance means no double click should occur.\n      _doStateMouseDownAndUp();\n    } else {\n      return;\n    }\n  }\n\n  const eventDetail: EventTypes.MouseDragEventDetail = {\n    event: evt,\n    eventName: MOUSE_DRAG,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: _copyPoints(state.startPoints),\n    lastPoints: _copyPoints(lastPoints),\n    currentPoints,\n    deltaPoints,\n  };\n\n  triggerEvent(state.element, MOUSE_DRAG, eventDetail);\n\n  // Update the last points\n  state.lastPoints = _copyPoints(currentPoints);\n}\n\n/**\n *_onMouseUp - Handle emission of mouse up events, and re-enabling mouse move events.\n *\n * If the mouse up event occurs during a double click timeout, it is either the first or\n * second mouse up of a potential double click sequence. If the first, then it\n * is saved in case the double click timeout expires and a simple mouse down and\n * up have to get executed. If the second, then the latest mouse down, up, down and\n * up constitute a double click and the mouseDoubleClickListener needs to execute.\n *\n * If the mouse up event comes after the double click timeout, then it is simply\n * handled as the up of a mouse down and up sequence.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseUp(evt: MouseEvent): void {\n  // Cancel the timeout preventing the click event from triggering\n  clearTimeout(state.preventClickTimeout);\n\n  if (doubleClickState.doubleClickTimeout) {\n    // received a mouse up while waiting for a double click (via a timeout)\n\n    if (!doubleClickState.mouseUpEvent) {\n      // this is the first mouse up during the double click timeout; we'll need it later if the timeout expires\n      doubleClickState.mouseUpEvent = evt;\n\n      state.element.addEventListener('mousemove', _onMouseMove);\n    } else {\n      // this is the second mouse up of a double click!\n      _cleanUp();\n    }\n  } else {\n    // Handle the actual mouse up. Note that it may have occurred during the double click timeout or\n    // after it expired. In either case this block is being executed after the time out has expired\n    // or after a drag started.\n\n    const eventName = state.isClickEvent ? MOUSE_CLICK : MOUSE_UP;\n\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const deltaPoints = _getDeltaPoints(currentPoints, state.lastPoints);\n    const eventDetail:\n      | EventTypes.MouseUpEventDetail\n      | EventTypes.MouseClickEventType = {\n      event: evt,\n      eventName,\n      mouseButton: state.mouseButton,\n      element: state.element,\n      renderingEngineId: state.renderingEngineId,\n      viewportId: state.viewportId,\n      camera: {},\n      startPoints: _copyPoints(state.startPoints),\n      lastPoints: _copyPoints(state.lastPoints),\n      currentPoints,\n      deltaPoints,\n    };\n\n    triggerEvent(eventDetail.element, eventName, eventDetail);\n\n    _cleanUp();\n  }\n\n  // Remove the drag as soon as we get the mouse up because either we have executed\n  // the mouse up logic, or we have not even handled the mouse down logic yet\n  // - either way no drag should/can occur.\n  document.removeEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Handles a mouse move on the state element after a mouse down AND up AND\n * while the double click timeout is still running.\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseMove(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n    return;\n  }\n\n  _doStateMouseDownAndUp();\n\n  // Do the move again because during the timeout the global mouse move listener was removed.\n  // Now it is back.\n  mouseMoveListener(evt);\n}\n\n/**\n * Determines if the given delta is past the double click, (projected) drag distance\n * tolerance.\n * @param delta the delta\n * @returns true iff the delta is past the tolerance\n */\nfunction _isDragPastDoubleClickTolerance(delta: Types.Point2): boolean {\n  return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;\n}\n\nfunction _preventClickHandler() {\n  state.isClickEvent = false;\n}\n\n/**\n * Do a mouse down and potential mouse up using each of the events in the double click state.\n * The events were stored in the state during the timeout to determine a double click.\n *\n * This function should be invoked whenever it is determined that the latest\n * sequence of mouse down(s) and up(s) is NOT a double click. Examples of this include\n * - the expiration of the double click timeout\n * - a mouse drag/move beyond the DOUBLE_CLICK_DRAG_TOLERANCE\n *\n * This function sets the doubleClickState.ignoreDoubleClick flag in case our timeout value\n * or mouse move/drag tolerance is inaccurate and we do indeed get a double click event from\n * the browser later. The flag will be cleared in the mouseDoubleClickIgnoreListener should a\n * double click event get fired. If there is no eventual double click for the latest sequence,\n * the flag spills into the next sequence where it will get cleared at the beginning of that next\n * sequence in mouseDownListener. It is perfectly safe for the flag to be\n * left true when no double click actually occurs because any future double click must start with\n * a mouse down that is handled in this module.\n *\n * @private\n */\nfunction _doStateMouseDownAndUp() {\n  doubleClickState.ignoreDoubleClick = true;\n\n  const mouseDownEvent = doubleClickState.mouseDownEvent;\n  const mouseUpEvent = doubleClickState.mouseUpEvent;\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  _doMouseDown(mouseDownEvent);\n\n  if (mouseUpEvent) {\n    _onMouseUp(mouseUpEvent);\n  }\n}\n\n/**\n * Clears the mouse events and double click timeout id in the double click state object.\n * The timeout itself is also cleared so that no callback is invoked.\n */\nfunction _clearDoubleClickTimeoutAndEvents() {\n  if (doubleClickState.doubleClickTimeout) {\n    clearTimeout(doubleClickState.doubleClickTimeout);\n    doubleClickState.doubleClickTimeout = null;\n  }\n\n  doubleClickState.mouseDownEvent = null;\n  doubleClickState.mouseUpEvent = null;\n}\n\nfunction _cleanUp() {\n  document.removeEventListener('mouseup', _onMouseUp);\n  state.element?.removeEventListener('mousemove', _onMouseMove);\n\n  // Restore our global mousemove listener\n  state.element?.addEventListener('mousemove', mouseMoveListener);\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  state = JSON.parse(JSON.stringify(defaultState));\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction _copyPoints(points: IPoints): IPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateMouseEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: IPoints\n): IPoints {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  const world = viewport.canvasToWorld(lastPoints.canvas);\n\n  return {\n    page: lastPoints.page,\n    client: lastPoints.client,\n    canvas: lastPoints.canvas,\n    world,\n  };\n}\n\n/**\n * Returns the difference between two `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction _getDeltaPoints(currentPoints: IPoints, lastPoints: IPoints): IPoints {\n  return {\n    page: _subtractPoints2D(currentPoints.page, lastPoints.page),\n    client: _subtractPoints2D(currentPoints.client, lastPoints.client),\n    canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),\n    world: _subtractPoints3D(currentPoints.world, lastPoints.world),\n  };\n}\n\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nexport function getMouseButton(): number {\n  return state.mouseButton;\n}\n\n/**\n * Handles a dblclick event to determine if it should be ignored based on the\n * double click state's ignoreDoubleClick flag. stopImmediatePropagation and\n * preventDefault are used to ignore the event.\n * @param evt browser dblclick event\n */\nexport function mouseDoubleClickIgnoreListener(evt: MouseEvent) {\n  if (doubleClickState.ignoreDoubleClick) {\n    doubleClickState.ignoreDoubleClick = false;\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  } else {\n    // If the embedding application blocked the first mouse down and up\n    // of a double click sequence from reaching this module, then this module\n    // has handled the second mouse down and up and thus needs to clean them up.\n    // Doing a clean up here for the typical double click case is harmless.\n    _cleanUp();\n  }\n}\n\nexport default mouseDownListener;\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, {\n  mouseDoubleClickIgnoreListener,\n} from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\n\n/**\n * Removes mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('dblclick', mouseDoubleClickListener);\n  element.removeEventListener('mousedown', mouseDownListener);\n  element.removeEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\n/**\n * Registers mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n\n  element.addEventListener('dblclick', mouseDoubleClickListener);\n  element.addEventListener('mousedown', mouseDownListener);\n  element.addEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport normalizeWheel from './normalizeWheel';\nimport Events from '../../enums/Events';\n// ~~ VIEWPORT LIBRARY\nimport getMouseEventPoints from '../mouse/getMouseEventPoints';\nimport { MouseWheelEventDetail } from '../../types/EventTypes';\n\n/**\n * wheelListener - Captures and normalizes mouse wheel events. Emits as a\n * cornerstoneTools3D mouse wheel event.\n * @param evt - The mouse wheel event.\n */\nfunction wheelListener(evt: WheelEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  // Prevent triggering MouseWheel events that are not real scroll events:\n  // E.g. when clicking the MiddleMouseWheelButton, a deltaY of 0 is emitted.\n  // See https://github.com/cornerstonejs/cornerstoneTools/issues/935\n  if (evt.deltaY > -1 && evt.deltaY < 1) {\n    return;\n  }\n\n  evt.preventDefault();\n\n  const { spinX, spinY, pixelX, pixelY } = normalizeWheel(evt);\n  const direction = spinY < 0 ? -1 : 1;\n\n  const eventDetail: MouseWheelEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_WHEEL,\n    renderingEngineId,\n    viewportId,\n    element,\n    camera: {},\n    detail: evt,\n    wheel: {\n      spinX,\n      spinY,\n      pixelX,\n      pixelY,\n      direction,\n    },\n    points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(element, Events.MOUSE_WHEEL, eventDetail);\n}\n\nexport default wheelListener;\n","// Reasonable defaults\nconst PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\n\n/**\n * Normalizes wheel events and provides properties that are more\n * consistent and helpful across different browsers\n *\n * @param event - the original mouse event\n * @returns a normalized eventDetail\n */\nexport default function normalizeWheel(event) {\n  let spinX = 0,\n    spinY = 0,\n    pixelX = 0,\n    pixelY = 0;\n\n  // Legacy\n  if ('detail' in event) {\n    spinY = event.detail;\n  }\n  if ('wheelDelta' in event) {\n    spinY = -event.wheelDelta / 120;\n  }\n  if ('wheelDeltaY' in event) {\n    spinY = -event.wheelDeltaY / 120;\n  }\n  if ('wheelDeltaX' in event) {\n    spinX = -event.wheelDeltaX / 120;\n  }\n\n  pixelX = spinX * PIXEL_STEP;\n  pixelY = spinY * PIXEL_STEP;\n\n  if ('deltaY' in event) {\n    pixelY = event.deltaY;\n  }\n  if ('deltaX' in event) {\n    pixelX = event.deltaX;\n  }\n\n  if ((pixelX || pixelY) && event.deltaMode) {\n    if (event.deltaMode === 1) {\n      // Delta in LINE units\n      pixelX *= LINE_HEIGHT;\n      pixelY *= LINE_HEIGHT;\n    } else {\n      // Delta in PAGE units\n      pixelX *= PAGE_HEIGHT;\n      pixelY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pixelX && !spinX) {\n    spinX = pixelX < 1 ? -1 : 1;\n  }\n  if (pixelY && !spinY) {\n    spinY = pixelY < 1 ? -1 : 1;\n  }\n\n  return {\n    spinX,\n    spinY,\n    pixelX,\n    pixelY,\n  };\n}\n","import wheelListener from './wheelListener';\n\n/**\n * Listens for the wheel event, and handles it. Handled event\n * will be \"normalized\" and re-emitted as `Events.MOUSE_WHEEL`\n *\n * @param element - The HTML element\n */\nfunction enable(element: HTMLDivElement) {\n  disable(element);\n  element.addEventListener('wheel', wheelListener, { passive: false });\n}\n\n/**\n * Removes listener and handler for wheel event. `Events.MOUSE_WHEEL`\n * will no longer be emitted.\n *\n * @param element - THe HTML element\n */\nfunction disable(element: HTMLDivElement) {\n  element.removeEventListener('wheel', wheelListener);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","// Functions to prevent ghost clicks following a touch\n// Since the event lifecycle is touchstart, mousedown, touchend, mouseup\n// we want to prevent mousedown and mouseup events after touch events\n// All credit to @kosich\n// https://gist.github.com/kosich/23188dd86633b6c2efb7\n\nconst antiGhostDelay = 2000,\n  pointerType = {\n    mouse: 0,\n    touch: 1,\n  };\n\nlet lastInteractionType, lastInteractionTime;\n\nfunction handleTap(type, e) {\n  const now = Date.now();\n\n  if (type !== lastInteractionType) {\n    if (now - lastInteractionTime <= antiGhostDelay) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n\n      return false;\n    }\n\n    lastInteractionType = type;\n  }\n\n  lastInteractionTime = now;\n}\n\n// Cacheing the function references\n// Necessary because a new function reference is created after .bind() is called\n// http://stackoverflow.com/questions/11565471/removing-event-listener-which-was-added-with-bind\nconst handleTapMouse = handleTap.bind(null, pointerType.mouse);\nconst handleTapTouch = handleTap.bind(null, pointerType.touch);\n\nfunction attachEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.addEventListener(eventName, tapHandler, { passive: false });\n  });\n}\n\nfunction removeEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.removeEventListener(eventName, tapHandler);\n  });\n}\n\nconst mouseEvents = ['mousedown', 'mouseup', 'mousemove'];\nconst touchEvents = ['touchstart', 'touchend'];\n\nfunction disable(element) {\n  removeEvents(element, mouseEvents, pointerType.mouse);\n  removeEvents(element, touchEvents, pointerType.touch);\n}\n\nfunction enable(element) {\n  disable(element);\n  attachEvents(element, mouseEvents, pointerType.mouse);\n  attachEvents(element, touchEvents, pointerType.touch);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","enum Swipe {\n  UP = 'UP',\n  DOWN = 'DOWN',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n}\n\nexport { Swipe };\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { ITouchPoints } from '../../types';\n\n/**\n * Given a native touch event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Touch event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getTouchEventPoints(\n  evt: TouchEvent,\n  element?: HTMLDivElement\n): ITouchPoints[] {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;\n  return Object.keys(touches).map((i) => {\n    const clientPoint = _clientToPoint(touches[i]);\n    const pagePoint = _pageToPoint(touches[i]);\n    const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n    const { viewport } = getEnabledElement(elementToUse);\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return {\n      page: pagePoint,\n      client: clientPoint,\n      canvas: canvasPoint,\n      world: worldPoint,\n      touch: {\n        identifier: i,\n        radiusX: touches[i].radiusX,\n        radiusY: touches[i].radiusY,\n        force: touches[i].force,\n        rotationAngle: touches[i].rotationAngle,\n      },\n    };\n  });\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param touch - The Touch\n */\nfunction _pageToPoint(touch: Touch): Types.Point2 {\n  return [touch.pageX, touch.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Touch `Event`\n */\nfunction _clientToPoint(touch: Touch): Types.Point2 {\n  return [touch.clientX, touch.clientY];\n}\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { Swipe } from '../../enums/Touch';\n\nimport { EventTypes, ITouchPoints, IPoints, IDistance } from '../../types';\n\nimport getTouchEventPoints from './getTouchEventPoints';\nimport {\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaDistance,\n  getDeltaPoints,\n  getMeanTouchPoints,\n  // getRotation\n} from '../../utilities/touch';\nimport { Settings } from '@cornerstonejs/core';\n\nconst runtimeSettings = Settings.getRuntimeSettings();\n\nconst {\n  TOUCH_START,\n  TOUCH_START_ACTIVATE,\n  TOUCH_PRESS,\n  TOUCH_DRAG,\n  TOUCH_END,\n  TOUCH_TAP,\n  TOUCH_SWIPE,\n} = Events;\n\ninterface ITouchTapListnenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  tapMaxDistance: number;\n  tapTimeout: ReturnType<typeof setTimeout>;\n  taps: number;\n  tapToleranceMs: number;\n}\n\ninterface ITouchStartListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  lastPointsList: ITouchPoints[];\n\n  // only trigger one touch event in the case the user puts down multiple fingers\n  isTouchStart: boolean;\n  startTime: Date;\n\n  // handle long press\n  pressTimeout: ReturnType<typeof setTimeout>;\n  pressDelay: number;\n  pressMaxDistance: number;\n  accumulatedDistance: IDistance;\n\n  // handle swipes\n  swipeDistanceThreshold: number;\n  swiped: boolean;\n  swipeToleranceMs: number;\n}\n\nconst zeroIPoint: IPoints = {\n  page: [0, 0],\n  client: [0, 0],\n  canvas: [0, 0],\n  world: [0, 0, 0],\n};\n\nconst zeroIDistance: IDistance = {\n  page: 0,\n  client: 0,\n  canvas: 0,\n  world: 0,\n};\n\n// STATE\nconst defaultState: ITouchStartListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  lastPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  isTouchStart: false,\n  startTime: null,\n\n  pressTimeout: null,\n  pressDelay: 700,\n  pressMaxDistance: 5,\n  accumulatedDistance: zeroIDistance,\n\n  swipeDistanceThreshold: 48,\n  swiped: false,\n  swipeToleranceMs: 300, // user has 300ms to swipe after touch start or no swipe will trigger\n};\n\n// TODO: these values should be configurable to handle different use cases such\n// as pen, left/right handed, index finger vs thumb, etc. These current values\n// assume thumb usage for single finger and index/middle finger for two finger\n// gestures in an attempt to cover the 90% use case.\nconst defaultTapState: ITouchTapListnenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  taps: 0,\n  tapTimeout: null,\n  tapMaxDistance: 24,\n  tapToleranceMs: 300,\n};\n\nlet state: ITouchStartListenerState = JSON.parse(JSON.stringify(defaultState));\nlet tapState: ITouchTapListnenerState = JSON.parse(\n  JSON.stringify(defaultTapState)\n);\n\nfunction triggerEventCallback(ele, name, eventDetail) {\n  if (runtimeSettings.get('debug')) {\n    if (name === 'CORNERSTONE_TOOLS_TOUCH_DRAG') {\n      console.debug(name);\n    } else {\n      console.debug(name, eventDetail);\n    }\n  }\n  return triggerEvent(ele, name, eventDetail);\n}\n\n/**\n * Listens to touch events from the DOM (touchstart, touchmove, touchend)\n * and depending on interaction and further interaction can emit the\n * following touch events:\n *\n * - TOUCH_START\n * - TOUCH_START_ACTIVATE\n * - TOUCH_PRESS\n * - TOUCH_DRAG (move while down)\n * - TOUCH_SWIPE\n * - TOUCH_END (also an end for multi touch)\n *\n * - TOUCH_TAP\n *\n * @param evt - The Touch event (touchstart).\n * @private\n */\nfunction touchStartListener(evt: TouchEvent) {\n  // if a user adds an extra finger when a touch/multi touch has already started\n  // don't trigger another touch.\n  state.element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  // this prevents multiple start firing\n  if (state.isTouchStart) return;\n  // this will clear on touchstart and touchend\n  clearTimeout(state.pressTimeout);\n  state.pressTimeout = setTimeout(() => _onTouchPress(evt), state.pressDelay);\n\n  _onTouchStart(evt);\n  document.addEventListener('touchmove', _onTouchDrag); // also checks for swipe\n  document.addEventListener('touchend', _onTouchEnd); // also checks for tap\n}\n\n/**\n * _onTouchPress - Handle emission of touchstart events which are held down for a longer\n * period of time\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchPress(evt: TouchEvent) {\n  const totalDistance = state.accumulatedDistance.canvas;\n  if (totalDistance > state.pressMaxDistance) return;\n  const eventDetail: EventTypes.TouchPressEventDetail = {\n    event: evt, // touchstart native event\n    eventName: TOUCH_PRESS,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(state.lastPointsList),\n    startPoints: copyPoints(getMeanTouchPoints(state.startPointsList)),\n    lastPoints: copyPoints(getMeanTouchPoints(state.lastPointsList)),\n  };\n  triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);\n}\n\n/**\n * _onTouchStart - Handle emission of touchstart events.\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchStart(evt: TouchEvent) {\n  state.isTouchStart = true;\n  state.startTime = new Date();\n  const startPointsList = getTouchEventPoints(evt, state.element);\n  const startPoints = getMeanTouchPoints(startPointsList);\n  const deltaPoints = zeroIPoint;\n  const deltaDistance = zeroIDistance;\n  // deltaRotation same as deltaDistance but values are theta\n  const eventDetail: EventTypes.TouchStartEventDetail = {\n    event: evt,\n    eventName: TOUCH_START,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: startPointsList,\n    lastPointsList: startPointsList,\n    currentPointsList: startPointsList,\n    startPoints: startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n    deltaDistance,\n    // deltaRotation\n  };\n\n  state.startPointsList = copyPointsList(eventDetail.startPointsList);\n  state.lastPointsList = copyPointsList(eventDetail.lastPointsList);\n  // by triggering TOUCH_START it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const eventDidPropagate = triggerEventCallback(\n    eventDetail.element,\n    TOUCH_START,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default propagation behavior,\n  // create a new tool\n  if (eventDidPropagate) {\n    triggerEventCallback(\n      eventDetail.element,\n      TOUCH_START_ACTIVATE,\n      eventDetail\n    );\n  }\n}\n\n/**\n * _onTouchDrag - Handle emission of drag events whilst the touch is depressed.\n *\n * @private\n * @param evt - The touch event (touchmove)\n */\nfunction _onTouchDrag(evt: TouchEvent) {\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : zeroIPoint;\n\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : zeroIDistance;\n\n  const totalDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistance(currentPointsList, state.lastPointsList)\n      : zeroIDistance;\n\n  state.accumulatedDistance = {\n    page: state.accumulatedDistance.page + totalDistance.page,\n    client: state.accumulatedDistance.client + totalDistance.client,\n    canvas: state.accumulatedDistance.canvas + totalDistance.canvas,\n    world: state.accumulatedDistance.world + totalDistance.world,\n  };\n\n  /**\n   * this is can be uncommented to make dragging smoother. In the future, these values\n   * should be in a configuration file. There may also need to be different\n   * profiles for left handed and right handed thumb use. These values\n   * are currently optimized for left handed use.\n   *\n   * const clamp = (num) => Math.min(Math.max(num, -15), 10);\n   * const deltaDistanceClamped = \\{\n   *     page: clamp(deltaDistance.page),\n   *     client: clamp(deltaDistance.client),\n   *     canvas: clamp(deltaDistance.canvas),\n   *     world: clamp(deltaDistance.world),\n   * \\};\n   */\n\n  const eventDetail: EventTypes.TouchDragEventDetail = {\n    event: evt,\n    eventName: TOUCH_DRAG,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    deltaPoints: deltaPoints,\n    deltaDistance: deltaDistance,\n  };\n\n  triggerEventCallback(state.element, TOUCH_DRAG, eventDetail);\n\n  // check for swipe events\n  _checkTouchSwipe(evt, deltaPoints);\n\n  // Update the last points\n  state.lastPointsList = copyPointsList(currentPointsList);\n}\n\n/**\n * _onTouchEnd - Handle emission of touch end events\n *\n * @private\n * @param evt - The touch event.\n */\nfunction _onTouchEnd(evt: TouchEvent): void {\n  // in case it was a tap event we don't want to fire the cornerstone normalized\n  // touch end event if the touch start never happend\n  clearTimeout(state.pressTimeout);\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : getDeltaPoints(currentPointsList, currentPointsList);\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : getDeltaDistanceBetweenIPoints(currentPointsList, currentPointsList);\n  const eventDetail: EventTypes.TouchEndEventDetail = {\n    event: evt,\n    eventName: TOUCH_END,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    deltaPoints,\n    deltaDistance,\n  };\n\n  triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);\n  _checkTouchTap(evt);\n\n  // reset to default state\n  state = JSON.parse(JSON.stringify(defaultState));\n  document.removeEventListener('touchmove', _onTouchDrag);\n  document.removeEventListener('touchend', _onTouchEnd);\n}\n\nfunction _checkTouchTap(evt: TouchEvent): void {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (currentTime - startTime > tapState.tapToleranceMs) return;\n\n  // first tap, initialize the state\n  if (tapState.taps === 0) {\n    tapState.element = state.element;\n    tapState.renderingEngineId = state.renderingEngineId;\n    tapState.viewportId = state.viewportId;\n    tapState.startPointsList = state.startPointsList;\n  }\n\n  // subsequent tap is on a different element\n  if (\n    tapState.taps > 0 &&\n    !(\n      tapState.element == state.element &&\n      tapState.renderingEngineId == state.renderingEngineId &&\n      tapState.viewportId == state.viewportId\n    )\n  ) {\n    return;\n  }\n\n  const currentPointsList = getTouchEventPoints(evt, tapState.element);\n  const distanceFromStart = getDeltaDistance(\n    currentPointsList,\n    tapState.startPointsList\n  ).canvas;\n\n  // if the tap is too far from starting tap, we can ignore it.\n  // TODO: in the case the user means to tap in two separate areas within the\n  // tapTolerance (300ms), the second tap will not trigger. This is because it\n  // is ignored below for simplicity to track multiple taps (double, triple etc)\n  // in order to support two separate single taps that occur < 300ms on the\n  // screen. One can create the concept of \"TapChains\". Our current implementation\n  // only supports a single tap chain on the screen. You can think of it as a\n  // region where the user has the option to perform unlimited multitaps as long\n  // as they are < the tapToleranceMs value. So a tap somewhere else on the screen\n  // that is > the tapMaxDistance will start a separate and new \"TapChain\".\n  if (distanceFromStart > tapState.tapMaxDistance) return;\n\n  clearTimeout(tapState.tapTimeout);\n  tapState.taps += 1;\n\n  tapState.tapTimeout = setTimeout(() => {\n    const eventDetail: EventTypes.TouchTapEventDetail = {\n      event: evt,\n      eventName: TOUCH_TAP,\n      element: tapState.element,\n      renderingEngineId: tapState.renderingEngineId,\n      viewportId: tapState.viewportId,\n      camera: {},\n      currentPointsList,\n      currentPoints: getMeanTouchPoints(currentPointsList),\n      taps: tapState.taps,\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);\n    tapState = JSON.parse(JSON.stringify(defaultTapState));\n  }, tapState.tapToleranceMs);\n}\n\nfunction _checkTouchSwipe(evt: TouchEvent, deltaPoints: IPoints) {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (state.swiped || currentTime - startTime > state.swipeToleranceMs) return;\n  const [x, y] = deltaPoints.canvas;\n  const eventDetail: EventTypes.TouchSwipeEventDetail = {\n    event: evt,\n    eventName: TOUCH_SWIPE,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    swipe: null,\n  };\n  if (Math.abs(x) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = x > 0 ? Swipe.RIGHT : Swipe.LEFT;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n\n  if (Math.abs(y) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = y > 0 ? Swipe.DOWN : Swipe.UP;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateTouchEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: ITouchPoints[]\n): ITouchPoints[] {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  return lastPoints.map((lp) => {\n    const world = viewport.canvasToWorld(lp.canvas);\n    return {\n      page: lp.page,\n      client: lp.client,\n      canvas: lp.canvas,\n      world,\n      touch: lp.touch,\n    };\n  });\n}\n\nexport default touchStartListener;\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\n\n/**\n * Removes touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  preventGhostClick.disable(element);\n  element.removeEventListener('touchstart', touchStartListener);\n}\n\n/**\n * Registers touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n  preventGhostClick.enable(element);\n  element.addEventListener('touchstart', touchStartListener, {\n    passive: false,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import _cloneDeep from 'lodash.clonedeep';\nimport { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { KeyDownEventDetail, KeyUpEventDetail } from '../../types/EventTypes';\n\ninterface IKeyDownListenerState {\n  renderingEngineId: string;\n  viewportId: string;\n  key: string | null;\n  keyCode: number | null;\n  element: HTMLDivElement;\n}\n\nconst defaultState: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\nlet state: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\n/**\n * Normalizes the keyboard event and triggers KEY_DOWN event from CornerstoneTools3D events\n * @param evt - DOM Keyboard event\n */\nfunction keyListener(evt: KeyboardEvent): void {\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  state.key = evt.key;\n  state.keyCode = evt.keyCode;\n\n  evt.preventDefault();\n  const eventDetail: KeyDownEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n\n    // detail: evt,\n    // Todo: mouse event points can be used later for placing tools with a key\n    // e.g., putting an arrow/probe/etc. on the mouse position. Another use case\n    // hovering and deleting the tool\n    // points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(eventDetail.element, Events.KEY_DOWN, eventDetail);\n\n  document.addEventListener('keyup', _onKeyUp);\n\n  // Todo: handle combination of keys\n  state.element.removeEventListener('keydown', keyListener);\n}\n\nfunction _onKeyUp(evt: KeyboardEvent): void {\n  const eventDetail: KeyUpEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n    // detail: evt,\n  };\n\n  // Remove our temporary handlers\n  document.removeEventListener('keyup', _onKeyUp);\n  state.element.addEventListener('keydown', keyListener);\n\n  // Restore `state` to `defaultState`\n  state = _cloneDeep(defaultState);\n  triggerEvent(eventDetail.element, Events.KEY_UP, eventDetail);\n}\n\nexport function getModifierKey(): number | undefined {\n  return state.keyCode;\n}\n\nexport function resetModifierKey(): void {\n  state.keyCode = undefined;\n}\n\nexport default keyListener;\n","import keyDownListener, { getModifierKey } from './keyDownListener';\n\nfunction enable(element: HTMLDivElement): void {\n  disable(element);\n  element.addEventListener('keydown', keyDownListener);\n}\n\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('keydown', keyDownListener);\n}\n\nexport default {\n  enable,\n  disable,\n  getModifierKey,\n};\n","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\n/**\n * Returns the SVG drawing helper for the given HTML element.\n * @param element - The HTML element to get the SVG drawing helper for.\n * @private\n */\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\n  const svgLayerElement = _getSvgLayer(element);\n\n  // Reset touched\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\n  });\n\n  return {\n    svgLayerElement: svgLayerElement,\n    svgNodeCacheForCanvas: state.svgNodeCache,\n    getSvgNode: getSvgNode.bind(this, canvasHash),\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n  };\n}\n\n/**\n *\n * @param element\n * @private\n */\nfunction _getSvgLayer(element) {\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\n  const internalDivElement = element.querySelector(viewportElement);\n  const svgLayer = internalDivElement.querySelector('.svg-layer');\n\n  return svgLayer;\n}\n\nfunction getSvgNode(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\n  }\n}\n\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return null;\n  }\n\n  state.svgNodeCache[canvasHash][cacheKey] = {\n    touched: true,\n    domRef: svgNode,\n  };\n\n  svgLayerElement.appendChild(svgNode);\n}\n\nfunction setNodeTouched(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\n  }\n}\n\nfunction clearUntouched(svgLayerElement, canvasHash) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n\n    if (!cacheEntry.touched && cacheEntry.domRef) {\n      svgLayerElement.removeChild(cacheEntry.domRef);\n      delete state.svgNodeCache[canvasHash][cacheKey];\n    }\n  });\n}\n\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\n\nfunction draw(\n  element: HTMLDivElement,\n  fn: (svgDrawingElement: any) => any\n): void {\n  const svgDrawingHelper = getSvgDrawingHelper(element);\n\n  // Save...\n  fn(svgDrawingHelper);\n  // Restore...\n\n  svgDrawingHelper.clearUntouched();\n}\n\nexport default draw;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a rendering engine Id and a viewport Id, return the tool group that\n * contains that rendering engine and viewport. Note: A viewport can only be\n * associated with a single tool group. You cannot have a viewport that belongs\n * to multiple tool groups. To achieve so, create a new viewport and a new toolGroup\n * for it. This will not impact memory usage much as the volume textures are\n * shared across all viewports rendering the same image.\n *\n * @param viewportId - The Id of the viewport that the tool is being\n * added to.\n * @param renderingEngineId - The Id of the rendering engine that the\n * tool group is associated with.\n * @returns A tool group.\n */\nfunction getToolGroupForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): IToolGroup | undefined {\n  const toolGroupFilteredByIds = state.toolGroups.filter((tg) =>\n    tg.viewportsInfo.some(\n      (vp) =>\n        vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)\n    )\n  );\n\n  if (!toolGroupFilteredByIds.length) {\n    return;\n  }\n\n  if (toolGroupFilteredByIds.length > 1) {\n    throw new Error(\n      `Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`\n    );\n  }\n\n  return toolGroupFilteredByIds[0];\n}\n\nexport default getToolGroupForViewport;\n","import { ToolGroupManager } from '../store';\nimport { ToolModes } from '../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Finds the enabled element, and iterates over the tools inside its\n * toolGroup. Returns the list of tool instances that are valid based\n * on the provided tool mode.\n *\n * @param element Canvas element\n * @param modesFilter tool modes: active, passive, enabled, disabled\n * @returns enabled tool instances\n */\nexport default function getToolsWithModesForElement(\n  element: HTMLDivElement,\n  modesFilter: ModesFilter\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    /* filter out tools that don't have options */\n    if (!toolOptions) {\n      continue;\n    }\n\n    if (modesFilter.includes(toolOptions.mode)) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import {\n  getEnabledElement,\n  triggerEvent,\n  getRenderingEngine,\n} from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../enums';\nimport { draw as drawSvg } from '../drawingSvg';\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\nimport { AnnotationRenderedEventDetail } from '../types/EventTypes';\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * AnnotationRenderingEngine is a class that is responsible for rendering\n * annotations defined in the renderAnnotation method of annotation tools on the page.\n * It mimics the RenderingEngine in the Cornerstone Core. Here it uses requestAnimationFrame\n * is used to render annotations by calling renderAnnotations() on each enabled tool. Note: This\n * is a Singleton class and should not be instantiated directly. To trigger\n * an annotation render for an HTML element containing a viewport you can use\n *\n * ```\n * triggerAnnotationRender(element)\n * ```\n */\nclass AnnotationRenderingEngine {\n  public hasBeenDestroyed: boolean;\n  private _needsRender: Set<HTMLDivElement> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  private _viewportElements: Map<string, HTMLDivElement>;\n\n  constructor() {\n    this._viewportElements = new Map();\n  }\n\n  /**\n   * Add the viewport's HTMLDivElement to the viewports for rendering. This method\n   * just informs the annotationRenderingEngine about the viewport and\n   * does not initiate a render.\n   * @param viewportId - Viewport Unique identifier\n   * @param element - HTMLDivElement\n   */\n  public addViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.set(viewportId, element);\n  }\n\n  /**\n   * Remove the viewport's HTMLDivElement from subsequent annotation renders\n   * @param viewportId - Viewport Unique identifier\n   */\n  public removeViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.delete(viewportId);\n\n    // delete element from needsRender if element exist\n    this._needsRender.delete(element);\n\n    // I don' think there is any disadvantage to canceling the animation frame\n    // and resetting the flags on viewport's element removal, since the removeVIewportElement\n    // might be as a result of reEnabling the element (in re-enable we disable first), hence the need to render the\n    // new one while removing the old one\n    this._reset();\n  }\n\n  /**\n   * It tells the AnnotationRenderingEngine to render the viewport element the next\n   * time it renders.\n   *\n   * @param element - The element to render.\n   */\n  public renderViewport(element: HTMLDivElement): void {\n    this._setViewportsToBeRenderedNextFrame([element]);\n  }\n\n  /**\n   * _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _renderFlaggedViewports = () => {\n    this._throwIfDestroyed();\n\n    const elements = Array.from(this._viewportElements.values());\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (this._needsRender.has(element)) {\n        this._triggerRender(element);\n\n        // This viewport has been rendered, we can remove it from the set\n        this._needsRender.delete(element);\n\n        // If there is nothing left that is flagged for rendering, stop here\n        // and allow RAF to be called again\n        if (this._needsRender.size === 0) {\n          this._animationFrameSet = false;\n          this._animationFrameHandle = null;\n          return;\n        }\n      }\n    }\n  };\n\n  private _setAllViewportsToBeRenderedNextFrame() {\n    const elements = [...this._viewportElements.values()];\n\n    elements.forEach((element) => {\n      this._needsRender.add(element);\n    });\n\n    this._renderFlaggedViewports();\n  }\n\n  private _setViewportsToBeRenderedNextFrame(elements: HTMLDivElement[]) {\n    const elementsEnabled = [...this._viewportElements.values()];\n\n    // Add the viewports to the set of flagged viewports\n    elements.forEach((element) => {\n      // only enabledElement need to render\n      if (elementsEnabled.indexOf(element) !== -1) {\n        this._needsRender.add(element);\n      }\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   * _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedViewports\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  _triggerRender(element) {\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      console.warn('Element has been disabled');\n      return;\n    }\n\n    const renderingEngine = getRenderingEngine(\n      enabledElement.renderingEngineId\n    );\n    if (!renderingEngine) {\n      console.warn('rendering Engine has been destroyed');\n      return;\n    }\n\n    const enabledTools = getToolsWithModesForElement(element, [\n      Active,\n      Passive,\n      Enabled,\n    ]);\n\n    const { renderingEngineId, viewportId } = enabledElement;\n    const eventDetail: AnnotationRenderedEventDetail = {\n      element,\n      renderingEngineId,\n      viewportId,\n    };\n\n    // const enabledToolsWithAnnotations = enabledTools.filter((tool) => {\n    //   const annotations = getAnnotations(tool.getToolName(), {FrameOfReferenceUID});\n    //   return annotations && annotations.length;\n    // });\n\n    drawSvg(element, (svgDrawingHelper) => {\n      let anyRendered = false;\n      const handleDrawSvg = (tool) => {\n        if (tool.renderAnnotation) {\n          const rendered = tool.renderAnnotation(\n            enabledElement,\n            svgDrawingHelper\n          );\n          anyRendered = anyRendered || rendered;\n        }\n      };\n\n      /**\n       * We should be able to filter tools that don't have annotations, but\n       * currently some of tools have renderAnnotation method BUT\n       * don't keep annotation in the state, so if we do so, the tool will not be\n       * rendered.\n       */\n      enabledTools.forEach(handleDrawSvg);\n\n      if (anyRendered) {\n        triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n      }\n    });\n  }\n\n  /**\n   * _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    this._setAllViewportsToBeRenderedNextFrame();\n  }\n}\n\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\n\n/**\n * It triggers the rendering of the annotations for the given HTML element using\n * the `AnnotationRenderingEngine`\n * @param element - The element to render the annotation on.\n */\nfunction triggerAnnotationRender(element: HTMLDivElement): void {\n  annotationRenderingEngine.renderViewport(element);\n}\n\nexport { annotationRenderingEngine, triggerAnnotationRender };\n\nexport default triggerAnnotationRender;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nconst onImageRendered = function (evt: Types.EventTypes.ImageRenderedEvent) {\n  // TODO: should we do this on camera modified instead of image rendered?\n  // e.g. no need to re-render annotations if only the VOI has changed\n  triggerAnnotationRender(evt.detail.element);\n};\n\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized mouse event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized mouseDown event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  modesFilter: ModesFilter,\n  evtButton?: any\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button - we match those with\n    // any modifier keys too since they can be passively interacted with\n    const correctBinding =\n      evtButton != null && // not null or undefined\n      tool.bindings.length &&\n      tool.bindings.some((binding) => binding.mouseButton === evtButton);\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      // Should not filter by event's button\n      // or should, and the tool binding includes the event's button\n      (!evtButton || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When the camera is modified, check what tools need to react to this.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onCameraModified` method, we call it.\n *\n * @param evt - The normalized camera modified event.\n */\nconst onCameraModified = function (evt: Types.EventTypes.CameraModifiedEvent) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onCameraModified) {\n      tool.onCameraModified(evt);\n    }\n  });\n};\n\nconst enable = function (element) {\n  element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nconst disable = function (element) {\n  element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When image spacing is calibrated modify the annotations for all of its tools\n * to consider the new calibration info.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onImageSpacingCalibrated` method, we call it.\n *\n * @param evt - The normalized image calibration event.\n */\nconst onImageSpacingCalibrated = function (\n  evt: Types.EventTypes.ImageSpacingCalibratedEvent\n) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onImageSpacingCalibrated) {\n      tool.onImageSpacingCalibrated(evt);\n    }\n  });\n};\n\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { state, ToolGroupManager } from '../../store';\nimport ToolModes from '../../enums/ToolModes';\n\nconst { Active } = ToolModes;\n\n/**\n * @function customCallbackHandler This is used as a generic event handler for tool events\n * on viewports. It:\n *\n * - Finds an \"active\" tool with:\n *    - A matching `handlerType`\n *    - A matching `customFunction` on its tool instance\n *\n * Then calls that custom function with raised event.\n *\n * @param handlerType - 'Mouse' | 'Touch' | 'MouseWheel'\n * @param customFunction - Function name that's expected to live on implementing\n *   (and event handling) active tool ex. 'doubleClickCallback'\n * @param evt\n */\nexport default function customCallbackHandler(\n  handlerType: string,\n  customFunction: string,\n  evt\n) {\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return false;\n  }\n\n  // TODO: Filter tools by interaction type?\n  /**\n   * Iterate tool group tools until we find a tool that is:\n   * - active\n   * - has the custom callback function\n   *\n   */\n  let activeTool;\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n    // TODO: Should be getter\n    const toolInstance = toolGroup.getToolInstance(toolName);\n\n    if (\n      // TODO: Should be enum?\n      tool.mode === Active &&\n      // TODO: Should be implements interface?\n      // Weird that we need concrete instance. Other options to filter / get callback?\n      typeof toolInstance[customFunction] === 'function'\n    ) {\n      activeTool = toolGroup.getToolInstance(toolName);\n      break;\n    }\n  }\n\n  if (!activeTool) {\n    return;\n  }\n\n  activeTool[customFunction](evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse click events. Uses `customCallbackHandler` to fire\n * the `mouseClickCallback` function on active tools.\n */\nconst mouseClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'mouseClickCallback'\n);\n\nexport default mouseClick;\n","/**\n * Mouse This enum enumerates the different buttons returned by `.buttons` on the mouse event.\n * These values are used when setting a tool active in a tool group.\n *\n * See also: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nenum MouseBindings {\n  /** usually the left button */\n  Primary = 1,\n  /** usually the right button */\n  Secondary = 2,\n  Primary_And_Secondary = 3,\n  /** usually mouse wheel button */\n  Auxiliary = 4,\n  Primary_And_Auxiliary = 5,\n  Secondary_And_Auxiliary = 6,\n  Primary_And_Secondary_And_Auxiliary = 7,\n  /** usually \"Browser Back\" button */\n  Fourth_Button = 8,\n  /** usually \"Browser Forward\" button */\n  Fifth_Button = 16,\n}\n\nenum KeyboardBindings {\n  Shift = 16,\n  Ctrl = 17,\n  Alt = 18,\n  Meta = 91,\n  ShiftCtrl = 1617,\n  ShiftAlt = 1618,\n  ShiftMeta = 1691,\n  CtrlAlt = 1718,\n  CtrlMeta = 1791,\n  AltMeta = 1891,\n}\n\nexport { MouseBindings, KeyboardBindings };\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationsPair,\n  ToolsWithMoveableHandles,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools, returning only tools with moveable handles at the mouse location that are not locked\n *\n * @param element - The element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction (e.g. 'mouse' or 'touch')\n * @returns The filtered array.\n */\nexport default function filterToolsWithMoveableHandles(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolsWithMoveableHandles[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n  const toolsWithMoveableHandles = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const handle = tool.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        proximity\n      );\n\n      if (handle) {\n        toolsWithMoveableHandles.push({\n          tool,\n          annotation,\n          handle,\n        });\n        break;\n      }\n    }\n  });\n\n  return toolsWithMoveableHandles;\n}\n","import { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport { ToolAnnotationsPair } from '../types/InternalToolTypes';\nimport type AnnotationTool from '../tools/base/AnnotationTool';\nimport BaseTool from '../tools/base/BaseTool';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\n/**\n * Filters an array of tools, returning only tools which have annotation.\n *\n * @param element - The cornerstone3D enabled element.\n * @param tools - The array of tools to check.\n *\n * @returns The array of tools with their found annotations.\n */\nexport default function filterToolsWithAnnotationsForElement(\n  element: HTMLDivElement,\n  tools: AnnotationTool[]\n): ToolAnnotationsPair[] {\n  const result = [];\n  for (let i = 0; i < tools.length; i++) {\n    const tool = tools[i];\n\n    if (!tool) {\n      console.warn('undefined tool in filterToolsWithAnnotationsForElement');\n      continue;\n    }\n\n    let annotations = getAnnotations(\n      (tool.constructor as typeof BaseTool).toolName,\n      element\n    );\n\n    if (!annotations?.length) {\n      continue;\n    }\n\n    if (typeof tool.filterInteractableAnnotationsForElement === 'function') {\n      // If the tool has a annotations filter (e.g. with in-plane-annotations-only filtering), use it.\n      annotations = tool.filterInteractableAnnotationsForElement(\n        element,\n        annotations\n      );\n    }\n\n    if (annotations.length > 0) {\n      result.push({ tool, annotations });\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationPair,\n  ToolAnnotationsPair,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools with annotations, returning the first annotation\n * for each tool that is moveable and at the mouse location. It results in\n * one annotation per tool.\n *\n *\n * @param element - The HTML element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction that is taking place.\n * @returns The filtered array containing ToolAndAnnotation\n */\nexport default function filterMoveableAnnotationTools(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolAnnotationPair[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n\n  // TODO - This could get pretty expensive pretty quickly. We don't want to fetch the camera\n  // And do world to canvas on each coord.\n\n  // We want to produce a matrix from canvas to world for the viewport and just do a matrix operation on each handle.\n  // This could still be expensive for ROIs, but we probably shouldn't have \"handles\" for them anyway.\n\n  const moveableAnnotationTools = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const near = tool.isPointNearTool(\n        element,\n        annotation,\n        canvasCoords,\n        proximity,\n        interactionType\n      );\n\n      if (near) {\n        moveableAnnotationTools.push({\n          tool,\n          annotation,\n        });\n        break;\n      }\n    }\n  });\n\n  return moveableAnnotationTools;\n}\n","import { KeyboardBindings as kb } from '../../enums';\n\n/**\n * Gets the mouse modifier key from a mouse event.\n * Supports Shift, Ctrl, Alt, in singly and in combinations of 2\n * Supports Meta singly.\n */\nconst getMouseModifierKey = (evt) => {\n  // The logic is a hard coded key mapping\n  if (evt.shiftKey) {\n    if (evt.ctrlKey) return kb.ShiftCtrl;\n    if (evt.altKey) return kb.ShiftAlt;\n    if (evt.metaKey) return kb.ShiftMeta;\n    return kb.Shift;\n  }\n  if (evt.ctrlKey) {\n    if (evt.altKey) return kb.CtrlAlt;\n    if (evt.metaKey) return kb.CtrlMeta;\n    return kb.Ctrl;\n  }\n  if (evt.altKey) {\n    return (evt.metaKey && kb.AltMeta) || kb.Alt;\n  }\n  if (evt.metaKey) {\n    kb.Meta;\n  }\n  return undefined;\n};\n\nexport default getMouseModifierKey;\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our MouseEvent's `buttons`. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The event dispatcher mouse event.\n *\n * @returns tool\n */\nexport default function getActiveToolForMouseEvent(\n  evt: EventTypes.NormalizedMouseEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForMouseEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const mouseEvent = evt.detail.event;\n\n  // If any keyboard modifier key is also pressed\n  // Use the actual key if set, otherwise get the key from the mouse event.\n  const modifierKey =\n    keyEventListener.getModifierKey() || getMouseModifier(mouseEvent);\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some((binding) => {\n        return (\n          binding.mouseButton ===\n            (mouseEvent ? mouseEvent.buttons : MouseBindings.Primary) &&\n          binding.modifierKey === modifierKey\n        );\n      });\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * When the mouse is depressed we check which entities can process these events in the following manner:\n *\n * - First we get the `activeTool` for the mouse button pressed.\n * - If the `activeTool` has a `preMouseDownCallback`, this is called. If the callback returns `true`,\n *   the event does not propagate further.\n * - Next we get all tools which are active or passive (`activeAndPassiveTools`), as annotation. for these tools could\n *   possibly catch and handle these events. We then filter the `activeAndPassiveTools` using `filterToolsWithAnnotationsForElement`, which filters tools with annotations\n *   for this frame of reference. Optionally a tool can employ a further filtering (via a\n *   `filterInteractableAnnotationsForElement` callback) for tools interactable within the current camera view\n *   (e.g. tools that only render when viewed from a certain direction).\n * - Next we check if any handles are interactable for each tool (`filterToolsWithMoveableHandles`). If interactable\n *   handles are found, the first tool/handle found consumes the event and the event does not propagate further.\n * - Next we check any tools are interactable (e.g. moving an entire length annotation rather than one of its handles:\n *   `filterMoveableAnnotationTools`). If interactable tools are found, the first tool found consumes the event and the\n *   event does not propagate further.\n * - Finally, if the `activeTool` has `postMouseDownCallback`, this is called.  If the callback returns `true`,\n *   the event does not propagate further.\n *\n * If the event is not consumed the event will bubble to the `mouseDownActivate` handler.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDown(evt: EventTypes.MouseDownEventType) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  // Check for preMouseDownCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.preMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  // Find all tools that might respond to this mouse down\n  const isPrimaryClick = evt.detail.event.buttons === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForMouseEvent(\n    evt,\n    [Active],\n    evt.detail.event.buttons\n  );\n  const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick\n    ? getToolsWithModesForMouseEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryMouseButton || []),\n  ];\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this mouse down\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // Preserve existing selections when shift key is pressed\n  const isMultiSelect = !!evt.detail.event.shiftKey;\n\n  // If there are annotation tools whose handle is near the mouse, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Mouse');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the mouse, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Mouse');\n\n    return;\n  }\n\n  // Run the postMouseDownCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.postMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that mouseDownActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { state } from '../../store';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { EventTypes } from '../../types';\n\n/**\n * If the `mouseDown` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * mouse button pressed.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDownActivate(\n  evt: EventTypes.MouseDownActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'mouse');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * @function mouseDoubleClick - Event handler for mouse double click events. Uses `customCallbackHandler` to fire\n * the `doubleClickCallback` function on active tools.\n */\nconst mouseDoubleClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'doubleClickCallback'\n);\n\nexport default mouseDoubleClick;\n","import getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { state } from '../../store';\nimport { MouseDragEventType } from '../../types/EventTypes';\n\n/**\n * mouseDrag - Event handler for mouse drag events. Fires the `mouseDragCallback`\n * function on active tools.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDrag(evt: MouseDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  const noFoundToolOrDoesNotHaveMouseDragCallback =\n    !activeTool || typeof activeTool.mouseDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveMouseDragCallback) {\n    return;\n  }\n\n  activeTool.mouseDragCallback(evt);\n}\n","// // State\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\n\n// // Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport { MouseMoveEventType } from '../../types/EventTypes';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * mouseMove - On mouse move when not dragging, fire tools `mouseMoveCallback`s.\n * This is mostly used to update the [un]hover state\n * of a tool.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseMove(evt: MouseMoveEventType) {\n  // Tool interactions when mouse moved are handled inside each tool.\n  // This function is mostly used to update the [un]hover state\n  if (state.isInteractingWithTool || state.isMultiPartToolActive) {\n    return;\n  }\n\n  const activeAndPassiveTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Annotation tool specific\n  const toolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    activeAndPassiveTools\n  );\n\n  const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {\n    const doesNotHaveAnnotations = !toolsWithAnnotations.some(\n      (toolAndAnnotation) =>\n        toolAndAnnotation.tool.getToolName() === tool.getToolName()\n    );\n\n    return doesNotHaveAnnotations;\n  });\n\n  let annotationsNeedToBeRedrawn = false;\n\n  for (const { tool, annotations } of toolsWithAnnotations) {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      annotationsNeedToBeRedrawn =\n        tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;\n    }\n  }\n\n  // Run mouse move handlers for non-annotation tools\n  toolsWithoutAnnotations.forEach((tool) => {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      tool.mouseMoveCallback(evt);\n    }\n  });\n\n  // Annotation activation status changed, redraw the annotations\n  if (annotationsNeedToBeRedrawn === true) {\n    triggerAnnotationRender(element);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse up events. Uses `customCallbackHandler` to fire\n * the `mouseUpCallback` function on active tools.\n */\nconst mouseUp = customCallbackHandler.bind(null, 'Mouse', 'mouseUpCallback');\n\nexport default mouseUp;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * Event handler for mouse wheel events. Uses `customCallbackHandler` to fire\n * the `mouseWheelCallback` function on active tools.\n */\nconst mouseWheel = customCallbackHandler.bind(\n  null,\n  'MouseWheel',\n  'mouseWheelCallback'\n);\n\nexport default mouseWheel;\n","import Events from '../enums/Events';\n\nimport {\n  mouseClick,\n  mouseDown,\n  mouseDownActivate,\n  mouseDoubleClick,\n  mouseDrag,\n  mouseMove,\n  mouseUp,\n  mouseWheel,\n} from './mouseEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.addEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.addEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.addEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.addEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.addEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.addEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.addEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.removeEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.removeEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.removeEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.removeEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.removeEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.removeEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\nconst mouseToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default mouseToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes, MouseBindings } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport { getMouseButton } from '../../eventListeners/mouse/mouseDownListener';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our Keyboard pressed keys. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The normalized keyboard event.\n *\n * @returns tool\n */\nexport default function getActiveToolForKeyboardEvent(\n  evt: EventTypes.KeyDownEventType\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  // Get the current mouse button clicked\n  const mouseButton = getMouseButton();\n\n  // If any keyboard modifier key is also pressed\n  const modifierKey = keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some(\n        (binding) =>\n          binding.mouseButton === (mouseButton ?? MouseBindings.Primary) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { KeyDownEventType } from '../../types/EventTypes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyDown(evt: KeyDownEventType): void {\n  // get the active tool given the key and mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  const toolName = activeTool.getToolName();\n  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n    toolGroup.setViewportsCursorByToolName(toolName);\n  }\n}\n","import { resetModifierKey } from '../../eventListeners/keyboard/keyDownListener';\nimport { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { KeyDownEventType } from '../../types/EventTypes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyUp(evt: KeyDownEventType): void {\n  // get the active tool for the primary mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  // Reset the modifier key\n  resetModifierKey();\n\n  const toolName = activeTool.getToolName();\n  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n    toolGroup.setViewportsCursorByToolName(toolName);\n  }\n}\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\n\n/**\n * Enable Key down and key up listeners\n *\n * @param element - The HTML element to attach the event listeners to.\n */\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.addEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\n/**\n * Disable Key down and key up listeners\n * @param element - The HTML element to attach the event listeners to.\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.removeEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\nconst keyboardToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default keyboardToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our TouchEvent's `buttons`. It's possible there will be no match\n * (no active tool for that touch button combination).\n *\n * @param evt - The event dispatcher touch event.\n *\n * @returns tool\n */\nexport default function getActiveToolForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForTouchEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const touchEvent = evt.detail.event;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  const numTouchPoints = Object.keys(touchEvent.touches).length;\n\n  // If any keyboard modifier key is also pressed\n  const modifierKey = getMouseModifier(touchEvent);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      toolOptions.bindings.length &&\n      /**\n       * TODO: setActiveTool treats MouseBindings.Primary in a special way\n       * which is analgous to numTouchPoints === 1 as the primary interaction\n       * for touch based applications. The ToolGroup set active and get active\n       * logic should be updated to account for numTouchPoints === 1\n       */\n      toolOptions.bindings.some(\n        (binding) =>\n          (binding.numTouchPoints === numTouchPoints ||\n            (numTouchPoints === 1 &&\n              binding.mouseButton === MouseBindings.Primary)) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized touch event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized touchStart event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType,\n  modesFilter: ModesFilter,\n  numTouchPoints?: number\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      numTouchPoints != null &&\n      tool.bindings.length &&\n      tool.bindings.some(\n        (binding) => binding.numTouchPoints === numTouchPoints\n      );\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      (!numTouchPoints || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport getToolsWithModesForTouchEvent from '../shared/getToolsWithModesForTouchEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * touchStart - Event handler for touchStart events. Uses `customCallbackHandler` to fire\n * the `touchStartCallback` function on active tools.\n */\nexport default function touchStart(evt: EventTypes.TouchStartEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  // Check for preTouchStartCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.preTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForTouchEvent(\n    evt,\n    [Active],\n    Object.keys(evt.detail.event.touches).length\n  );\n  const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick\n    ? getToolsWithModesForTouchEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryTouchButton || []),\n    activeTool,\n  ];\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this touch start\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  const isMultiSelect = false;\n\n  // If there are annotation tools whose handle is near the touch, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Touch');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the touch, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Touch');\n\n    return;\n  }\n\n  // Run the postTouchStartCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.postTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that touchStartActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { state } from '../../store';\nimport { EventTypes } from '../../types';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\n\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\n\n/**\n * If the `touchStart` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * touch button pressed.\n *\n * @param evt - The normalized touchStart event.\n */\nexport default function touchStartActivate(\n  evt: EventTypes.TouchStartActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'touch');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport { state } from '../../store';\nimport { TouchDragEventType } from '../../types/EventTypes';\n\n/**\n * touchDrag - Event handler for touchDrag events. Uses `customCallbackHandler` to fire\n * the `touchDragCallback` function on active tools.\n */\nexport default function touchDrag(evt: TouchDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  const noFoundToolOrDoesNotHaveTouchDragCallback =\n    !activeTool || typeof activeTool.touchDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveTouchDragCallback) {\n    return;\n  }\n\n  activeTool.touchDragCallback(evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchEnd - Event handler for touchEnd events. Uses `customCallbackHandler` to fire\n * the `touchEndCallback` function on active tools.\n */\nconst touchEnd = customCallbackHandler.bind(null, 'Touch', 'touchEndCallback');\n\nexport default touchEnd;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchTap - Event handler for touch tap events. Uses `customCallbackHandler` to fire\n * the `touchTapCallback` function on active tools.\n */\nconst touchTap = customCallbackHandler.bind(null, 'Touch', 'touchTapCallback');\n\nexport default touchTap;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchPress - Event handler for touch press events. Uses `customCallbackHandler` to fire\n * the `touchPressCallback` function on active tools.\n */\nconst touchPress = customCallbackHandler.bind(\n  null,\n  'Touch',\n  'touchPressCallback'\n);\n\nexport default touchPress;\n","import Events from '../enums/Events';\n\nimport {\n  touchStart,\n  touchStartActivate,\n  touchDrag,\n  touchEnd,\n  touchTap,\n  touchPress,\n} from './touchEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.addEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.addEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.addEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.addEventListener(Events.TOUCH_TAP, touchTap as EventListener);\n  element.addEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.removeEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.removeEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.removeEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.removeEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\nconst touchToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default touchToolEventDispatcher;\n","import { Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  touchToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n} from '../eventDispatchers';\nimport { state } from './state';\n\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\n/**\n * When an element is \"enabled\", add event listeners and dispatchers to it\n * so we can use interactions to affect tool behaviors\n *\n * @param evt - The ELEMENT_ENABLED event\n */\nexport default function addEnabledElement(\n  evt: Types.EventTypes.ElementEnabledEvent\n): void {\n  const { element, viewportId } = evt.detail;\n  const svgLayer = _createSvgAnnotationLayer(viewportId);\n\n  // Reset/Create svgNodeCache for element\n  _setSvgNodeCache(element);\n  _appendChild(svgLayer, element);\n\n  // Add this element to the annotation rendering engine\n  annotationRenderingEngine.addViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.enable(element);\n  wheelEventListener.enable(element);\n  touchEventListeners.enable(element);\n  keyEventListener.enable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.enable(element);\n  cameraModifiedEventDispatcher.enable(element);\n  imageSpacingCalibratedEventDispatcher.enable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.enable(element);\n  keyboardToolEventDispatcher.enable(element);\n  touchToolEventDispatcher.enable(element);\n\n  // labelmap\n  // State\n  state.enabledElements.push(element);\n}\n\n/**\n *\n */\nfunction _createSvgAnnotationLayer(viewportId: string): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgLayer = document.createElementNS(svgns, 'svg');\n\n  const svgLayerId = `svg-layer-${viewportId}`;\n  svgLayer.classList.add('svg-layer');\n  svgLayer.setAttribute('id', svgLayerId);\n  svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgLayer.style.width = '100%';\n  svgLayer.style.height = '100%';\n  svgLayer.style.pointerEvents = 'none';\n  svgLayer.style.position = 'absolute';\n  // TODO: we should test this on high-res monitors\n  //svgLayer.style.textRendering = 'optimizeSpeed'\n\n  // Single dropshadow config for now\n  const defs = document.createElementNS(svgns, 'defs');\n  const filter = document.createElementNS(svgns, 'filter');\n  const feOffset = document.createElementNS(svgns, 'feOffset');\n  const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n  const feBlend = document.createElementNS(svgns, 'feBlend');\n\n  //\n  filter.setAttribute('id', `shadow-${svgLayerId}`);\n  filter.setAttribute('filterUnits', 'userSpaceOnUse');\n\n  //\n  feOffset.setAttribute('result', 'offOut');\n  feOffset.setAttribute('in', 'SourceGraphic');\n  feOffset.setAttribute('dx', '0.5');\n  feOffset.setAttribute('dy', '0.5');\n\n  //\n  feColorMatrix.setAttribute('result', 'matrixOut');\n  feColorMatrix.setAttribute('in', 'offOut');\n  feColorMatrix.setAttribute('in2', 'matrix');\n  feColorMatrix.setAttribute(\n    'values',\n    '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0'\n  );\n\n  //\n  feBlend.setAttribute('in', 'SourceGraphic');\n  feBlend.setAttribute('in2', 'matrixOut');\n  feBlend.setAttribute('mode', 'normal');\n\n  filter.appendChild(feOffset);\n  filter.appendChild(feColorMatrix);\n  filter.appendChild(feBlend);\n  defs.appendChild(filter);\n  svgLayer.appendChild(defs);\n\n  return svgLayer;\n}\n\nfunction _setSvgNodeCache(element) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  // Create or reset\n  // TODO: If... Reset, we should blow out any nodes in DOM\n  state.svgNodeCache[elementHash] = {};\n}\n\n/**\n *\n * @param newNode\n * @param referenceNode\n */\nfunction _appendChild(\n  newNode: SVGElement,\n  referenceNode: HTMLDivElement\n): void {\n  referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * It returns all synchronizers that are not disabled and have a source viewport\n * with the given rendering engine Id and viewport Id\n * @param renderingEngineId - The Id of the rendering engine\n * @param viewportId - The Id of the viewport\n * @returns An array of synchronizers\n */\nfunction getSynchronizersForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): Array<Synchronizer> {\n  const synchronizersFilteredByIds = [];\n\n  if (!renderingEngineId && !viewportId) {\n    throw new Error(\n      'At least one of renderingEngineId or viewportId should be given'\n    );\n  }\n\n  for (let i = 0; i < state.synchronizers.length; i++) {\n    const synchronizer = state.synchronizers[i];\n    const notDisabled = !synchronizer.isDisabled();\n    const hasSourceViewport = synchronizer.hasSourceViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    const hasTargetViewport = synchronizer.hasTargetViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n      synchronizersFilteredByIds.push(synchronizer);\n    }\n  }\n\n  return synchronizersFilteredByIds;\n}\n\nexport default getSynchronizersForViewport;\n","import { getEnabledElement, Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n  touchToolEventDispatcher,\n} from '../eventDispatchers';\n// ~~\n\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\nfunction removeEnabledElement(\n  elementDisabledEvt: Types.EventTypes.ElementDisabledEvent\n): void {\n  // Is DOM element\n  const { element, viewportId } = elementDisabledEvt.detail;\n\n  _resetSvgNodeCache(element);\n  _removeSvgNode(element);\n\n  // Remove this element from the annotation rendering engine\n  annotationRenderingEngine.removeViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.disable(element);\n  wheelEventListener.disable(element);\n  touchEventListeners.disable(element);\n  keyEventListener.disable(element);\n  // labelmap\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.disable(element);\n  cameraModifiedEventDispatcher.disable(element);\n  imageSpacingCalibratedEventDispatcher.disable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.disable(element);\n  keyboardToolEventDispatcher.disable(element);\n  touchToolEventDispatcher.disable(element);\n\n  // State\n  // @TODO: We used to \"disable\" the tool before removal. Should we preserve the hook that would call on tools?\n  _removeViewportFromSynchronizers(element);\n  _removeViewportFromToolGroup(element);\n\n  // _removeAllToolsForElement(canvas)\n  _removeEnabledElement(element);\n}\n\nconst _removeViewportFromSynchronizers = (element: HTMLDivElement) => {\n  const enabledElement = getEnabledElement(element);\n\n  const synchronizers = getSynchronizersForViewport(\n    enabledElement.viewportId,\n    enabledElement.renderingEngineId\n  );\n  synchronizers.forEach((sync) => {\n    sync.remove(enabledElement);\n  });\n};\n\nconst _removeViewportFromToolGroup = (element: HTMLDivElement) => {\n  const { renderingEngineId, viewportId } = getEnabledElement(element);\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (toolGroup) {\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n  }\n};\n\nconst _removeAllToolsForElement = function (element) {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  toolsWithData.forEach(({ annotations }) => {\n    annotations.forEach((annotation) => {\n      removeAnnotation(annotation.annotationUID);\n    });\n  });\n};\n\nfunction _resetSvgNodeCache(element: HTMLDivElement) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  delete state.svgNodeCache[elementHash];\n}\n\nfunction _removeSvgNode(element: HTMLDivElement) {\n  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n  const svgLayer = internalViewportNode.querySelector('svg');\n  if (svgLayer) {\n    internalViewportNode.removeChild(svgLayer);\n  }\n}\n\n/**\n * @private\n * @param enabledElement\n */\nconst _removeEnabledElement = function (element: HTMLDivElement) {\n  const foundElementIndex = state.enabledElements.findIndex(\n    (el) => el === element\n  );\n\n  if (foundElementIndex > -1) {\n    state.enabledElements.splice(foundElementIndex, 1);\n  }\n};\n\nexport default removeEnabledElement;\n","import type { Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\n\nexport function triggerAnnotationRenderForViewportIds(\n  renderingEngine: Types.IRenderingEngine,\n  viewportIdsToRender: string[]\n): void {\n  if (!viewportIdsToRender.length) {\n    return;\n  }\n\n  viewportIdsToRender.forEach((viewportId) => {\n    const { element } = renderingEngine.getViewport(viewportId);\n    triggerAnnotationRender(element);\n  });\n}\n\nexport default triggerAnnotationRenderForViewportIds;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\n/**\n * This is a callback function that is called when an annotation is modified.\n * Since we are throttling the cachedStats calculation for annotation tools,\n * we need to trigger a final render for the annotation. so that the annotation\n * textBox is updated.\n * Todo: This will trigger all the annotation tools to re-render, although DOM\n * will update those that have changed, but more efficient would be to only\n * update the changed annotation.\n * Todo: A better way is to extract the textBox render logic from the renderAnnotation\n * of all tools and just trigger a render for that (instead of the entire annotation., even if\n * no svg update happens since the attributes for handles are the same)\n */\nfunction annotationModifiedListener(evt): void {\n  const { viewportId, renderingEngineId } = evt.detail;\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n  triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n}\n\nexport default annotationModifiedListener;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\n\n/**\n * When an annotation is deselected, trigger an annotation render for all viewports.\n * The reason for this is that, drawing an annotation in a different viewport\n * should deselect all other annotations in other viewports. In order to achieve\n * this, we need to trigger an annotation render for all viewports.\n * Todo: Although this is inefficient, but since annotations are only rendered if necessary,\n * it's probably not going to have a noticeable impact on performance.\n * @param evt - The event object.\n */\nfunction annotationSelectionListener(evt): void {\n  const deselectedAnnotation = evt.detail.removed;\n\n  if (!deselectedAnnotation.length) {\n    return;\n  }\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n    const viewportIds = viewports.map((vp) => vp.id);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  });\n}\n\nexport default annotationSelectionListener;\n","import { SegmentationModifiedEventType } from '../../types/EventTypes';\nimport {\n  getToolGroupIdsWithSegmentation,\n  getSegmentationRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\n\n/** A function that listens to the `segmentationModified` event and triggers\n * the triggerSegmentationRepresentationModified on each toolGroup that\n * has a representation of the given segmentationId.\n */\nconst segmentationModifiedListener = function (\n  evt: SegmentationModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n\n  const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n  toolGroupIds.forEach((toolGroupId) => {\n    const segRepresentations = getSegmentationRepresentations(toolGroupId);\n    segRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        triggerSegmentationRepresentationModified(\n          toolGroupId,\n          representation.segmentationRepresentationUID\n        );\n      }\n    });\n  });\n};\n\nexport default segmentationModifiedListener;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a tool group Id, return the tool group\n * @param toolGroupId - The Id of the tool group to be retrieved.\n * @returns The tool group that has the same id as the tool group id that was\n * passed in.\n */\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\n  return state.toolGroups.find((s) => s.id === toolGroupId);\n}\n\nexport default getToolGroup;\n","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\n\nimport {\n  RepresentationConfig,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It returns the global segmentation config.\n * @returns The global segmentation config containing the representations\n * config for each representation type and renderInactiveSegmentations flag.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  return SegmentationState.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation config\n * @param segmentationConfig - SegmentationConfig\n */\nfunction setGlobalConfig(\n  segmentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setGlobalConfig(segmentationConfig);\n}\n\n/**\n * Given a representation type, return the corresponding global representation config\n * @param representationType - The type of representation to query\n * @returns A representation configuration object.\n */\nfunction getGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations\n): RepresentationConfig['LABELMAP'] {\n  const globalConfig = getGlobalConfig();\n  return globalConfig.representations[representationType];\n}\n\n/**\n * Set the global configuration for a given representation type. It fires\n * a SEGMENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param representationType - The type of representation to set config for\n * @param config - The configuration for the representation.\n */\nfunction setGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations,\n  config: RepresentationConfig['LABELMAP']\n): void {\n  const globalConfig = getGlobalConfig();\n\n  setGlobalConfig({\n    ...globalConfig,\n    representations: {\n      ...globalConfig.representations,\n      [representationType]: {\n        ...globalConfig.representations[representationType],\n        ...config,\n      },\n    },\n  });\n}\n\n/**\n * Get the toolGroup specific segmentation config\n * @param toolGroupId - The Id of the tool group\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Sets the tool group specific configuration for the segmentation\n * representation. This will apply to all segmentation representations.\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationConfig - This is the configuration object that you will use to set the default values for\n * the segmentation representation.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setToolGroupSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationConfig\n  );\n}\n\n/**\n * Give the segmentation representation UID, return the corresponding config\n * which is shared by all segments in the segmentation representation. This is\n * an optional level of configuration that can be set by the user, by default\n * it will fallback to the toolGroup specific config, if not set, it will fallback\n * to the global config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n * @returns - The configuration for the representation.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  return SegmentationState.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Set the segmentation representation specific configuration for the\n * segmentation representation. This will apply to all segments in the\n * segmentation representation and has higher priority than the toolGroup\n * specific config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig\n): void {\n  SegmentationState.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\n/**\n * Get the segment specific configuration for the segmentation representation.\n *\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID  - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @returns - The configuration for the segment index in the segmentation representation that is shown in the toolGroup's viewport\n */\nfunction getSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  return SegmentationState.getSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\n/**\n * Set the segment specific configuration for the segmentation representation.\n * This configuration, if specified, has higher priority than the segmentation representation specific config,\n * and the toolGroup specific config. The order of priority is: segment specific config > segmentation representation specific config > toolGroup specific config > global config\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @param config - The configuration for the representation. This is an object\n */\nfunction setSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig\n): void {\n  SegmentationState.setSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport {\n  // Global\n  getGlobalConfig,\n  setGlobalConfig,\n  getGlobalRepresentationConfig,\n  setGlobalRepresentationConfig,\n  // ToolGroup Specific\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  // segmentation representation specific config\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  // segment specific config\n  getSegmentSpecificConfig,\n  setSegmentSpecificConfig,\n};\n","import { cache, Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\n\nfunction getSegmentationIndices(segmentationId) {\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (segmentation.type === SegmentationRepresentations.Labelmap) {\n    const volume = cache.getVolume(segmentationId);\n    const scalarData = volume.getScalarData();\n\n    const keySet = {};\n    scalarData.forEach((it) => (keySet[it] = it));\n    return Object.keys(keySet).map((it) => parseInt(it, 10));\n  } else if (segmentation.type === SegmentationRepresentations.Contour) {\n    const geometryIds = segmentation.representationData.CONTOUR?.geometryIds;\n\n    if (!geometryIds) {\n      throw new Error(\n        `No geometryIds found for segmentationId ${segmentationId}`\n      );\n    }\n\n    return geometryIds.map((geometryId) => {\n      const geometry = cache.getGeometry(geometryId) as Types.IGeometry;\n      return (geometry.data as Types.IContourSet).getSegmentIndex();\n    });\n  }\n}\n\n/**\n * Set the visibility of a segmentation representation for a given tool group. It fires\n * a SEGMENTATION_REPRESENTATION_MODIFIED event. Visibility true will show all segments\n * and visibility false will hide all segments\"\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param visibility - boolean\n */\nfunction setSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  visibility: boolean\n): void {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n\n  const indices = getSegmentationIndices(segmentationId);\n\n  // if visibility is set to be true, we need to remove all the segments\n  // from the segmentsHidden set, otherwise we need to add all the segments\n  // to the segmentsHidden set\n  if (visibility) {\n    segmentsHidden.clear();\n  } else {\n    indices.forEach((index) => {\n      segmentsHidden.add(index);\n    });\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    representation.segmentationRepresentationUID\n  );\n}\n\n/**\n * Get the visibility of a segmentation data for a given tool group.\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The id of the segmentation data to get\n * @returns A boolean value that indicates whether the segmentation data is visible or\n * not on the toolGroup\n */\nfunction getSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): boolean | undefined {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden } = representation;\n\n  return segmentsHidden.size === 0;\n}\n\n/**\n * Set the visibility of the given segment indices to the given visibility. This\n * is a helper to set the visibility of multiple segments at once and reduces\n * the number of events fired.\n *\n * @param toolGroupId -  The tool group id of the segmentation representation.\n * @param segmentationRepresentationUID -  The UID of the segmentation\n * representation.\n * @param segmentIndices -  The indices of the segments to be hidden/shown.\n * @param visibility -  The visibility to set the segments to.\n *\n */\nfunction setSegmentsVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndices: number[],\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  segmentIndices.forEach((segmentIndex) => {\n    visibility\n      ? segRepresentation.segmentsHidden.delete(segmentIndex)\n      : segRepresentation.segmentsHidden.add(segmentIndex);\n  });\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction setSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  visibility\n    ? segRepresentation.segmentsHidden.delete(segmentIndex)\n    : segRepresentation.segmentsHidden.add(segmentIndex);\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  setSegmentationVisibility,\n  getSegmentationVisibility,\n  setSegmentVisibility,\n  setSegmentsVisibility,\n};\n","import { StackViewport, VolumeViewport, utilities } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../../enums';\nimport { InteractionTypes, ToolProps, PublicToolProps } from '../../types';\n\nexport interface IBaseTool {\n  /** ToolGroup ID the tool instance belongs to */\n  toolGroupId: string;\n  /** Tool supported interaction types */\n  supportedInteractionTypes: InteractionTypes[];\n  /** Tool Mode : Active, Passive, Enabled, Disabled */\n  mode: ToolModes;\n  /** Tool Configuration */\n  configuration: {\n    preventHandleOutsideImage?: boolean;\n    strategies?: Record<string, any>;\n    defaultStrategy?: string;\n    activeStrategy?: string;\n    strategyOptions?: Record<string, unknown>;\n  };\n}\n\n/**\n * Abstract base class from which all tools derive.\n * Deals with cleanly merging custom and default configuration, and strategy\n * application.\n */\nabstract class BaseTool implements IBaseTool {\n  static toolName;\n  /** Supported Interaction Types - currently only Mouse */\n  public supportedInteractionTypes: InteractionTypes[];\n  public configuration: Record<string, any>;\n  /** ToolGroup ID the tool instance belongs to */\n  public toolGroupId: string;\n  /** Tool Mode - Active/Passive/Enabled/Disabled/ */\n  public mode: ToolModes;\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n\n    const {\n      configuration = {},\n      supportedInteractionTypes,\n      toolGroupId,\n    } = initialProps;\n\n    // If strategies are not initialized in the tool config\n    if (!configuration.strategies) {\n      configuration.strategies = {};\n      configuration.defaultStrategy = undefined;\n      configuration.activeStrategy = undefined;\n      configuration.strategyOptions = {};\n    }\n\n    this.toolGroupId = toolGroupId;\n    this.supportedInteractionTypes = supportedInteractionTypes || [];\n    this.configuration = Object.assign({}, configuration);\n    this.mode = ToolModes.Disabled;\n  }\n\n  /**\n   * Returns the name of the tool\n   * @returns The name of the tool.\n   */\n  public getToolName(): string {\n    // Since toolName is static we get it from the class constructor\n    return (<typeof BaseTool>this.constructor).toolName;\n  }\n\n  /**\n   * It applies the active strategy to the enabled element.\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategy(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n    return strategies[activeStrategy].call(this, enabledElement, operationData);\n  }\n\n  /**\n   * merges the new configuration with the tool configuration\n   * @param configuration - toolConfiguration\n   */\n  public setConfiguration(newConfiguration: Record<string, any>): void {\n    this.configuration = utilities.deepMerge(\n      this.configuration,\n      newConfiguration\n    );\n  }\n\n  /**\n   * Sets the active strategy for a tool. Strategies are\n   * multiple implementations of tool behavior that can be switched by tool\n   * configuration.\n   *\n   * @param strategyName - name of the strategy to be set as active\n   */\n  public setActiveStrategy(strategyName: string): void {\n    this.setConfiguration({ activeStrategy: strategyName });\n  }\n\n  /**\n   * Returns the volumeId for the volume viewport. It will grabbed the volumeId\n   * from the volumeId if particularly specified in the tool configuration, or if\n   * not, the first actorUID in the viewport is returned as the volumeId. NOTE: for\n   * segmentations, actorUID is not necessarily the volumeId since the segmentation\n   * can have multiple representations, use segmentation helpers to get the volumeId\n   * based on the actorUID.\n   *\n   * @param viewport - Volume viewport\n   * @returns the volumeId for the viewport if specified in the tool configuration,\n   * or the first actorUID in the viewport if not.\n   */\n  private getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n    if (this.configuration.volumeId) {\n      return this.configuration.volumeId;\n    }\n\n    // If volume not specified, then return the actorUID for the\n    // default actor - first actor\n    const actorEntries = viewport.getActors();\n\n    if (!actorEntries) {\n      return;\n    }\n\n    // find the first image actor of instance type vtkVolume\n    return actorEntries.find(\n      (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n    )?.uid;\n  }\n\n  /**\n   * Get the image that is displayed for the targetId in the cachedStats\n   * which can be either imageId:<imageId> or volumeId:<volumeId>\n   *\n   * @param targetId - annotation targetId stored in the cached stats\n   * @param renderingEngine - The rendering engine\n   * @returns The image data for the target.\n   */\n  protected getTargetIdImage(\n    targetId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): Types.IImageData | Types.CPUIImageData | Types.IImageVolume {\n    if (targetId.startsWith('imageId:')) {\n      const imageId = targetId.split('imageId:')[1];\n      const imageURI = utilities.imageIdToURI(imageId);\n      let viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      viewports = viewports.filter((viewport) => {\n        return viewport.getCurrentImageId() === imageId;\n      });\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('volumeId:')) {\n      const volumeId = targetId.split('volumeId:')[1];\n      const viewports = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else {\n      throw new Error(\n        'getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"'\n      );\n    }\n  }\n\n  /**\n   * Get the target Id for the viewport which will be used to store the cached\n   * statistics scoped to that target in the annotations.\n   * For StackViewport, targetId is the viewportId, but for the volume viewport,\n   * the targetId will be grabbed from the volumeId if particularly specified\n   * in the tool configuration, or if not, the first actorUID in the viewport.\n   *\n   * @param viewport - viewport to get the targetId for\n   * @returns targetId\n   */\n  protected getTargetId(viewport: Types.IViewport): string | undefined {\n    if (viewport instanceof StackViewport) {\n      return `imageId:${viewport.getCurrentImageId()}`;\n    } else if (viewport instanceof VolumeViewport) {\n      return `volumeId:${this.getTargetVolumeId(viewport)}`;\n    } else {\n      throw new Error(\n        'getTargetId: viewport must be a StackViewport or VolumeViewport'\n      );\n    }\n  }\n}\n\n// Note: this is a workaround since terser plugin does not support static blocks\n// yet and we can't easily say static toolName = \"BaseTool\" in the class definition.\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import { Enums, Types } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { ToolGroupSpecificContourRepresentation } from '../../../types';\n\n/**\n * If the segment specific config exists for the given segment id, it returns\n * the segment specific config. Otherwise, it looks for the segment specific\n * config for the given index. If it doesn't exist, it returns null.\n *\n * @param contourRepresentation -  The representation object that is passed\n * to the tool.\n * @param segmentId -  The id of the segment.\n * @param index -  The index of the segment in the list of segments.\n * @returns the segment specific config for the given segment id.\n *\n */\nexport function getSegmentSpecificConfig(\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  segmentId: string,\n  index: number\n) {\n  let segmentSpecificConfig =\n    contourRepresentation.segmentSpecificConfig?.[segmentId];\n\n  if (!segmentSpecificConfig) {\n    // try the index\n    segmentSpecificConfig =\n      contourRepresentation.segmentSpecificConfig?.[index];\n  }\n\n  if (!segmentSpecificConfig) {\n    return null;\n  }\n\n  return segmentSpecificConfig.CONTOUR;\n}\n\n/**\n * takes a geometry object as an argument\n * and throws an error if the geometry object is not a contour\n * @param geometry -  The geometry object to be rendered.\n */\nexport function validateGeometry(geometry: Types.IGeometry): void {\n  if (!geometry) {\n    throw new Error(`No contours found for geometryId ${geometry.id}`);\n  }\n\n  const geometryId = geometry.id;\n\n  if (geometry.type !== Enums.GeometryType.CONTOUR) {\n    throw new Error(\n      `Geometry type ${geometry.type} not supported for rendering.`\n    );\n  }\n\n  if (!geometry.data) {\n    console.warn(\n      `No contours found for geometryId ${geometryId}. Skipping render.`\n    );\n    return;\n  }\n}\n\n/**\n * It takes a contourSet and returns a vtkPolyData for that contourSet. A contour set\n * is a collection of contours. Each contour is a collection of points. Each point\n * is x,y,z in the world coordinate system.\n *\n * @param contourSet -  the contour set that you want to convert to polyData\n * @returns A vtkPolyData object\n */\nexport function getPolyData(contourSet: Types.IContourSet) {\n  const pointArray = [];\n\n  const points = vtkPoints.newInstance();\n  const lines = vtkCellArray.newInstance();\n\n  // this variable will indicate the index of the first point in the current line\n  // so we can correctly generate the point index list to add in the cellArray\n  let pointIndex = 0;\n  contourSet.getContours().forEach((contour: Types.IContour) => {\n    const pointList = contour.getPoints();\n    const flatPoints = contour.getFlatPointsArray();\n    const type = contour.getType();\n\n    // creating a point index list that defines a line\n    const pointIndexes = pointList.map(\n      (_, pointListIndex) => pointListIndex + pointIndex\n    );\n\n    // if close planar, add the first point index to the list\n    if (type === Enums.ContourType.CLOSED_PLANAR) {\n      pointIndexes.push(pointIndexes[0]);\n    }\n\n    const linePoints = Float32Array.from(flatPoints);\n    // add the current points into the point list\n    pointArray.push(...linePoints);\n    // add the point indexes into the cell array\n    lines.insertNextCell([...pointIndexes]);\n    // update the first point index\n    pointIndex = pointIndex + pointList.length;\n  });\n\n  // converts the pointArray into vtkPoints\n  points.setData(pointArray, 3);\n\n  // creates the polyData\n  const polygon = vtkPolyData.newInstance();\n  polygon.setPoints(points);\n  polygon.setLines(lines);\n\n  return polygon;\n}\n","type ConfigCache = {\n  segmentsHidden: Set<number>;\n  outlineWidthActive: number;\n  visibility: boolean;\n};\n\n/**\n * Config cache is used to store the config for a given segmentation\n * representation. This is used to avoid having to recompute the config\n * every time the user changes the active segment, and also for performance\n * reasons.\n */\nconst configCachePerSegmentationRepresentationUID = new Map();\n\nexport function getConfigCache(\n  segmentationRepresentationUID: string\n): ConfigCache {\n  return configCachePerSegmentationRepresentationUID.get(\n    segmentationRepresentationUID\n  );\n}\n\nexport function setConfigCache(\n  segmentationRepresentationUID: string,\n  config: ConfigCache\n) {\n  configCachePerSegmentationRepresentationUID.set(\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport function deleteConfigCache(segmentationRepresentationUID: string) {\n  configCachePerSegmentationRepresentationUID.delete(\n    segmentationRepresentationUID\n  );\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkAppendPolyData from '@kitware/vtk.js/Filters/General/AppendPolyData';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\n\nimport {\n  getPolyData,\n  getSegmentSpecificConfig,\n  validateGeometry,\n} from './utils';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\n\nexport function addContourSetsToElement(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const appendPolyData = vtkAppendPolyData.newInstance();\n\n  const scalarToColorMap = new Map();\n  const segmentSpecificMap = new Map();\n\n  geometryIds.forEach((geometryId) => {\n    const geometry = cache.getGeometry(geometryId);\n\n    if (!geometry) {\n      console.warn(\n        `No geometry found for geometryId ${geometryId}. Skipping render.`\n      );\n      return;\n    }\n\n    const segmentIndex = (geometry.data as Types.IContourSet).getSegmentIndex();\n\n    validateGeometry(geometry);\n\n    const segmentSpecificConfig = getSegmentSpecificConfig(\n      contourRepresentation,\n      geometryId,\n      segmentIndex\n    );\n\n    const contourSet = geometry.data;\n    const polyData = getPolyData(contourSet);\n    const color = contourSet.getColor();\n\n    const size = polyData.getPoints().getNumberOfPoints();\n\n    const scalars = vtkDataArray.newInstance({\n      size: size * 4,\n      numberOfComponents: 4,\n      dataType: 'Uint8Array',\n    });\n    for (let i = 0; i < size; ++i) {\n      scalars.setTuple(i, [...color, 255]);\n    }\n    polyData.getPointData().setScalars(scalars);\n\n    if (segmentSpecificConfig) {\n      segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n    }\n\n    scalarToColorMap.set(segmentIndex, [\n      ...color,\n      segmentsHidden.has(segmentIndex) ? 0 : 255,\n    ]);\n\n    segmentIndex === 0\n      ? appendPolyData.setInputData(polyData)\n      : appendPolyData.addInputData(polyData);\n  });\n\n  const polyDataOutput = appendPolyData.getOutputData();\n\n  const outlineWidthActive =\n    contourRepresentationConfig.representations.CONTOUR.outlineWidthActive;\n\n  const mapper = vtkMapper.newInstance();\n  mapper.setInputData(polyDataOutput);\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n  actor.getProperty().setLineWidth(outlineWidthActive);\n\n  // set the config cache for later update of the contour\n  setConfigCache(\n    segmentationRepresentationUID,\n    Object.assign({}, getConfigCache(segmentationRepresentationUID), {\n      segmentsHidden: new Set(segmentsHidden),\n      segmentSpecificMap,\n      outlineWidthActive,\n    })\n  );\n\n  actor.setForceOpaque(true);\n\n  viewport.addActor({ uid: contourActorUID, actor });\n  viewport.resetCamera();\n  viewport.render();\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkAppendPolyData from '@kitware/vtk.js/Filters/General/AppendPolyData';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\nimport { getPolyData } from './utils';\n\nexport function updateContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const newContourConfig = contourRepresentationConfig.representations.CONTOUR;\n  const cachedConfig = getConfigCache(segmentationRepresentationUID);\n\n  const contourSetsActor = viewport.getActor(contourActorUID);\n\n  if (!contourSetsActor) {\n    console.warn(\n      `No contour actor found for actorUID ${contourActorUID}. Skipping render.`\n    );\n    return;\n  }\n\n  const { actor } = contourSetsActor;\n\n  const newOutlineWithActive = newContourConfig.outlineWidthActive;\n\n  if (cachedConfig?.outlineWidthActive !== newOutlineWithActive) {\n    (actor as vtkActor).getProperty().setLineWidth(newOutlineWithActive);\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        outlineWidthActive: newOutlineWithActive,\n      })\n    );\n  }\n\n  const mapper = (actor as vtkActor).getMapper();\n  const lut = mapper.getLookupTable();\n\n  const segmentsToSetToInvisible = [];\n  const segmentsToSetToVisible = [];\n\n  for (const segmentIndex of segmentsHidden) {\n    if (!cachedConfig?.segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToInvisible.push(segmentIndex);\n    }\n  }\n\n  // the other way around\n  for (const segmentIndex of cachedConfig.segmentsHidden) {\n    if (!segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToVisible.push(segmentIndex);\n    }\n  }\n  if (segmentsToSetToInvisible.length || segmentsToSetToVisible.length) {\n    const appendPolyData = vtkAppendPolyData.newInstance();\n\n    geometryIds.forEach((geometryId) => {\n      const geometry = cache.getGeometry(geometryId);\n      const { data: contourSet } = geometry;\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const color = contourSet.getColor();\n      const visibility = segmentsToSetToInvisible.includes(segmentIndex)\n        ? 0\n        : 255;\n      const polyData = getPolyData(contourSet);\n\n      const size = polyData.getPoints().getNumberOfPoints();\n\n      const scalars = vtkDataArray.newInstance({\n        size: size * 4,\n        numberOfComponents: 4,\n        dataType: 'Uint8Array',\n      });\n      for (let i = 0; i < size; ++i) {\n        scalars.setTuple(i, [...color, visibility]);\n      }\n      polyData.getPointData().setScalars(scalars);\n\n      segmentIndex === 0\n        ? appendPolyData.setInputData(polyData)\n        : appendPolyData.addInputData(polyData);\n    });\n\n    const polyDataOutput = appendPolyData.getOutputData();\n    mapper.setInputData(polyDataOutput);\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        segmentsHidden: new Set(segmentsHidden),\n      })\n    );\n\n    mapper.setLookupTable(lut);\n  }\n\n  viewport.render();\n}\n","import { Types } from '@cornerstonejs/core';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { addContourSetsToElement } from './addContourSetsToElement';\nimport { updateContourSets } from './updateContourSets';\n\nexport function addOrUpdateContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig\n) {\n  const { segmentationRepresentationUID } = contourRepresentation;\n  const actorUID = `CONTOUR_${segmentationRepresentationUID}`;\n  const actor = viewport.getActor(actorUID);\n\n  const addOrUpdateFn = actor ? updateContourSets : addContourSetsToElement;\n  addOrUpdateFn(\n    viewport,\n    geometryIds,\n    contourRepresentation,\n    contourRepresentationConfig,\n    actorUID\n  );\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the contour representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the contour representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.startsWith(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n}\n\nexport default removeContourFromElement;\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationConfig from '../../../stateManagement/segmentation/config/segmentationConfig';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport {\n  RepresentationPublicInput,\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\nimport { addOrUpdateContourSets } from './addOrUpdateContourSets';\nimport removeContourFromElement from './removeContourFromElement';\n\n/**\n * It adds a new segmentation representation to the segmentation state\n * @param toolGroupId - The id of the toolGroup that the segmentation\n * belongs to\n * @param representationInput - RepresentationPublicInput\n * @param toolGroupSpecificConfig - The configuration that is specific to the toolGroup.\n * @returns The segmentationRepresentationUID\n */\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId } = representationInput;\n  const segmentationRepresentationUID = csUtils.uuidv4();\n  // Todo: make these configurable during representation input by user\n  const segmentsHidden = new Set() as Set<number>;\n  const visibility = true;\n  const colorLUTIndex = 0;\n  const active = true;\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: Representations.Contour,\n    segmentsHidden,\n    colorLUTIndex,\n    active,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: {},\n  };\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const mergedConfig = csUtils.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n  SegmentationState.addSegmentationRepresentation(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n  return segmentationRepresentationUID;\n}\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeContourFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the contour sets for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representationConfig: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const { segmentationId } = representationConfig;\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const contourData = segmentation.representationData[Representations.Contour];\n  const { geometryIds } = contourData;\n\n  if (!geometryIds?.length) {\n    console.warn(\n      `No contours found for segmentationId ${segmentationId}. Skipping render.`\n    );\n  }\n\n  // add the contour sets to the viewport\n  addOrUpdateContourSets(\n    viewport,\n    geometryIds,\n    representationConfig,\n    toolGroupConfig\n  );\n}\n\nfunction _removeContourFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeContourFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n};\n","import {\n  getEnabledElement,\n  addVolumesToViewports,\n  Types,\n  Enums,\n} from '@cornerstonejs/core';\n\n/**\n * It adds a labelmap segmentation representation of the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that will be rendered.\n * @param volumeId - The volume id of the labelmap.\n * @param segmentationRepresentationUID - The segmentation representation UID.\n *\n * @internal\n */\nasync function addLabelmapToElement(\n  element: HTMLDivElement,\n  volumeId: string,\n  segmentationRepresentationUID: string\n): Promise<void> {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n  const { id: viewportId } = viewport;\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const visibility = true;\n  const immediateRender = false;\n  const suppressEvents = true;\n\n  // Todo: Right now we use MIP blend mode for the labelmap, since the\n  // composite blend mode has a non linear behavior regarding fill and line\n  // opacity. This should be changed to a custom labelmap blendMode which does\n  // what composite does, but with a linear behavior.\n  const volumeInputs: Types.IVolumeInput[] = [\n    {\n      volumeId,\n      actorUID: segmentationRepresentationUID,\n      visibility,\n      blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n    },\n  ];\n\n  // Add labelmap volumes to the viewports to be be rendered, but not force the render\n  await addVolumesToViewports(\n    renderingEngine,\n    volumeInputs,\n    [viewportId],\n    immediateRender,\n    suppressEvents\n  );\n}\n\nexport default addLabelmapToElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the labelmap segmentation representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the labelmap representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeLabelmapFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  (viewport as Types.IVolumeViewport).removeVolumeActors([\n    segmentationRepresentationUID,\n  ]);\n}\n\nexport default removeLabelmapFromElement;\n","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\n\nimport {\n  cache,\n  getEnabledElementByIds,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationConfig from '../../../stateManagement/segmentation/config/segmentationConfig';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport type {\n  LabelmapConfig,\n  LabelmapRenderingConfig,\n} from '../../../types/LabelmapTypes';\nimport {\n  RepresentationPublicInput,\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport addLabelmapToElement from './addLabelmapToElement';\n\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\n\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\n\n/**\n * For each viewport, in the toolGroup it adds the segmentation labelmap\n * representation to its viewports.\n * @param toolGroup - the tool group that contains the viewports\n * @param representationInput - The segmentation representation input\n * @param toolGroupSpecificConfig - The configuration object for toolGroup\n *\n * @returns The UID of the new segmentation representation\n */\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId } = representationInput;\n  const segmentationRepresentationUID = utilities.uuidv4();\n\n  // Todo: make these configurable during representation input by user\n  const segmentsHidden = new Set() as Set<number>;\n  const colorLUTIndex = 0;\n  const active = true;\n  const cfun = vtkColorTransferFunction.newInstance();\n  const ofun = vtkPiecewiseFunction.newInstance();\n\n  ofun.addPoint(0, 0);\n\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: Representations.Labelmap,\n    segmentsHidden,\n    colorLUTIndex,\n    active,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: {\n      cfun,\n      ofun,\n    },\n  };\n\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const mergedConfig = utilities.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n\n  SegmentationState.addSegmentationRepresentation(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n\n  return segmentationRepresentationUID;\n}\n\n/**\n * For each viewport, and for each segmentation, set the segmentation for the viewport's enabled element\n * Initializes the global and viewport specific state for the segmentation in the\n * SegmentationStateManager.\n * @param toolGroup - the tool group that contains the viewports\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param renderImmediate - If true, there will be a render call after the labelmap is removed\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeLabelmapFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It takes the enabled element, the segmentation Id, and the configuration, and\n * it sets the segmentation for the enabled element as a labelmap\n * @param enabledElement - The cornerstone enabled element\n * @param segmentationId - The id of the segmentation to be rendered.\n * @param configuration - The configuration object for the labelmap.\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n    config: renderingConfig,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const labelmapData =\n    segmentation.representationData[Representations.Labelmap];\n  const { volumeId: labelmapUID } = labelmapData;\n\n  const labelmap = cache.getVolume(labelmapUID);\n\n  if (!labelmap) {\n    throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\n  }\n\n  let actorEntry = viewport.getActor(segmentationRepresentationUID);\n\n  if (!actorEntry) {\n    const segmentation = SegmentationState.getSegmentation(segmentationId);\n    const { volumeId } =\n      segmentation.representationData[Representations.Labelmap];\n    // only add the labelmap to ToolGroup viewports if it is not already added\n    await _addLabelmapToViewport(\n      viewport,\n      volumeId,\n      segmentationRepresentationUID\n    );\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  }\n\n  const { cfun, ofun } = renderingConfig as LabelmapRenderingConfig;\n\n  const renderInactiveSegmentations =\n    toolGroupConfig.renderInactiveSegmentations;\n\n  _setLabelmapColorAndOpacity(\n    viewport.id,\n    actorEntry,\n    cfun,\n    ofun,\n    colorLUTIndex,\n    toolGroupConfig.representations[Representations.Labelmap],\n    representation,\n    active,\n    renderInactiveSegmentations,\n    segmentsHidden\n  );\n}\n\nfunction _setLabelmapColorAndOpacity(\n  viewportId: string,\n  actorEntry: Types.ActorEntry,\n  cfun: vtkColorTransferFunction,\n  ofun: vtkPiecewiseFunction,\n  colorLUTIndex: number,\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  isActiveLabelmap: boolean,\n  renderInactiveSegmentations: boolean,\n  segmentsHidden: Set<number>\n): void {\n  const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } =\n    segmentationRepresentation;\n\n  const segmentationRepresentationLabelmapConfig =\n    segmentationRepresentationSpecificConfig[Representations.Labelmap];\n\n  // Note: MAX_NUMBER_COLORS = 256 is needed because the current method to generate\n  // the default color table uses RGB.\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  const numColors = Math.min(256, colorLUT.length);\n  const volumeActor = actorEntry.actor as Types.VolumeActor;\n  const { uid: actorUID } = actorEntry;\n\n  // Note: right now outlineWidth and renderOutline are not configurable\n  // at the segment level, so we don't need to check for segment specific\n  // configuration in the loop, Todo: make them configurable at the segment level\n  const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(\n    toolGroupLabelmapConfig,\n    segmentationRepresentationLabelmapConfig,\n    isActiveLabelmap\n  );\n\n  for (let i = 0; i < numColors; i++) {\n    const segmentIndex = i;\n    const segmentColor = colorLUT[segmentIndex];\n\n    const segmentSpecificLabelmapConfig =\n      segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\n\n    const { fillAlpha, outlineWidth, renderFill, renderOutline } =\n      _getLabelmapConfig(\n        toolGroupLabelmapConfig,\n        segmentationRepresentationLabelmapConfig,\n        isActiveLabelmap,\n        segmentSpecificLabelmapConfig\n      );\n\n    const { forceOpacityUpdate, forceColorUpdate } =\n      _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\n        fillAlpha,\n        renderFill,\n        renderOutline,\n        segmentColor,\n        outlineWidth,\n        segmentsHidden,\n      });\n\n    if (forceColorUpdate) {\n      cfun.addRGBPoint(\n        segmentIndex,\n        segmentColor[0] / MAX_NUMBER_COLORS,\n        segmentColor[1] / MAX_NUMBER_COLORS,\n        segmentColor[2] / MAX_NUMBER_COLORS\n      );\n    }\n\n    if (forceOpacityUpdate) {\n      if (renderFill) {\n        const segmentOpacity = segmentsHidden.has(segmentIndex)\n          ? 0\n          : (segmentColor[3] / 255) * fillAlpha;\n\n        ofun.removePoint(segmentIndex);\n        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n      } else {\n        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n      }\n    }\n  }\n\n  volumeActor.getProperty().setRGBTransferFunction(0, cfun);\n\n  ofun.setClamping(false);\n  volumeActor.getProperty().setScalarOpacity(0, ofun);\n\n  volumeActor.getProperty().setInterpolationTypeToNearest();\n\n  volumeActor.getProperty().setUseLabelOutline(renderOutline);\n\n  // @ts-ignore: setLabelOutlineWidth is not in the vtk.d.ts apparently\n  volumeActor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n  volumeActor.getProperty().setLabelOutlineThickness(outlineWidth);\n\n  // Set visibility based on whether actor visibility is specifically asked\n  // to be turned on/off (on by default) AND whether is is in active but\n  // we are rendering inactive labelmap\n  const visible = isActiveLabelmap || renderInactiveSegmentations;\n  volumeActor.setVisibility(visible);\n}\n\nfunction _getLabelmapConfig(\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentationLabelmapConfig: LabelmapConfig,\n  isActiveLabelmap: boolean,\n  segmentsLabelmapConfig?: LabelmapConfig\n) {\n  const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n\n  const configToUse = {\n    ...toolGroupLabelmapConfig,\n    ...segmentationRepresentationLabelmapConfig,\n    ...segmentLabelmapConfig,\n  };\n\n  const fillAlpha = isActiveLabelmap\n    ? configToUse.fillAlpha\n    : configToUse.fillAlphaInactive;\n  const outlineWidth = isActiveLabelmap\n    ? configToUse.outlineWidthActive\n    : configToUse.outlineWidthInactive;\n\n  const renderFill = isActiveLabelmap\n    ? configToUse.renderFill\n    : configToUse.renderFillInactive;\n\n  const renderOutline = configToUse.renderOutline;\n\n  const outlineOpacity = isActiveLabelmap\n    ? configToUse.outlineOpacity\n    : configToUse.outlineOpacityInactive;\n\n  return {\n    fillAlpha,\n    outlineWidth,\n    renderFill,\n    renderOutline,\n    outlineOpacity,\n  };\n}\n\nfunction _needsTransferFunctionUpdate(\n  viewportId: string,\n  actorUID: string,\n  segmentIndex: number,\n  {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    segmentColor,\n    outlineWidth,\n    segmentsHidden,\n  }: {\n    fillAlpha: number;\n    renderFill: boolean;\n    renderOutline: boolean;\n    outlineWidth: number;\n    segmentColor: number[];\n    segmentsHidden: Set<number>;\n  }\n) {\n  const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\n  const oldConfig = labelMapConfigCache.get(cacheUID);\n\n  if (!oldConfig) {\n    labelMapConfigCache.set(cacheUID, {\n      fillAlpha,\n      renderFill,\n      renderOutline,\n      outlineWidth,\n      segmentColor,\n      segmentsHidden: new Set(segmentsHidden), // Create a copy\n    });\n\n    return {\n      forceOpacityUpdate: true,\n      forceColorUpdate: true,\n    };\n  }\n\n  const {\n    fillAlpha: oldFillAlpha,\n    renderFill: oldRenderFill,\n    renderOutline: oldRenderOutline,\n    outlineWidth: oldOutlineWidth,\n    segmentColor: oldSegmentColor,\n    segmentsHidden: oldSegmentsHidden,\n  } = oldConfig;\n\n  const forceColorUpdate =\n    oldSegmentColor[0] !== segmentColor[0] ||\n    oldSegmentColor[1] !== segmentColor[1] ||\n    oldSegmentColor[2] !== segmentColor[2];\n\n  const forceOpacityUpdate =\n    oldSegmentColor[3] !== segmentColor[3] ||\n    oldFillAlpha !== fillAlpha ||\n    oldRenderFill !== renderFill ||\n    oldRenderOutline !== renderOutline ||\n    oldOutlineWidth !== outlineWidth ||\n    oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\n\n  // update the cache\n  labelMapConfigCache.set(cacheUID, {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    outlineWidth,\n    segmentColor: segmentColor.slice(), // Create a copy\n    segmentsHidden: new Set(segmentsHidden), // Create a copy\n  });\n\n  return {\n    forceOpacityUpdate,\n    forceColorUpdate,\n  };\n}\n\nfunction _removeLabelmapFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeLabelmapFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nasync function _addLabelmapToViewport(\n  viewport: Types.IVolumeViewport,\n  volumeId: string,\n  segmentationRepresentationUID: string\n): Promise<void> {\n  await addLabelmapToElement(\n    viewport.element,\n    volumeId,\n    segmentationRepresentationUID\n  );\n}\n\nexport default {\n  render,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n};\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { PublicToolProps, ToolProps } from '../../types';\nimport { BaseTool } from '../base';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\n\n/**\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\n * Generally, any Segmentation can be viewed in various representations such as\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\n * Labelmap representation.\n *\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\n * scenarios for displaying segmentations.\n *\n * Current Limitations:\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\n * - Labelmap representation is the only supported representation for now.\n *\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\n * viewports information such as viewportId and renderingEngineId should be provided\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\n *\n *\n */\nclass SegmentationDisplayTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility true\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          true\n        );\n      }\n    );\n  }\n\n  onSetToolDisabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility false\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          false\n        );\n      }\n    );\n  }\n\n  /**\n   * It is used to trigger the render for each segmentations in the toolGroup.\n   * Based on the segmentation representation type, it will call the corresponding\n   * render function.\n   *\n   * @param toolGroupId - the toolGroupId\n   */\n  renderSegmentation = (toolGroupId: string): void => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // toolGroup Viewports\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\n      ({ renderingEngineId, viewportId }) => {\n        const enabledElement = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n\n        if (enabledElement) {\n          return enabledElement.viewport;\n        }\n      }\n    );\n\n    // Render each segmentationData, in each viewport in the toolGroup\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\n      (representation: ToolGroupSpecificRepresentation) => {\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\n\n        const viewportsRenderList = [];\n        for (const viewport of toolGroupViewports) {\n          if (representation.type == Representations.Labelmap) {\n            viewportsRenderList.push(\n              labelmapDisplay.render(\n                viewport as Types.IVolumeViewport,\n                representation,\n                config\n              )\n            );\n          } else if (representation.type == Representations.Contour) {\n            viewportsRenderList.push(\n              contourDisplay.render(\n                viewport as Types.IVolumeViewport,\n                representation,\n                config\n              )\n            );\n          }\n        }\n\n        return viewportsRenderList;\n      }\n    );\n\n    Promise.allSettled(segmentationRenderList).then(() => {\n      // for all viewports in the toolGroup trigger a re-render\n      toolGroupViewports.forEach((viewport) => {\n        viewport.render();\n      });\n    });\n  };\n\n  /**\n   * Merge the toolGroup specific configuration with the default global configuration\n   * @param toolGroupId\n   * @returns\n   */\n  _getMergedRepresentationsConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig {\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    // merge two configurations and override the global config\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n\n    return mergedConfig;\n  }\n}\n\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n","import {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\nimport { Events as csToolsEvents } from '../../enums';\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../../store/ToolGroupManager';\n\nimport SegmentationDisplayTool from '../../tools/displayTools/SegmentationDisplayTool';\nimport { SegmentationRenderedEventDetail } from '../../types/EventTypes';\n\n/**\n * SegmentationRenderingEngine is a class that is responsible for rendering\n * segmentations for a toolGroup. It will call SegmentationDisplayTool to render the segmentation\n * based on the segmentation data and their configurations. Note: This is a Singleton class\n * and should not be instantiated directly. To trigger a render for all the\n * segmentations of a tool group you can use.\n *\n * ```\n * triggerSegmentationRender(toolGroupId)\n * ```\n */\nclass SegmentationRenderingEngine {\n  private _needsRender: Set<string> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  public hasBeenDestroyed: boolean;\n\n  public removeToolGroup(toolGroupId) {\n    this._needsRender.delete(toolGroupId);\n\n    if (this._needsRender.size === 0) {\n      this._reset();\n    }\n  }\n\n  public renderToolGroupSegmentations(toolGroupId): void {\n    this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\n  }\n\n  /**\n   *  _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _setToolGroupSegmentationToBeRenderedNextFrame(\n    toolGroupIds: string[]\n  ) {\n    // Add the viewports to the set of flagged viewports\n    toolGroupIds.forEach((toolGroupId) => {\n      this._needsRender.add(toolGroupId);\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   *  _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedToolGroups\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  private _renderFlaggedToolGroups = () => {\n    this._throwIfDestroyed();\n\n    // for each toolGroupId insides the _needsRender set, render the segmentation\n    const toolGroupIds = Array.from(this._needsRender.values());\n\n    for (const toolGroupId of toolGroupIds) {\n      this._triggerRender(toolGroupId);\n\n      // This viewport has been rendered, we can remove it from the set\n      this._needsRender.delete(toolGroupId);\n\n      // If there is nothing left that is flagged for rendering, stop here\n      // and allow RAF to be called again\n      if (this._needsRender.size === 0) {\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        return;\n      }\n    }\n  };\n  _triggerRender(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\n      return;\n    }\n\n    const { viewportsInfo } = toolGroup;\n    const viewports = [];\n\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n\n      if (!renderingEngine) {\n        console.warn('rendering Engine has been destroyed');\n        return;\n      }\n\n      viewports.push(renderingEngine.getViewport(viewportId));\n    });\n\n    const segmentationDisplayToolInstance = toolGroup.getToolInstance(\n      SegmentationDisplayTool.toolName\n    ) as SegmentationDisplayTool;\n    if (!segmentationDisplayToolInstance) {\n      console.warn('No segmentation tool found inside', toolGroupId);\n      return;\n    }\n\n    function onSegmentationRender(evt: Types.EventTypes.ImageRenderedEvent) {\n      const { element, viewportId, renderingEngineId } = evt.detail;\n\n      element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n\n      const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n      if (!toolGroup) {\n        console.warn('toolGroup has been destroyed');\n        return;\n      }\n\n      const eventDetail: SegmentationRenderedEventDetail = {\n        toolGroupId: toolGroup.id,\n        viewportId,\n      };\n\n      triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n        ...eventDetail,\n      });\n    }\n\n    // Todo: for other representations we probably need the drawSVG, but right now we are not using it\n    // drawSvg(element, (svgDrawingHelper) => {\n    //   const handleDrawSvg = (tool) => {\n    //     if (tool instanceof SegmentationDisplayTool && tool.renderAnnotation) {\n    //       tool.renderAnnotation({ detail: eventDetail })\n    //       triggerEvent(element, csToolsEvents.SEGMENTATION_RENDERED, { ...eventDetail })\n    //     }\n    //   }\n    //   enabledTools.forEach(handleDrawSvg)\n    // })\n\n    viewports.forEach(({ element }) => {\n      element.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender\n      );\n    });\n\n    segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\n  }\n\n  /**\n   *  _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n  }\n}\n\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\n\n/**\n * It triggers a render for all the segmentations of the tool group with the given Id.\n * @param toolGroupId - The Id of the tool group to render.\n */\nfunction triggerSegmentationRender(toolGroupId: string): void {\n  segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\n}\n\nexport { segmentationRenderingEngine, triggerSegmentationRender };\nexport default triggerSegmentationRender;\n","import { cache } from '@cornerstonejs/core';\n\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../types/EventTypes';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId, modifiedSlicesToUse } = evt.detail;\n\n  const { representationData, type } =\n    SegmentationState.getSegmentation(segmentationId);\n\n  let toolGroupIds;\n  if (type === SegmentationRepresentations.Labelmap) {\n    // get the volume from cache, we need the openGLTexture to be updated to GPU\n    const segmentationVolume = cache.getVolume(\n      representationData[type].volumeId\n    );\n\n    if (!segmentationVolume) {\n      console.warn('segmentation not found in cache');\n      return;\n    }\n\n    const { imageData, vtkOpenGLTexture } = segmentationVolume;\n\n    // Update the texture for the volume in the GPU\n    let slicesToUpdate;\n    if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\n      slicesToUpdate = modifiedSlicesToUse;\n    } else {\n      const numSlices = imageData.getDimensions()[2];\n      slicesToUpdate = [...Array(numSlices).keys()];\n    }\n\n    slicesToUpdate.forEach((i) => {\n      vtkOpenGLTexture.setUpdatedFrame(i);\n    });\n\n    // Trigger modified on the imageData to update the image\n    imageData.modified();\n    toolGroupIds =\n      SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n  } else {\n    throw new Error(\n      `onSegmentationDataModified: representationType ${type} not supported yet`\n    );\n  }\n\n  toolGroupIds.forEach((toolGroupId) => {\n    triggerSegmentationRender(toolGroupId);\n  });\n};\n\nexport default onSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationModifiedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationStateModified` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationModifiedListener = function (\n  evt: SegmentationRepresentationModifiedEventType\n): void {\n  const { toolGroupId } = evt.detail;\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationModifiedListener;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationRemovedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationRepresentationRemoved` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationRemovedEventListener = function (\n  evt: SegmentationRepresentationRemovedEventType\n): void {\n  const { toolGroupId, segmentationRepresentationUID } = evt.detail;\n\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationRemovedEventListener;\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\n\nimport {\n  getSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n} from './segmentationState';\n\n/**\n * Remove the segmentation representation (representation) from the viewports of the toolGroup.\n * @param toolGroupId - The Id of the toolGroup to remove the segmentation from.\n * @param segmentationRepresentationUIDs - The UIDs of the segmentation representations to remove.\n * @param immediate - if True the viewport will be re-rendered immediately.\n */\nfunction removeSegmentationsFromToolGroup(\n  toolGroupId: string,\n  segmentationRepresentationUIDs?: string[] | undefined,\n  immediate?: boolean\n): void {\n  const toolGroupSegRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (\n    !toolGroupSegRepresentations ||\n    toolGroupSegRepresentations.length === 0\n  ) {\n    return;\n  }\n\n  const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map(\n    (representation) => representation.segmentationRepresentationUID\n  );\n\n  let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\n  if (segRepresentationUIDsToRemove) {\n    // make sure the segmentationDataUIDs that are going to be removed belong\n    // to the toolGroup\n    const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter(\n      (segRepresentationUID) =>\n        !toolGroupSegRepresentationUIDs.includes(segRepresentationUID)\n    );\n\n    if (invalidSegRepresentationUIDs.length > 0) {\n      throw new Error(\n        `The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(\n          invalidSegRepresentationUIDs\n        )}`\n      );\n    }\n  } else {\n    // remove all segmentation representations\n    segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\n  }\n\n  segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\n    _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\n  });\n}\n\nfunction _removeSegmentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  immediate?: boolean\n): void {\n  const segmentationRepresentation = getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  const { type } = segmentationRepresentation;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    labelmapDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else if (type === SegmentationRepresentations.Contour) {\n    console.debug('Contour representation is not supported yet, ignoring...');\n  } else {\n    throw new Error(`The representation ${type} is not supported yet`);\n  }\n}\n\nexport default removeSegmentationsFromToolGroup;\n","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it\n\n/**\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\n * associated with that tool group too\n *\n * @param toolGroupId - The Id of the tool group to be destroyed.\n */\nfunction destroyToolGroup(toolGroupId: string): void {\n  const toolGroupIndex = state.toolGroups.findIndex(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupIndex > -1) {\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\n    // Todo: this should not happen here)\n    removeSegmentationsFromToolGroup(toolGroupId);\n    state.toolGroups.splice(toolGroupIndex, 1);\n  }\n}\n\nexport default destroyToolGroup;\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\nimport { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\n\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it. Calling\n// destroyToolGroup() to make sure the SegmentationDisplayTools\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\n// to be based on events, but we don't have any toolGroup created/removed events\n\n/**\n * Destroy all tool groups\n */\nfunction destroy(): void {\n  const toolGroups = [...csToolsState.toolGroups];\n\n  for (const toolGroup of toolGroups) {\n    destroyToolGroup(toolGroup.id);\n  }\n\n  csToolsState.toolGroups = [];\n}\n\nexport default destroy;\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport {\n  annotationSelectionListener,\n  segmentationDataModifiedEventListener,\n  segmentationRepresentationModifiedEventListener,\n  segmentationRepresentationRemovedEventListener,\n  segmentationModifiedListener,\n  annotationModifiedListener,\n} from './eventListeners';\n\nimport * as ToolGroupManager from './store/ToolGroupManager';\n\nlet csToolsInitialized = false;\n\n/**\n * Initialize the cornerstoneTools package. It will add event listeners for mouse\n * and keyboard events.\n * @param defaultConfiguration - A configuration object that will be used to\n * initialize the tool.\n */\nexport function init(defaultConfiguration = {}): void {\n  if (csToolsInitialized) {\n    return;\n  }\n\n  _addCornerstoneEventListeners();\n  _addCornerstoneToolsEventListeners();\n\n  csToolsInitialized = true;\n}\n\n/**\n * It destroys and cleanup state for cornerstone3DTools. It removes all the tools\n * that were added to the tool groups and restore states. It also removes all\n * event listeners.\n */\nexport function destroy(): void {\n  _removeCornerstoneEventListeners();\n  _removeCornerstoneToolsEventListeners();\n\n  // Important: destroy ToolGroups first, in order for cleanup to work correctly for the\n  // added tools.\n  ToolGroupManager.destroy();\n\n  // Remove all tools\n  resetCornerstoneToolsState();\n\n  // remove all annotation.\n  const annotationManager = getAnnotationManager();\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  annotationManager.restoreAnnotations({});\n  segmentationStateManager.resetState();\n  csToolsInitialized = false;\n}\n\n/**\n * Wires up event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n * @internal\n */\nfunction _addCornerstoneEventListeners(): void {\n  // Clear any listeners that may already be set\n  _removeCornerstoneEventListeners();\n\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n}\n\n/**\n * Removes event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n */\nfunction _removeCornerstoneEventListeners(): void {\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n}\n\n/**\n * It adds an event listener to the event target (the cornerstoneTools object) for\n * the annotation selected and annotation modified events.\n */\nfunction _addCornerstoneToolsEventListeners() {\n  // Clear any listeners that may already be set\n  _removeCornerstoneToolsEventListeners();\n\n  /**\n   * Annotation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\n/**\n * Remove the event listener for the the annotation selected and annotation modified events.\n */\nfunction _removeCornerstoneToolsEventListeners() {\n  /**\n   * Annotation\n   */\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\nexport default init;\n","import { state } from './state';\n\n/**\n * Adds the tool class to the cornerstoneTools to be used later. This function\n * should be called before creating the toolGroups and adding tools and setting their mode.\n * The flow is:\n * - addTool(ToolClass) // where ToolClass is the tool constructor imported from CornerstoneTools or created by a 3rd party\n * - createToolGroup(toolGroupId)\n * - toolGroup.addTool(${toolName}) // NOT THE TOOL CLASS\n * - toolGroup.setToolActive(${toolName})\n *\n * @param ToolClass - A tool calls to instantiate.\n * @param toolOptions - The tool-specific configuration options for the tool.\n * @returns\n */\nexport function addTool(ToolClass): void {\n  // Check if tool exists and name is not undefined\n  const toolName = ToolClass.toolName;\n  const toolAlreadyAdded = state.tools[toolName] !== undefined;\n\n  if (!toolName) {\n    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n  }\n\n  if (toolAlreadyAdded) {\n    throw new Error(`${toolName} has already been added globally`);\n  }\n\n  // Stores the toolNames and ToolClass to be instantiated in the toolGroup on toolGroup.addTool\n  state.tools[toolName] = {\n    toolClass: ToolClass,\n  };\n}\n\n/**\n * Removes the tool class from the cornerstoneTools.\n *\n * @param ToolClass - A tool calls to instantiate.\n */\nexport function removeTool(ToolClass): void {\n  const toolName = ToolClass.toolName;\n\n  if (!toolName) {\n    throw new Error(`No tool found for: ${ToolClass.name}`);\n  }\n\n  if (!state.tools[toolName] !== undefined) {\n    delete state.tools[toolName];\n  } else {\n    throw new Error(\n      `${toolName} cannot be removed because it has not been added`\n    );\n  }\n}\n\nexport default addTool;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\n\n/**\n * Cancel the current active manipulation that is being performed on the provided\n * element. It filters all the active and passive tools for the enabledElement\n * and calls cancel() method for all of them, and returns the tool that has executed its\n * cancellation (returned its annotationUID), since tools that are not being manipulated will\n * short circuit early. Note: not all tools currently implement a cancel method.\n *\n * @param element - canvas element\n * @returns annotationUID that is cancelled\n */\nexport default function cancelActiveManipulations(\n  element: HTMLDivElement\n): string | undefined {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  for (const { tool } of toolsWithData) {\n    const annotationUID = tool.cancel(element);\n    if (annotationUID) {\n      return annotationUID;\n    }\n  }\n}\n","import {\n  getRenderingEngine,\n  getEnabledElement,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\n\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Synchronizer is a class that listens to a specific event on a specific source\n * targets and fires a specific event on a specific target elements. Use cases\n * include: synchronizing a camera between two viewports, synchronizing a\n * windowLevel between various viewports.\n */\nclass Synchronizer {\n  //\n  private _enabled: boolean;\n  private _eventName: string;\n  private _eventHandler: ISynchronizerEventHandler;\n  private _ignoreFiredEvents: boolean;\n  private _sourceViewports: Array<Types.IViewportId>;\n  private _targetViewports: Array<Types.IViewportId>;\n  private _viewportOptions: Record<string, Record<string, unknown>> = {};\n  public id: string;\n\n  constructor(\n    synchronizerId: string,\n    eventName: string,\n    eventHandler: ISynchronizerEventHandler\n  ) {\n    this._enabled = true;\n    this._eventName = eventName;\n    this._eventHandler = eventHandler;\n    this._ignoreFiredEvents = false;\n    this._sourceViewports = [];\n    this._targetViewports = [];\n\n    //\n    this.id = synchronizerId;\n  }\n\n  /**\n   * \"Returns true if the synchronizer is disabled.\"\n   * @returns A boolean value.\n   */\n  public isDisabled(): boolean {\n    return !this._enabled || !this._hasSourceElements();\n  }\n\n  /**\n   * Sets the options for the viewport id.  This can be used to\n   * provide configuration on a viewport basis for things like offsets\n   * to the general synchronization, or turn on/off synchronization of certain\n   * attributes.\n   */\n  public setOptions(\n    viewportId: string,\n    options: Record<string, unknown> = {}\n  ): void {\n    this._viewportOptions[viewportId] = options;\n  }\n\n  /** Gets the options for the given viewport id */\n  public getOptions(viewportId: string): Record<string, unknown> | undefined {\n    return this._viewportOptions[viewportId];\n  }\n\n  /**\n   * Add a viewport to the list of targets and sources both.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public add(viewportInfo: Types.IViewportId): void {\n    this.addTarget(viewportInfo);\n    this.addSource(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of sources (source ONLY)\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addSource(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._sourceViewports, viewportInfo)) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = viewportInfo;\n\n    const { element } =\n      getRenderingEngine(renderingEngineId).getViewport(viewportId);\n\n    // @ts-ignore\n    element.addEventListener(this._eventName, this._onEvent.bind(this));\n    this._updateDisableHandlers();\n\n    this._sourceViewports.push(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of viewports that will get the eventHandler\n   * executed when the event is fired on the source viewport.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addTarget(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._targetViewports, viewportInfo)) {\n      return;\n    }\n\n    this._targetViewports.push(viewportInfo);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Get the list of source viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getSourceViewports(): Array<Types.IViewportId> {\n    return this._sourceViewports;\n  }\n\n  /**\n   * Get the list of target viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getTargetViewports(): Array<Types.IViewportId> {\n    return this._targetViewports;\n  }\n\n  public destroy(): void {\n    this._sourceViewports.forEach((s) => this.removeSource(s));\n    this._targetViewports.forEach((t) => this.removeTarget(t));\n  }\n\n  /**\n   * Remove the viewport from the list of targets and sources\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public remove(viewportInfo: Types.IViewportId): void {\n    this.removeTarget(viewportInfo);\n    this.removeSource(viewportInfo);\n  }\n\n  /**\n   * Remove the viewport from the list of source viewports\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public removeSource(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    const element = _getViewportElement(viewportInfo);\n\n    this._sourceViewports.splice(index, 1);\n    // @ts-ignore\n    element.removeEventListener(this._eventName, this._eventHandler);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Remove the viewport from the list of viewports that are currently targeted by\n   * this handler\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   *\n   */\n  public removeTarget(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._targetViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._targetViewports.splice(index, 1);\n    this._updateDisableHandlers();\n  }\n\n  public hasSourceViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._sourceViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  public hasTargetViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._targetViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  private fireEvent(sourceViewport: Types.IViewportId, sourceEvent: any): void {\n    if (this.isDisabled() || this._ignoreFiredEvents) {\n      return;\n    }\n\n    this._ignoreFiredEvents = true;\n    try {\n      for (let i = 0; i < this._targetViewports.length; i++) {\n        const targetViewport = this._targetViewports[i];\n        const targetIsSource =\n          sourceViewport.viewportId === targetViewport.viewportId;\n\n        if (targetIsSource) {\n          continue;\n        }\n\n        this._eventHandler(this, sourceViewport, targetViewport, sourceEvent);\n      }\n    } catch (ex) {\n      console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n    } finally {\n      this._ignoreFiredEvents = false;\n    }\n  }\n\n  private _onEvent = (evt: any): void => {\n    if (this._ignoreFiredEvents === true) {\n      return;\n    }\n\n    // If no target viewports, then return immediately, this is useful\n    // when switching between layouts, when previous layout has disabled\n    // its viewports, and the new layout has not yet enabled them.\n    // Right now we don't \"delete\" the synchronizer if all source and targets\n    // are removed, but we may want to do that in the future.\n    if (!this._targetViewports.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(evt.currentTarget);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = enabledElement;\n\n    // If the viewport has been removed from the synchronizer before the event is\n    // fired, then return immediately.\n    if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n      return;\n    }\n\n    this.fireEvent(\n      {\n        renderingEngineId,\n        viewportId,\n      },\n      evt\n    );\n  };\n\n  private _hasSourceElements(): boolean {\n    return this._sourceViewports.length !== 0;\n  }\n\n  private _updateDisableHandlers(): void {\n    const viewports = _getUniqueViewports(\n      this._sourceViewports,\n      this._targetViewports\n    );\n    const _remove = this.remove;\n    const disableHandler = (elementDisabledEvent) => {\n      _remove(elementDisabledEvent.detail.element);\n    };\n\n    viewports.forEach(function (vUid) {\n      const renderingEngine = getRenderingEngine(\n        vUid.renderingEngineId\n      ).getViewport(vUid.viewportId);\n\n      if (!renderingEngine) {\n        return;\n      }\n\n      const { element } = renderingEngine;\n\n      element.removeEventListener(\n        Enums.Events.ELEMENT_DISABLED,\n        disableHandler\n      );\n      element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n    });\n  }\n}\n\nfunction _getUniqueViewports(\n  vp1: Array<Types.IViewportId>,\n  vp2: Array<Types.IViewportId>\n): Array<Types.IViewportId> {\n  const unique = [];\n\n  const vps = vp1.concat(vp2);\n\n  for (let i = 0; i < vps.length; i++) {\n    const vp = vps[i];\n    if (\n      !unique.some(\n        (u) =>\n          vp.renderingEngineId === u.renderingEngineId &&\n          vp.viewportId === u.viewportId\n      )\n    ) {\n      unique.push(vp);\n    }\n  }\n\n  return unique;\n}\n\nfunction _getViewportIndex(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n): number {\n  return arr.findIndex(\n    (ar) =>\n      vp.renderingEngineId === ar.renderingEngineId &&\n      vp.viewportId === ar.viewportId\n  );\n}\n\nfunction _containsViewport(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n) {\n  return arr.some(\n    (ar) =>\n      ar.renderingEngineId === vp.renderingEngineId &&\n      ar.viewportId === vp.viewportId\n  );\n}\n\nfunction _getViewportElement(vp: Types.IViewportId): HTMLDivElement {\n  const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\n  }\n\n  return renderingEngine.getViewport(vp.viewportId).element;\n}\n\nexport default Synchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Create a new synchronizer instance from Synchronizer class\n * @param synchronizerId - The id of the synchronizer.\n * @param eventName - The name of the event that will be emitted by the\n * synchronizer.\n * @param eventHandler - The event handler that will be\n * called when the event is emitted.\n * @returns A reference to the synchronizer.\n */\nfunction createSynchronizer(\n  synchronizerId: string,\n  eventName: string,\n  eventHandler: ISynchronizerEventHandler\n): Synchronizer {\n  const synchronizerWithSameIdExists = state.synchronizers.some(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerWithSameIdExists) {\n    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n  }\n\n  // Create\n  const synchronizer = new Synchronizer(\n    synchronizerId,\n    eventName,\n    eventHandler\n  );\n\n  // Update state\n  state.synchronizers.push(synchronizer);\n\n  // Return reference\n  return synchronizer;\n}\n\nexport default createSynchronizer;\n","import { state } from '../index';\n\n/**\n * \"Destroy all synchronizers.\"\n */\nfunction destroy(): void {\n  while (state.synchronizers.length > 0) {\n    const synchronizer = state.synchronizers.pop();\n\n    synchronizer.destroy();\n  }\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Get the synchronizer with the given id from the state.\n * @param synchronizerId - The id of the synchronizer to be retrieved.\n * @returns A synchronizer object.\n */\nfunction getSynchronizer(synchronizerId: string): Synchronizer | void {\n  return state.synchronizers.find((s) => s.id === synchronizerId);\n}\n\nexport default getSynchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Return the array of synchronizers\n * @returns An array of synchronizers.\n */\nfunction getAllSynchronizers(): Array<Synchronizer> {\n  return state.synchronizers;\n}\n\nexport default getAllSynchronizers;\n","import { state } from '../index';\n\n// Synchronizers are a bit more tenacious. We need to make sure we remove\n// any attached events\n// We should probably just have a destroySynchronizer call\n// then use getByX to allow versatility in how we can call destroy\n\n/**\n * Destroy a synchronizer by its ID.\n * @param synchronizerId - The id of the synchronizer to destroy.\n */\nfunction destroySynchronizer(synchronizerId: string): void {\n  const synchronizerIndex = state.synchronizers.findIndex(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerIndex > -1) {\n    const synchronizer = state.synchronizers[synchronizerIndex];\n\n    synchronizer.destroy();\n    state.synchronizers.splice(synchronizerIndex, 1);\n  }\n}\n\nexport default destroySynchronizer;\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n  'alias',\n  'all-scroll',\n  'auto',\n  'cell',\n  'col-resize',\n  'context-menu',\n  'copy',\n  'crosshair',\n  'default',\n  'e-resize',\n  'ew-resize',\n  'grab',\n  'grabbing',\n  'help',\n  'move',\n  'ne-resize',\n  'nesw-resize',\n  'no-drop',\n  'none',\n  'not-allowed',\n  'n-resize',\n  'ns-resize',\n  'nw-resize',\n  'nwse-resize',\n  'pointer',\n  'progress',\n  'row-resize',\n  'se-resize',\n  's-resize',\n  'sw-resize',\n  'text',\n  'vertical-text',\n  'wait',\n  'w-resize',\n  'zoom-in',\n  'zoom-out',\n]);\n\nexport default class MouseCursor {\n  private name: string;\n  private fallback: MouseCursor | undefined;\n\n  constructor(name: string, fallback?: MouseCursor | undefined) {\n    this.name = name + '';\n    this.fallback = fallback;\n  }\n\n  getName(): string {\n    return this.name + '';\n  }\n\n  addFallbackStyleProperty(style: string): string {\n    const { fallback } = this;\n    if (fallback instanceof MouseCursor) {\n      return `${style}, ${fallback.getStyleProperty()}`;\n    }\n    return style + '';\n  }\n\n  getStyleProperty(): string {\n    return this.addFallbackStyleProperty(this.name) + '';\n  }\n\n  static getDefinedCursor(name: string): MouseCursor | undefined {\n    const definedCursors = getDefinedCursors(\n      // @ts-ignore\n      MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n      DEFINED_CURSORS\n    );\n    let mouseCursor = definedCursors.get(name);\n    if (mouseCursor instanceof MouseCursor) {\n      return mouseCursor;\n    }\n    if (STANDARD_CURSORS.has(name)) {\n      mouseCursor = new MouseCursor(name);\n      definedCursors.set(name, mouseCursor);\n      return mouseCursor;\n    }\n  }\n\n  static setDefinedCursor(name: string, cursor: MouseCursor): boolean {\n    if (cursor instanceof MouseCursor) {\n      const definedCursors = getDefinedCursors(\n        // @ts-ignore\n        MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n        DEFINED_CURSORS\n      );\n      definedCursors.set(name, cursor);\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction getDefinedCursors(\n  context: Record<symbol, Map<string, MouseCursor>>,\n  symbol: symbol\n): Map<string, MouseCursor> {\n  let definedCursors = context[symbol];\n  if (!(definedCursors instanceof Map)) {\n    definedCursors = new Map();\n    Object.defineProperty(context, symbol, { value: definedCursors });\n  }\n  return definedCursors;\n}\n\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","/**\n * AnnotationStyleStates - This enum defines the 4 possible states available for\n *  a Annotation instance.\n *\n * Default:\n *   The default state for the annotation instance\n * Highlighted:\n *   The annotation should be rendered in \"highlighted\" mode in response to\n *   direct user interaction;\n * Selected:\n *   The annotation has been selected by the user;\n * Locked:\n *   The annotation has been locked;\n */\nenum AnnotationStyleStates {\n  Default = '',\n  Highlighted = 'Highlighted',\n  Selected = 'Selected',\n  Locked = 'Locked',\n}\n\nexport default AnnotationStyleStates;\n","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\n\nconst DEFAULT_NAME = 'image-cursor';\n\nexport default class ImageMouseCursor extends MouseCursor {\n  private url: string;\n  private x: number;\n  private y: number;\n\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(\n      name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME),\n      fallback\n    );\n    this.url = url;\n    this.x = Number(x) || 0;\n    this.y = Number(y) || 0;\n  }\n\n  getStyleProperty(): string {\n    const { url, x, y } = this;\n    let style = `url('${url}')`;\n    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n      style += ` ${x} ${y}`;\n    }\n    return this.addFallbackStyleProperty(style);\n  }\n\n  static getUniqueInstanceName(prefix: string): string {\n    return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n  }\n}\n","import { SVGCursorDescriptor } from '../types';\n\n/*\n * Definitions\n */\n\nconst BASE: SVGCursorDescriptor = {\n  iconContent: '',\n  iconSize: 16,\n  viewBox: {\n    x: 16,\n    y: 16,\n  },\n  mousePoint: {\n    x: 8,\n    y: 8,\n  },\n  mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\n\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n  x: 127,\n  y: 60,\n};\n\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\n\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\n\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\n\nconst CursorSVG = {\n  Angle: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  ArrowAnnotate: extend(BASE, {\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Bidirectional: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n    viewBox: {\n      x: 48,\n      y: 48,\n    },\n  }),\n  CobbAngle: extend(BASE, {\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  CircleROI: extend(BASE, {\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  EllipticalROI: extend(BASE, {\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  FreehandROI: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  FreehandROISculptor: extend(BASE, {\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Length: extend(BASE, {\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Probe: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  RectangleROI: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  TextMarker: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Crosshairs: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Eraser: extend(BASE, {\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n    viewBox: {\n      x: 2048,\n      y: 1792,\n    },\n  }),\n  Magnify: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n    viewBox: {\n      x: 512,\n      y: 512,\n    },\n  }),\n  Pan: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Rotate: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  StackScroll: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n    viewBox: {\n      x: 24,\n      y: 28,\n    },\n  }),\n  WindowLevelRegion: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  WindowLevel: extend(BASE, {\n    iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Zoom: extend(BASE, {\n    iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n    viewBox: {\n      x: 640,\n      y: 512,\n    },\n  }),\n\n  /*\n   * Segmentation Cursors\n   */\n\n  SegmentationFreeHandEraseInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandEraseOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationRectangleEraseInside: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  // Default Rectangle Scissors\n  RectangleScissor: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  CircleScissor: extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n};\n\n/*\n * Utils\n */\n\nfunction extend(\n  base: SVGCursorDescriptor,\n  values: Record<string, unknown>\n): SVGCursorDescriptor {\n  return Object.assign(Object.create(base), values);\n}\n\n/**\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\n * Overwrites the given cursor if it is already set.\n *\n * @param toolName - The name of the tool to assign a cursor to.\n * @param iconContent - The SVG icon content of the cursor.\n * @param viewBox - The viewBox of the cursor object.\n */\nfunction registerCursor(\n  toolName: string,\n  iconContent: string,\n  viewBox: { x: number; y: number }\n) {\n  CursorSVG[toolName] = extend(BASE, {\n    iconContent,\n    viewBox,\n  });\n}\n\nfunction getDefinedSVGCursorDescriptor(\n  name: string\n): SVGCursorDescriptor | undefined {\n  if (Object.prototype.hasOwnProperty.call(CursorSVG, name)) {\n    return CursorSVG[name];\n  }\n}\n\n/*\n * Exports\n */\nconst svgCursorNames = Object.keys(CursorSVG);\n\nexport {\n  getDefinedSVGCursorDescriptor,\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n};\n","import {\n  StyleConfig,\n  ToolStyleConfig,\n  StyleSpecifier,\n  AnnotationStyle,\n} from '../../../types/AnnotationStyle';\n\n/**\n * This class handles the configuration of the tool style. You can use it to set\n * the style of a tool at various levels (annotation, viewport, toolGroup, global).\n *\n * The hierarchy of the configuration is as follows (each level falls back to the\n * next level if not specified):\n *\n * 1) Annotation-level styles (with annotationUID)\n *     2) Viewport-level tool styles\n *         - Per-tool: Length on the viewport with viewportId\n *         - Global: All tools on the viewport with viewportId\n *             3) ToolGroup tool styles\n *                 - Per-tool: Angle on toolGroupId in all viewports of the toolGroup\n *                 - Global: All tools in the toolGroupId for all viewports\n *                     4) Default level:\n *                         - Per-tool: Length styles\n *                         - Global: Opinionated styles by CornerstoneJS\n */\nclass ToolStyle {\n  config: StyleConfig;\n\n  constructor() {\n    const defaultConfig = {\n      color: 'rgb(255, 255, 0)',\n      colorHighlighted: 'rgb(0, 255, 0)',\n      colorSelected: 'rgb(0, 220, 0)',\n      colorLocked: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '',\n      shadow: true,\n      textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n      textBoxFontSize: '14px',\n      textBoxColor: 'rgb(255, 255, 0)',\n      textBoxColorHighlighted: 'rgb(0, 255, 0)',\n      textBoxColorSelected: 'rgb(0, 255, 0)',\n      textBoxColorLocked: 'rgb(255, 255, 0)',\n      textBoxBackground: '',\n      textBoxLinkLineWidth: '1',\n      textBoxLinkLineDash: '2,3',\n      textBoxShadow: true,\n    };\n\n    this._initializeConfig(defaultConfig);\n  }\n\n  /**\n   * It returns the annotation-specific tool styles for the annotation with the given UID\n   * @param annotationUID - The unique identifier of the annotation.\n   * @returns The annotation tool styles for the annotation with the given UID.\n   */\n  getAnnotationToolStyles(annotationUID: string): AnnotationStyle {\n    return this.config.annotations && this.config.annotations[annotationUID];\n  }\n\n  /**\n   * It returns the styles for a given viewport. It includes tool-specific and\n   * global styles (all tools in the viewport)\n   * @param viewportId - The id of the viewport\n   * @returns The viewport tool styles for the given viewport id.\n   */\n  getViewportToolStyles(viewportId: string): ToolStyleConfig {\n    return this.config.viewports && this.config.viewports[viewportId];\n  }\n\n  /**\n   * It returns the tool style for the given toolGroup. It includes tool-specific and\n   * global styles (all tools in the toolGroup)\n   * @param toolGroupId - The id of the toolGroup.\n   * @returns The tool styles for the tool group with the given id.\n   */\n  getToolGroupToolStyles(toolGroupId: string): ToolStyleConfig {\n    return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n  }\n\n  /**\n   * It returns the default tool styles from the config file. It includes tool-specific and\n   * global styles (all tools in all tooLGroups)\n   * @returns The default tool styles.\n   */\n  getDefaultToolStyles(): ToolStyleConfig {\n    return this.config.default;\n  }\n\n  /**\n   * It takes an annotationUID and a style object and sets the styles at\n   * the annotationLevel (highest priority in the hierarchy). The styles is an\n   * object with key value pairs.\n   * @param annotationUID - string - The unique identifier for the annotation.\n   * @param styles - ToolStyles\n   */\n  setAnnotationStyles(annotationUID: string, styles: AnnotationStyle) {\n    let annotationSpecificStyles = this.config.annotations;\n\n    if (!annotationSpecificStyles) {\n      this.config = {\n        ...this.config,\n        annotations: {},\n      };\n\n      annotationSpecificStyles = this.config.annotations;\n    }\n\n    annotationSpecificStyles[annotationUID] = styles;\n  }\n\n  /**\n   * It takes a viewportId and a ToolStyles object, and adds the ToolStyles object\n   * at the viewport level (second highest priority in the hierarchy after the annotation level).\n   * @param viewportId - The id of the viewport\n   * @param styles - style object including tool-specific and/or global styles (All tools in the viewport)\n   */\n  setViewportToolStyles(viewportId: string, styles: ToolStyleConfig) {\n    let viewportSpecificStyles = this.config.viewports;\n\n    if (!viewportSpecificStyles) {\n      this.config = {\n        ...this.config,\n        viewports: {},\n      };\n\n      viewportSpecificStyles = this.config.viewports;\n    }\n\n    viewportSpecificStyles[viewportId] = styles;\n  }\n\n  /**\n   * It takes a toolGroupId and a ToolStyles object, and it adds the ToolStyles object\n   * at the toolGroup level (third highest priority in the hierarchy after the viewport level).\n   * @param toolGroupId - The id of the toolGroup\n   * @param styles - style object including tool-specific (in all viewports of the toolGroup) and/or\n   * global styles (All tools in the toolGroup for all viewports)\n   */\n  setToolGroupToolStyles(toolGroupId: string, styles: ToolStyleConfig) {\n    let toolGroupSpecificStyles = this.config.toolGroups;\n\n    if (!toolGroupSpecificStyles) {\n      this.config = {\n        ...this.config,\n        toolGroups: {},\n      };\n\n      toolGroupSpecificStyles = this.config.toolGroups;\n    }\n\n    toolGroupSpecificStyles[toolGroupId] = styles;\n  }\n\n  /**\n   * Sets the default tool styles for the editor. It overrides the default styles for all tools.\n   * @param styles - style object including tool-specific (a tool in all toolGroups) and/or\n   * global styles (All tools in all tooLGroups)\n   */\n  setDefaultToolStyles(styles: ToolStyleConfig) {\n    this.config.default = styles;\n  }\n\n  /**\n   * It returns the value for a given style key, based on the provided specifications.\n   * It starts by looking at the annotation-specific styles, then at the viewport-specific styles,\n   * then at the toolGroup-specific styles, and finally at the default styles.\n   * @param styleKey - The key of the style.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met\n   * @returns The value for the given style key.\n   */\n  getStyleProperty(toolStyle: string, specifications: StyleSpecifier) {\n    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n\n    return this._getToolStyle(\n      toolStyle,\n      annotationUID,\n      viewportId,\n      toolGroupId,\n      toolName\n    );\n  }\n\n  private _getToolStyle(\n    property: string,\n    annotationUID: string,\n    viewportId: string,\n    toolGroupId: string,\n    toolName: string\n  ) {\n    if (annotationUID) {\n      const styles = this.getAnnotationToolStyles(annotationUID);\n\n      if (styles) {\n        // check first in the toolSpecific styles\n        if (styles[property]) {\n          return styles[property];\n        }\n      }\n    }\n\n    if (viewportId) {\n      const styles = this.getViewportToolStyles(viewportId);\n\n      if (styles) {\n        // check if we have the viewportId specific style\n        // check first in the toolSpecific styles\n        if (styles[toolName] && styles[toolName][property]) {\n          return styles[toolName][property];\n        }\n\n        // check if we have the style in the viewport specific global viewportSpecificStyles\n        if (styles.global && styles.global[property]) {\n          return styles.global[property];\n        }\n      }\n    }\n\n    if (toolGroupId) {\n      const styles = this.getToolGroupToolStyles(toolGroupId);\n\n      if (styles) {\n        // check first in the toolSpecific styles\n        if (styles[toolName] && styles[toolName][property]) {\n          return styles[toolName][property];\n        }\n\n        // check if we have the style in the toolGroup specific global styles\n        if (styles.global && styles.global[property]) {\n          return styles.global[property];\n        }\n      }\n    }\n\n    const globalStyles = this.getDefaultToolStyles();\n\n    if (globalStyles[toolName] && globalStyles[toolName][property]) {\n      return globalStyles[toolName][property];\n    }\n\n    if (globalStyles.global && globalStyles.global[property]) {\n      return globalStyles.global[property];\n    }\n  }\n\n  private _initializeConfig(config) {\n    const toolStyles = {};\n    for (const name in config) {\n      toolStyles[name] = config[name];\n    }\n\n    this.config = {\n      default: {\n        global: toolStyles as AnnotationStyle,\n      },\n    };\n  }\n}\n\nconst toolStyle = new ToolStyle();\n\nexport default toolStyle;\n","import { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport toolStyle from './ToolStyle';\n\n/**\n * Build a list of hierarchal property names in ascending order of priority\n * @param property - The base property name -- e.g., 'color'\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns A list of property names\n */\nfunction getHierarchalPropertyStyles(\n  property: string,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string[] {\n  const list = [`${property}`];\n  if (state) list.push(`${list[0]}${state}`);\n  if (mode) list.push(`${list[list.length - 1]}${mode}`);\n  return list;\n}\n\n/**\n * Get the value of a style property from the ToolStyle config\n * @param property - The name of the property to get.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - The state of the tool (Default, Locked etc.)\n * @param mode - The current tool mode. (Active, Passive etc.)\n * @returns The value of the property.\n */\nfunction getStyleProperty(\n  property: string,\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  // Hierarchal property styles is a list of property names with priority in ascending\n  // order like: ['color', 'colorSelected', 'colorSelectedActive'], if in the toolStyle\n  // config, the `colorSelectedActive` property is defined, it will be used, otherwise\n  // the `colorSelected` property will be used, and if that is not defined, the `color`\n  // property will be used. This is done to ensure that the most specific property is used.\n  // Thus, we attempt resolving property names in reverse order\n  const alternatives = getHierarchalPropertyStyles(property, state, mode);\n  for (let i = alternatives.length - 1; i >= 0; --i) {\n    const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n    if (style !== undefined) {\n      return style;\n    }\n  }\n}\n\nexport { getStyleProperty };\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport MouseCursor from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\n\nimport type { StyleSpecifier } from '../types/AnnotationStyle';\nimport type { SVGCursorDescriptor } from '../types';\n\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\n\nexport default class SVGMouseCursor extends ImageMouseCursor {\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(url, x, y, name, fallback);\n  }\n\n  /**\n   * Get a shared instance of the SVGMouseCursor class satisfying the given parameters.\n   *\n   * @param name - The name of the cursor (defined in SVGCursorDescriptor.ts);\n   * @param pointer - Should be true to use the version of the cursor containing\n   * a mouse pointer. Defaults to false (which does not add a pointer to the cursor);\n   * @param color - The color of the cursor. Defaults to tool.style.colorHighlightedActive;\n   * @returns a SVGMouseCursor instance or\n   * undefined if no SVG cursor descriptor was found with the given name;\n   */\n  static getDefinedCursor(\n    name: string,\n    pointer = false,\n    color?: string\n  ): MouseCursor {\n    if (!color) {\n      color = getStyleProperty(PROPERTY, {} as StyleSpecifier, STATE, MODE);\n    }\n    const urn = getCursorURN(name, pointer, color);\n    let cursor = super.getDefinedCursor(urn);\n    if (!cursor) {\n      const descriptor = getDefinedSVGCursorDescriptor(name);\n      if (descriptor) {\n        cursor = createSVGMouseCursor(\n          descriptor,\n          urn,\n          pointer,\n          color,\n          super.getDefinedCursor('default')\n        );\n        super.setDefinedCursor(urn, cursor);\n      }\n    }\n    return cursor;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction format(template: string, dictionary: Record<string, unknown>): string {\n  const dict = Object(dictionary);\n  const defined = Object.prototype.hasOwnProperty.bind(dict);\n  return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return defined(key) ? dict[key] + '' : '';\n  });\n}\n\nfunction getCursorURN(name: string, pointer: boolean, color: string) {\n  const type = pointer ? 'pointer' : 'cursor';\n  return `${type}:${name}/${color}`;\n}\n\nfunction createSVGMouseCursor(\n  descriptor: SVGCursorDescriptor,\n  name: string,\n  pointer: boolean,\n  color: string,\n  fallback: MouseCursor\n): SVGMouseCursor {\n  const { x, y } = descriptor.mousePoint;\n  return new SVGMouseCursor(\n    createSVGIconUrl(descriptor, pointer, { color }),\n    x,\n    y,\n    name,\n    fallback\n  );\n}\n\nfunction createSVGIconUrl(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): string {\n  return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\n}\n\nfunction createSVGIconBlob(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): Blob {\n  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(\n    descriptor,\n    options\n  );\n  return new Blob([svgString], { type: 'image/svg+xml' });\n}\n\nfunction createSVGIcon(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n): string {\n  const { iconContent, iconSize, viewBox } = descriptor;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n  return format(svgString, options);\n}\n\nfunction createSVGIconWithPointer(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n) {\n  const { iconContent, iconSize, viewBox, mousePointerGroupString } =\n    descriptor;\n  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n  const svgSize = 16 + iconSize;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n  return format(svgString, options);\n}\n","import { MouseCursor } from '.';\n\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\n\n/*\n * Public Methods\n */\n\nfunction initElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  _getElementCursors(element)[0] = cursor;\n  _setElementCursor(element, cursor);\n}\n\nfunction _setElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  const cursors = _getElementCursors(element);\n  cursors[1] = cursors[0];\n  cursors[0] = cursor;\n  element.style.cursor = (\n    cursor instanceof MouseCursor\n      ? cursor\n      : MouseCursor.getDefinedCursor('auto')\n  ).getStyleProperty();\n}\n\nfunction resetElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, _getElementCursors(element)[1]);\n}\n\nfunction hideElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\n\n/*\n * Helpers\n */\n\nfunction _getElementCursors(\n  element: HTMLDivElement\n): [MouseCursor | null, MouseCursor | null] {\n  let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n  if (!(map instanceof WeakMap)) {\n    map = new WeakMap();\n    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n      value: map,\n    });\n  }\n  let cursors = map.get(element);\n  if (!cursors) {\n    cursors = [null, null];\n    map.set(element, cursors);\n  }\n  return cursors;\n}\n\n/*\n * Exports\n */\nexport {\n  initElementCursor,\n  resetElementCursor,\n  hideElementCursor,\n  _setElementCursor as setElementCursor,\n};\n","import { MouseBindings, ToolModes } from '../../enums';\nimport cloneDeep from 'lodash.clonedeep';\nimport get from 'lodash.get';\nimport {\n  getRenderingEngine,\n  getRenderingEngines,\n  getEnabledElementByIds,\n  Settings,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../index';\nimport {\n  IToolBinding,\n  IToolClassReference,\n  IToolGroup,\n  SetToolBindingsType,\n  ToolOptionsType,\n} from '../../types';\n\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\n\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\n\n/**\n * ToolGroup class which is a container for tools and their modes and states.\n * In Cornerstone3DTools, you need to create a tool group in order to use the\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports. Tools can set to be activated, enabled or disabled\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\n *\n * ```js\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\n * ```\n */\nexport default class ToolGroup implements IToolGroup {\n  id: string;\n  viewportsInfo = [];\n  toolOptions = {};\n  _toolInstances = {};\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Get the viewport IDs of all the viewports in the current viewport\n   * @returns An array of viewport IDs.\n   */\n  getViewportIds(): string[] {\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\n  }\n\n  /**\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\n   */\n  getViewportsInfo(): Array<Types.IViewportId> {\n    return this.viewportsInfo.slice();\n  }\n\n  /**\n   * Get the tool instance for a given tool name in the toolGroup\n   * @param toolName - The name of the tool.\n   * @returns A tool instance.\n   */\n  public getToolInstance(toolInstanceName: string) {\n    const toolInstance = this._toolInstances[toolInstanceName];\n    if (!toolInstance) {\n      console.warn(\n        `'${toolInstanceName}' is not registered with this toolGroup.`\n      );\n      return;\n    }\n\n    return toolInstance;\n  }\n  /**\n   * Add a tool to the tool group with the given tool name and tool configuration.\n   * Note that adding a tool to a tool group will not automatically set the tool\n   * to be active. You must call setToolActive or setToolPassive and other methods\n   * to set the tool to be active or passive or in other states.\n   *\n   * @param toolName - string\n   * @param configuration - Tool configuration objects\n   */\n  addTool(toolName: string, configuration = {}): void {\n    const toolDefinition = state.tools[toolName];\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n    const localToolInstance = this.toolOptions[toolName];\n\n    if (!hasToolName) {\n      console.warn(\n        'Tool with configuration did not produce a toolName: ',\n        configuration\n      );\n      return;\n    }\n\n    if (!toolDefinition) {\n      console.warn(\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\n      );\n      return;\n    }\n\n    if (localToolInstance) {\n      console.warn(\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\n      );\n      return;\n    }\n\n    // Should these be renamed higher up, so we don't have to alias?\n    // Wrap in try-catch so 3rd party tools don't explode?\n    const { toolClass: ToolClass } = toolDefinition;\n\n    const toolProps = {\n      name: toolName,\n      toolGroupId: this.id,\n      configuration,\n    };\n\n    const instantiatedTool = new ToolClass(toolProps);\n\n    // API instead of directly exposing schema?\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\n    this._toolInstances[toolName] = instantiatedTool;\n  }\n\n  public addToolInstance(\n    toolName: string,\n    parentClassName: string,\n    configuration = {}\n  ): void {\n    let ToolClassToUse = state.tools[toolName]\n      ?.toolClass as IToolClassReference;\n\n    if (!ToolClassToUse) {\n      // get parent class constructor\n      const ParentClass = state.tools[parentClassName]\n        .toolClass as IToolClassReference;\n\n      // Todo: could not find a way to make this work with typescript\n      // @ts-ignore\n      class ToolInstance extends ParentClass {}\n      // @ts-ignore\n      ToolInstance.toolName = toolName;\n      // @ts-ignore\n      ToolClassToUse = ToolInstance;\n\n      state.tools[toolName] = {\n        toolClass: ToolInstance as IToolClassReference,\n      };\n    }\n\n    // add the tool to the toolGroup\n    // @ts-ignore\n    this.addTool(ToolClassToUse.toolName, configuration);\n  }\n\n  //   class InstanceTool extends parentClass;\n  // InstanceTool.constructor.toolName = name;\n  // addTool(InstanceTool,configuration)\n  /**\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\n   * renderingEngineId parameter. If renderingEngineId is not provided,\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\n   * it will use that renderingEngine.\n   *\n   * @param viewportId - The unique identifier for the viewport.\n   * @param renderingEngineId - The rendering engine to use.\n   */\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\n    const renderingEngines = getRenderingEngines();\n\n    if (!renderingEngineId && renderingEngines.length > 1) {\n      throw new Error(\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\n      );\n    }\n\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n\n    // Don't overwrite if it already exists\n    if (\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\n    ) {\n      this.viewportsInfo.push({\n        viewportId,\n        renderingEngineId: renderingEngineUIDToUse,\n      });\n    }\n\n    // Handle the newly added viewport's mouse cursor\n    const toolName = this.getActivePrimaryMouseButtonTool();\n\n    const runtimeSettings = Settings.getRuntimeSettings();\n    if (runtimeSettings.get('useCursors')) {\n      this.setViewportsCursorByToolName(toolName);\n    }\n  }\n\n  /**\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\n   * it removes all the viewports with the same renderingEngineId, if viewportId\n   * is also provided, it will remove that specific viewport from the ToolGroup.\n   *\n   * @param renderingEngineId - renderingEngine id\n   * @param viewportId - viewport id\n   */\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\n    const indices = [];\n\n    this.viewportsInfo.forEach((vpInfo, index) => {\n      let match = false;\n      if (vpInfo.renderingEngineId === renderingEngineId) {\n        match = true;\n\n        if (viewportId && vpInfo.viewportId !== viewportId) {\n          match = false;\n        }\n      }\n      if (match) {\n        indices.push(index);\n      }\n    });\n\n    if (indices.length) {\n      // Note: Traverse the array backwards, such that when we remove items we\n      // do not immediately mess up our loop indicies.\n      for (let i = indices.length - 1; i >= 0; i--) {\n        this.viewportsInfo.splice(indices[i], 1);\n      }\n    }\n  }\n\n  public setActiveStrategy(toolName: string, strategyName: string) {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\n      );\n\n      return;\n    }\n\n    toolInstance.setActiveStrategy(strategyName);\n  }\n\n  setToolMode(\n    toolName: string,\n    mode: ToolModes,\n    options = {} as SetToolBindingsType\n  ): void {\n    if (!toolName) {\n      console.warn('setToolMode: toolName must be defined');\n      return;\n    }\n\n    if (mode === ToolModes.Active) {\n      this.setToolActive(toolName, options);\n      return;\n    }\n\n    if (mode === ToolModes.Passive) {\n      this.setToolPassive(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Enabled) {\n      this.setToolEnabled(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Disabled) {\n      this.setToolDisabled(toolName);\n      return;\n    }\n\n    console.warn('setToolMode: mode must be defined');\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Active. This means the tool\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\n   *\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param toolBindingsOptions - tool bindings\n   */\n  public setToolActive(\n    toolName: string,\n    toolBindingsOptions = {} as SetToolBindingsType\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    if (!toolInstance) {\n      console.warn(\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\n      );\n      return;\n    }\n\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\n      ? this.toolOptions[toolName].bindings\n      : [];\n\n    const newBindings = toolBindingsOptions.bindings\n      ? toolBindingsOptions.bindings\n      : [];\n\n    // combine the new bindings with the previous bindings to avoid duplicates\n    // it allows duplicated mouse buttons as long as they don't have same\n    // modifier keys.\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\n      (unique, binding) => {\n        const TouchBinding = binding.numTouchPoints !== undefined;\n        const MouseBinding = binding.mouseButton !== undefined;\n\n        if (\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\n          (TouchBinding || MouseBinding)\n        ) {\n          unique.push(binding);\n        }\n        return unique;\n      },\n      []\n    );\n\n    // We should not override the bindings if they are already set\n    const toolOptions: ToolOptionsType = {\n      bindings: bindingsToUse,\n      mode: Active,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    this._toolInstances[toolName].mode = Active;\n\n    // reset the mouse cursor if tool has left click binding\n    const runtimeSettings = Settings.getRuntimeSettings();\n    const useCursor = runtimeSettings.get('useCursors');\n\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n      this.setViewportsCursorByToolName(toolName);\n    } else {\n      // reset to default cursor only if there is no other tool with primary binding\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n      if (!activeToolIdentifier && useCursor) {\n        const cursor = MouseCursor.getDefinedCursor('default');\n        this._setCursorForViewports(cursor);\n      }\n    }\n\n    if (typeof toolInstance.onSetToolActive === 'function') {\n      toolInstance.onSetToolActive();\n    }\n    this._renderViewports();\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Passive.\n   *\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   */\n  public setToolPassive(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    // We should only remove the primary button bindings and keep\n    // the other ones (Zoom on right click)\n    const prevToolOptions = this.getToolOptions(toolName);\n    const toolOptions = Object.assign(\n      {\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\n      },\n      prevToolOptions,\n      {\n        mode: Passive,\n      }\n    );\n\n    // Remove the primary button bindings without modifiers, if they exist\n    toolOptions.bindings = toolOptions.bindings.filter(\n      (binding) =>\n        binding.mouseButton !== MouseBindings.Primary || binding.modifierKey\n    );\n\n    // If there are other bindings, set the tool to be active\n    let mode = Passive;\n    if (toolOptions.bindings.length !== 0) {\n      mode = Active;\n      toolOptions.mode = mode;\n    }\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = mode;\n\n    if (typeof toolInstance.onSetToolPassive === 'function') {\n      toolInstance.onSetToolPassive();\n    }\n    this._renderViewports();\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Enabled.\n   *\n   * - Renders data if the tool has a `renderAnnotation` method..\n   *\n   * @param toolName - tool name\n   */\n  public setToolEnabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Enabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Enabled;\n\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\n      toolInstance.onSetToolEnabled();\n    }\n\n    this._renderViewports();\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Disabled.\n   *\n   * - Annotation does not render.\n   *\n   * @param toolName - tool name\n   */\n  public setToolDisabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Disabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Disabled;\n\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\n      toolInstance.onSetToolDisabled();\n    }\n    this._renderViewports();\n  }\n\n  /**\n   * Get the options for a given tool\n   * @param toolName - The name of the tool.\n   * @returns the tool options\n   */\n  public getToolOptions(toolName: string): ToolOptionsType {\n    const toolOptionsForTool = this.toolOptions[toolName];\n\n    if (toolOptionsForTool === undefined) {\n      return;\n    }\n\n    return toolOptionsForTool;\n  }\n\n  /**\n   * Find the name of the tool that is Active and has a primary button binding\n   * (Mouse primary click)\n   *\n   * @returns The name of the tool\n   */\n  public getActivePrimaryMouseButtonTool(): string {\n    return Object.keys(this.toolOptions).find((toolName) => {\n      const toolOptions = this.toolOptions[toolName];\n      return (\n        toolOptions.mode === Active &&\n        this._hasMousePrimaryButtonBinding(toolOptions)\n      );\n    });\n  }\n\n  public setViewportsCursorByToolName(\n    toolName: string,\n    strategyName?: string\n  ): void {\n    const cursor = this._getCursor(toolName, strategyName);\n\n    this._setCursorForViewports(cursor);\n  }\n\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\n    let cursorName;\n    let cursor;\n\n    if (strategyName) {\n      // Try combinations with strategyName first:\n      // Try with toolName and toolInstanceName first.\n      cursorName = `${toolName}.${strategyName}`;\n\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n      if (cursor) {\n        return cursor;\n      }\n    }\n\n    // Try with toolName and toolInstanceName first.\n    cursorName = `${toolName}`;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    // Try with just toolName.\n    cursorName = toolName;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    return MouseCursor.getDefinedCursor('default');\n  }\n\n  _setCursorForViewports(cursor: MouseCursor): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      initElementCursor(viewport.element, cursor);\n    });\n  }\n\n  /**\n   * Set a configuration of a tool by the given toolName.\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\n   */\n  public setToolConfiguration(\n    toolName: string,\n    configuration: Record<any, any>,\n    overwrite?: boolean\n  ): boolean {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return false;\n    }\n\n    let _configuration;\n\n    if (overwrite) {\n      _configuration = configuration;\n    } else {\n      _configuration = csUtils.deepMerge(\n        this._toolInstances[toolName].configuration,\n        configuration\n      );\n    }\n\n    this._toolInstances[toolName].configuration = _configuration;\n\n    this._renderViewports();\n\n    return true;\n  }\n\n  /**\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\n   * ConfigurationPath is the the path of the property to get separated by '.'.\n   *\n   * @example\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\n   */\n  getToolConfiguration(toolName: string, configurationPath: string): any {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return;\n    }\n\n    const _configuration = get(\n      this._toolInstances[toolName].configuration,\n      configurationPath\n    );\n\n    return cloneDeep(_configuration);\n  }\n\n  /**\n   * Check if the tool binding is set to be primary mouse button.\n   * @param toolOptions - The options for the tool mode.\n   * @returns A boolean value.\n   */\n  private _hasMousePrimaryButtonBinding(toolOptions) {\n    return toolOptions?.bindings?.some(\n      (binding) =>\n        binding.mouseButton === MouseBindings.Primary &&\n        binding.modifierKey === undefined\n    );\n  }\n\n  /**\n   * It re-renders the viewports in the toolGroup\n   */\n  private _renderViewports(): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n    });\n  }\n}\n\nfunction hasSameBinding(\n  binding1: IToolBinding,\n  binding2: IToolBinding\n): boolean {\n  if (binding1.mouseButton !== binding2.mouseButton) {\n    return false;\n  }\n\n  return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nimport { IToolGroup } from '../../types';\n\n/**\n * Create a new tool group with the given name. ToolGroups are the new way\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports.\n *\n * @param toolGroupId - The unique ID of the tool group.\n * @returns A reference to the tool group that was created.\n */\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\n  // Exit early if ID conflict\n  const toolGroupWithIdExists = state.toolGroups.some(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupWithIdExists) {\n    console.warn(`'${toolGroupId}' already exists.`);\n    return;\n  }\n\n  const toolGroup = new ToolGroup(toolGroupId);\n\n  // Update state\n  state.toolGroups.push(toolGroup);\n\n  // Return reference\n  return toolGroup;\n}\n\nexport default createToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Return the array of tool groups\n * @returns An array of tool groups.\n */\nfunction getAllToolGroups(): Array<IToolGroup> {\n  return state.toolGroups;\n}\n\nexport default getAllToolGroups;\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera by updating all camera\n * values.  See also zoomPanSyncCallback\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default function cameraSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  cameraModifiedEvent: CustomEvent\n): void {\n  const { camera } = cameraModifiedEvent.detail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n\n  tViewport.setCamera(camera);\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createCameraPositionSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const cameraPositionSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    cameraSyncCallback\n  );\n\n  return cameraPositionSynchronizer;\n}\n","import {\n  getRenderingEngine,\n  StackViewport,\n  Types,\n  VolumeViewport,\n} from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the voi of volumeActors of identical volumes\n * in different viewports.\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport.\n * @param voiModifiedEvent - The VOI_MODIFIED event.\n */\nexport default function voiSyncCallback(\n  synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  voiModifiedEvent: Types.EventTypes.VoiModifiedEvent\n): void {\n  const eventDetail = voiModifiedEvent.detail;\n  const { volumeId, range } = eventDetail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `Rendering Engine does not exist: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n\n  if (tViewport instanceof VolumeViewport) {\n    tViewport.setProperties(\n      {\n        voiRange: range,\n      },\n      volumeId\n    );\n  } else if (tViewport instanceof StackViewport) {\n    tViewport.setProperties({\n      voiRange: range,\n    });\n  } else {\n    throw new Error('Viewport type not supported.');\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\n/**\n * A helper that creates a new `Synchronizer`\n * which listens to the `VOI_MODIFIED` rendering event and calls the `voiSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n *\n * @returns A new `Synchronizer` instance.\n */\nexport default function createVOISynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const VOISynchronizer = createSynchronizer(\n    synchronizerName,\n    Enums.Events.VOI_MODIFIED,\n    voiSyncCallback\n  );\n\n  return VOISynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function zoomPanSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  if (options?.syncZoom !== false) {\n    const srcZoom = sViewport.getZoom();\n    // Do the zoom first, as the pan is relative to the zoom level\n    tViewport.setZoom(srcZoom);\n  }\n  if (options?.syncPan !== false) {\n    const srcPan = sViewport.getPan();\n    tViewport.setPan(srcPan);\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createZoomPanSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const zoomPanSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    zoomPanSyncCallback\n  );\n\n  return zoomPanSynchronizer;\n}\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  options: ScrollOptions\n): void {\n  const { type: viewportType } = viewport;\n  const { volumeId, delta } = options;\n\n  if (viewport instanceof StackViewport) {\n    viewport.scroll(delta, options.debounceLoading, options.loop);\n  } else if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta);\n  } else {\n    throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number\n) {\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    const VolumeScrollEventDetail = {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail as EventTypes.VolumeScrollOutOfBoundsEventDetail\n    );\n  }\n}\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  } else if (viewport instanceof VolumeViewport) {\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\n  } else {\n    throw new Error('Unsupported viewport type');\n  }\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nexport default function areViewportsCoplanar(\n  viewport1: Types.IStackViewport,\n  viewport2: Types.IStackViewport\n): boolean {\n  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n  const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n  return Math.abs(dotProducts) > 0.9;\n}\n","import { vec3 } from 'gl-matrix';\nimport {\n  getRenderingEngine,\n  Types,\n  metaData,\n  utilities,\n} from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\nimport { jumpToSlice } from '../../utilities';\nimport areViewportsCoplanar from './areViewportsCoplanar ';\n/**\n * Synchronizer callback to synchronize the source viewport image to the\n * target viewports closest image in its stack. There are two scenarios\n *\n * 1) viewports are in the same frameOfReferenceUID then we can use the\n * absolute imagePositionPatient for the source viewport's current image\n * and set the target viewport's image to the closest image in its stack\n * (which might have different slice thickness so cannot use slice number)\n *\n * 2) viewports have different frameOfReferenceUIDs then we look inside the\n * registrationMetadataProvider to check if there is a corresponding matrix\n * for mapping between the source and target viewport if so it is used to\n * and is applied to the imagePositionPatient of the source viewport's to\n * get the imagePositionPatient of the target viewport's closest image in\n * its stack.\n * Note for 2) The consuming apps using Cornerstone3D (OHIF, etc) are responsible\n * to provide such data in the registrationMetadataProvider. This can be done\n * by various methods 1) Using spatialRegistrationModule inside dicom 2) assuming\n * the user has actually manually scrolled the target viewport to the correct\n * slice before initiating the synchronization 3) using some other method\n * But overall, the consuming app is responsible for providing the data.\n *\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default async function stackImageSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): Promise<void> {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const sViewport = renderingEngine.getViewport(\n    sourceViewport.viewportId\n  ) as Types.IStackViewport;\n\n  const tViewport = renderingEngine.getViewport(\n    targetViewport.viewportId\n  ) as Types.IStackViewport;\n\n  const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n  const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n\n  const imageId1 = sViewport.getCurrentImageId();\n  const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n\n  const targetImageIds = tViewport.getImageIds();\n\n  if (!areViewportsCoplanar(sViewport, tViewport)) {\n    return;\n  }\n\n  if (frameOfReferenceUID1 === frameOfReferenceUID2) {\n    // if frames of references are the same we can use the absolute\n    // imagePositionPatient to find the closest image in the target viewport's stack\n    const closestImageIdIndex = _getClosestImageIdIndex(\n      sourceImagePositionPatient,\n      targetImageIds\n    );\n\n    if (\n      closestImageIdIndex.index !== -1 &&\n      tViewport.getCurrentImageIdIndex() !== closestImageIdIndex.index\n    ) {\n      // await tViewport.setImageIdIndex(closestImageIdIndex.index);\n      await jumpToSlice(tViewport.element, {\n        imageIndex: closestImageIdIndex.index,\n      });\n\n      return;\n    }\n  } else {\n    // if the frame of reference is different we need to use the registrationMetadataProvider\n    // and add that to the imagePositionPatient of the source viewport to get the\n    // imagePositionPatient of the target viewport's closest image in its stack\n    const registrationMatrixMat4 =\n      utilities.spatialRegistrationMetadataProvider.get(\n        'spatialRegistrationModule',\n        [targetViewport.viewportId, sourceViewport.viewportId]\n      );\n\n    if (!registrationMatrixMat4) {\n      throw new Error(\n        `No registration matrix found for sourceViewport: ${sourceViewport.viewportId} and targetViewport: ${targetViewport.viewportId}, viewports with different frameOfReferenceUIDs must have a registration matrix in the registrationMetadataProvider. Use calculateViewportsRegistrationMatrix to calculate the matrix.`\n      );\n    }\n\n    // apply the registration matrix to the source viewport's imagePositionPatient\n    // to get the target viewport's imagePositionPatient\n    const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(\n      vec3.create(),\n      sourceImagePositionPatient,\n      registrationMatrixMat4\n    );\n\n    // find the closest image in the target viewport's stack to the\n    // targetImagePositionPatientWithRegistrationMatrix\n    const closestImageIdIndex2 = _getClosestImageIdIndex(\n      targetImagePositionPatientWithRegistrationMatrix,\n      targetImageIds\n    );\n\n    if (\n      closestImageIdIndex2.index !== -1 &&\n      tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index\n    ) {\n      await jumpToSlice(tViewport.element, {\n        imageIndex: closestImageIdIndex2.index,\n      });\n    }\n  }\n}\n\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n  // todo: this does not assume orientation yet, but that can be added later\n  return imageIds.reduce(\n    (closestImageIdIndex, imageId, index) => {\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n      const distance = vec3.distance(imagePositionPatient, targetPoint);\n\n      if (distance < closestImageIdIndex.distance) {\n        return {\n          distance,\n          index,\n        };\n      }\n      return closestImageIdIndex;\n    },\n    {\n      distance: Infinity,\n      index: -1,\n    }\n  );\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport stackImageSyncCallback from '../callbacks/stackImageSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { STACK_NEW_IMAGE } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `STACK_NEW_IMAGE`\n * rendering event and calls the `stackImageSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createStackImageSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const stackImageSynchronizer = createSynchronizer(\n    synchronizerName,\n    STACK_NEW_IMAGE,\n    stackImageSyncCallback\n  );\n\n  return stackImageSynchronizer;\n}\n","function _getHash(\n  annotationUID: string,\n  drawingElementType: string,\n  nodeUID: string\n): string {\n  return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\n\nexport default _getHash;\n","export function _setAttributesIfNecessary(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const currentValue = svgNode.getAttribute(key);\n    const newValue = attributes[key];\n    if (newValue === undefined || newValue === '') {\n      svgNode.removeAttribute(key);\n    } else if (currentValue !== newValue) {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default _setAttributesIfNecessary;\n","export function _setNewAttributesIfValid(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const newValue = attributes[key];\n    if (newValue !== undefined && newValue !== '') {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default _setNewAttributesIfValid;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\n\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\n\nfunction drawCircle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  circleUID: string,\n  center: Types.Point2,\n  radius: number,\n  options = {},\n  dataId = ''\n): void {\n  const { color, fill, width, lineWidth } = Object.assign(\n    {\n      color: 'dodgerblue',\n      fill: 'transparent',\n      width: '2',\n      lineWidth: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    r: `${radius}`,\n    stroke: color,\n    fill,\n    'stroke-width': strokeWidth,\n  };\n\n  if (existingCircleElement) {\n    _setAttributesIfNecessary(attributes, existingCircleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newCircleElement = document.createElementNS(svgns, 'circle');\n\n    if (dataId !== '') {\n      newCircleElement.setAttribute('data-id', dataId);\n    }\n\n    _setNewAttributesIfValid(attributes, newCircleElement);\n\n    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n  }\n}\n\nexport default drawCircle;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\n\nfunction drawEllipse(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  corner1: Types.Point2,\n  corner2: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const w = Math.abs(corner1[0] - corner2[0]);\n  const h = Math.abs(corner1[1] - corner2[1]);\n  const xMin = Math.min(corner1[0], corner2[0]);\n  const yMin = Math.min(corner1[1], corner2[1]);\n\n  const center = [xMin + w / 2, yMin + h / 2];\n  const radiusX = w / 2;\n  const radiusY = h / 2;\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    rx: `${radiusX}`,\n    ry: `${radiusY}`,\n    stroke: color,\n    fill: 'transparent',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingEllipse) {\n    _setAttributesIfNecessary(attributes, existingEllipse);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n\n    if (dataId !== '') {\n      svgEllipseElement.setAttribute('data-id', dataId);\n    }\n\n    _setNewAttributesIfValid(attributes, svgEllipseElement);\n\n    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n  }\n}\n\nexport default drawEllipse;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawHandles(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handlePoints: Array<Types.Point2>,\n  options = {}\n): void {\n  const { color, handleRadius, width, lineWidth, fill, type, opacity } =\n    Object.assign(\n      {\n        color: 'dodgerblue',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  for (let i = 0; i < handlePoints.length; i++) {\n    const handle = handlePoints[i];\n\n    // variable for the namespace\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(\n      annotationUID,\n      'handle',\n      `hg-${handleGroupUID}-index-${i}`\n    );\n\n    let attributes;\n    if (type === 'circle') {\n      attributes = {\n        cx: `${handle[0]}`,\n        cy: `${handle[1]}`,\n        r: handleRadius,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        opacity: opacity,\n      };\n    } else if (type === 'rect') {\n      const handleRadiusFloat = parseFloat(handleRadius);\n      const side = handleRadiusFloat * 1.5;\n      const x = handle[0] - side * 0.5;\n      const y = handle[1] - side * 0.5;\n\n      attributes = {\n        x: `${x}`,\n        y: `${y}`,\n        width: `${side}`,\n        height: `${side}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        rx: `${side * 0.1}`,\n        opacity: opacity,\n      };\n    } else {\n      throw new Error(`Unsupported handle type: ${type}`);\n    }\n\n    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n    if (existingHandleElement) {\n      _setAttributesIfNecessary(attributes, existingHandleElement);\n\n      svgDrawingHelper.setNodeTouched(svgNodeHash);\n    } else {\n      const newHandleElement = document.createElementNS(svgns, type);\n\n      _setNewAttributesIfValid(attributes, newHandleElement);\n\n      svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n    }\n  }\n}\n\nexport default drawHandles;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nexport default function drawLine(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  lineUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash, shadow } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n      shadow: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n  const dropShadowStyle = shadow\n    ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n    : '';\n\n  const attributes = {\n    x1: `${start[0]}`,\n    y1: `${start[1]}`,\n    x2: `${end[0]}`,\n    y2: `${end[1]}`,\n    stroke: color,\n    style: dropShadowStyle,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    _setAttributesIfNecessary(attributes, existingLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newLine = document.createElementNS(svgns, 'line');\n\n    if (dataId !== '') {\n      newLine.setAttribute('data-id', dataId);\n    }\n\n    _setNewAttributesIfValid(attributes, newLine);\n\n    svgDrawingHelper.appendNode(newLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG polyline with the given points.\n *\n * The `connectLastToFirst` option, if true, draws a closed polyline, with the\n * last point connected to the first.\n */\nexport default function drawPolyline(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  polylineUID: string,\n  points: Types.Point2[],\n  options: {\n    color?: string;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    connectLastToFirst?: boolean;\n  }\n): void {\n  if (points.length < 2) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n      connectLastToFirst: false,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  let pointsAttribute = '';\n\n  for (const point of points) {\n    pointsAttribute += `${point[0]}, ${point[1]} `;\n  }\n\n  if (options.connectLastToFirst) {\n    const firstPoint = points[0];\n\n    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n  }\n\n  const attributes = {\n    points: pointsAttribute,\n    stroke: color,\n    fill: 'none',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingPolyLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    _setAttributesIfNecessary(attributes, existingPolyLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newPolyLine = document.createElementNS(svgns, 'polyline');\n\n    _setNewAttributesIfValid(attributes, newPolyLine);\n\n    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\n\n/**\n * Draws a textBox.\n *\n * @param textLines - The text to display.\n * @param position - The x/y position of the textbox\n * @param options - Options for the textBox.\n * @returns Bounding box; can be used for isPointNearTool\n */\nfunction drawTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string>,\n  position: Types.Point2,\n  options = {}\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      fontFamily: 'Helvetica, Arial, sans-serif',\n      fontSize: '14px',\n      color: 'rgb(255, 255, 0)',\n      background: '',\n      padding: 25,\n      centerX: false,\n      centerY: true,\n    },\n    options\n  );\n\n  // Draw each of the text lines on top of the background box\n  const textGroupBoundingBox = _drawTextGroup(\n    svgDrawingHelper,\n    annotationUID,\n    textUID,\n    textLines,\n    position,\n    mergedOptions\n  );\n\n  return textGroupBoundingBox;\n}\n\nfunction _drawTextGroup(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string> = [''],\n  position: Types.Point2,\n  options: any\n): SVGRect {\n  const { padding, color, fontFamily, fontSize, background } = options;\n\n  let textGroupBoundingBox;\n  const [x, y] = [position[0] + padding, position[1] + padding];\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  // Todo: right now textBox gets a re-render even if the textBox has not changed\n  // and evenIf the attributes are not set again since they are the same.\n  if (existingTextGroup) {\n    // TODO: Iterate each node and update color? font-size?\n    const textElement = existingTextGroup.querySelector('text');\n    const textSpans = Array.from(textElement.children) as Array<SVGElement>;\n\n    for (let i = 0; i < textSpans.length; i++) {\n      const textSpanElement = textSpans[i];\n      const text = textLines[i] || '';\n\n      textSpanElement.textContent = text;\n    }\n\n    // if the textLines have changed size, we need to create textSpans for them\n    if (textLines.length > textSpans.length) {\n      for (let i = 0; i < textLines.length - textSpans.length; i++) {\n        const textLine = textLines[i + textSpans.length];\n        const textSpan = _createTextSpan(textLine);\n\n        textElement.appendChild(textSpan);\n      }\n\n      existingTextGroup.appendChild(textElement);\n      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n    }\n\n    const textAttributes = {\n      fill: color,\n      'font-size': fontSize,\n      'font-family': fontFamily,\n    };\n\n    const textGroupAttributes = {\n      transform: `translate(${x} ${y})`,\n    };\n\n    // Todo: for some reason this does not work to not re-render the textBox\n    _setAttributesIfNecessary(textAttributes, textElement);\n    _setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n\n    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const textGroup = document.createElementNS(svgns, 'g');\n\n    textGroup.setAttribute('transform', `translate(${x} ${y})`);\n\n    //\n    const textElement = _createTextElement(svgDrawingHelper, options);\n    for (let i = 0; i < textLines.length; i++) {\n      const textLine = textLines[i];\n      const textSpan = _createTextSpan(textLine);\n\n      textElement.appendChild(textSpan);\n    }\n\n    textGroup.appendChild(textElement);\n    svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n    textGroupBoundingBox = _drawTextBackground(textGroup, background);\n  }\n\n  // We translate the group using `position`\n  // which means we also need to pluck those values when returning\n  // the bounding box\n  return Object.assign({}, textGroupBoundingBox, {\n    x,\n    y,\n    height: textGroupBoundingBox.height + padding,\n    width: textGroupBoundingBox.width + padding,\n  });\n}\n\nfunction _createTextElement(\n  svgDrawingHelper: SVGDrawingHelper,\n  options: any\n): SVGElement {\n  const { color, fontFamily, fontSize } = options;\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textElement = document.createElementNS(svgns, 'text');\n  const noSelectStyle =\n    'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n\n  // font-size=\"100\"\n  textElement.setAttribute('x', '0');\n  textElement.setAttribute('y', '0');\n  textElement.setAttribute('fill', color);\n  textElement.setAttribute('font-family', fontFamily);\n  textElement.setAttribute('font-size', fontSize);\n  textElement.setAttribute('style', combinedStyle);\n\n  return textElement;\n}\n\nfunction _createTextSpan(text): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textSpanElement = document.createElementNS(svgns, 'tspan');\n\n  // TODO: centerX\n  // (parent width / 2) - my width\n  // TODO: centerY\n\n  textSpanElement.setAttribute('x', '0');\n  textSpanElement.setAttribute('dy', '1.2em');\n  textSpanElement.textContent = text;\n\n  return textSpanElement;\n}\n\nfunction _drawTextBackground(group: SVGGElement, color: string) {\n  let element = group.querySelector('rect.background');\n\n  // If we have no background color, remove any element that exists and return\n  // the bounding box of the text\n  if (!color) {\n    if (element) {\n      group.removeChild(element);\n    }\n\n    return group.getBBox();\n  }\n\n  // Otherwise, check if we have a <rect> element. If not, create one\n  if (!element) {\n    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    element.setAttribute('class', 'background');\n    group.insertBefore(element, group.firstChild);\n  }\n\n  // Get the text groups's bounding box and use it to draw the background rectangle\n  const bBox = group.getBBox();\n\n  const attributes = {\n    x: `${bBox.x}`,\n    y: `${bBox.y}`,\n    width: `${bBox.width}`,\n    height: `${bBox.height}`,\n    fill: color,\n  };\n\n  _setAttributesIfNecessary(attributes, element);\n\n  return bBox;\n}\n\nexport default drawTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Find the closest point to the target point\n *\n * @param sourcePoints - The potential source points.\n * @param targetPoint - The target point, used to find the closest source.\n * @returns The closest point in the array of point sources\n */\nexport default function findClosestPoint(\n  sourcePoints: Array<Types.Point2>,\n  targetPoint: Types.Point2\n): Types.Point2 {\n  let minPoint = [0, 0];\n  let minDistance = Number.MAX_SAFE_INTEGER;\n\n  sourcePoints.forEach(function (sourcePoint) {\n    const distance = _distanceBetween(targetPoint, sourcePoint);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPoint = [...sourcePoint];\n    }\n  });\n\n  return minPoint as Types.Point2;\n}\n\n/**\n *\n * @private\n * @param p1\n * @param p2\n */\nfunction _distanceBetween(p1: Types.Point2, p2: Types.Point2): number {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nimport { PlanarBoundingBox, SVGDrawingHelper } from '../types';\n\n/**\n * Draw a link between an annotation to a box.\n */\nfunction drawLink(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  linkUID: string,\n  // Find closest point to approx. bounding box\n  annotationAnchorPoints: Array<Types.Point2>,\n  refPoint: Types.Point2,\n  // Find bounding box point that's closest to our identified\n  // start point\n  boundingBox: PlanarBoundingBox,\n  options = {}\n): void {\n  // The closest anchor point (for the annotation) to the\n  // text box / bounding box\n  const start =\n    annotationAnchorPoints.length > 0\n      ? findClosestPoint(annotationAnchorPoints, refPoint)\n      : refPoint;\n\n  // Calculate the midpoints of the bounding box\n  const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n  // Find the closest textBox midpoint to the annotation's anchor/start point\n  const end = findClosestPoint(boundingBoxPoints, start);\n\n  // Finally we draw the dashed linking line\n  const mergedOptions = Object.assign(\n    {\n      color: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '2,3',\n    },\n    options\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    `link-${linkUID}`,\n    start,\n    end,\n    mergedOptions\n  );\n}\n\n/**\n * Find potential anchor points for a given bounding box. For example, it may\n * look nicer to draw a line from the \"middle left\" of a bounding box to an\n * annotation (instead of from a corner). This function calculates those points\n *\n * @param boundingBox\n */\nfunction _boundingBoxPoints(\n  boundingBox: PlanarBoundingBox\n): Array<Types.Point2> {\n  const { x: left, y: top, height, width } = boundingBox;\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n\n  const topMiddle = [left + halfWidth, top] as Types.Point2;\n  const leftMiddle = [left, top + halfHeight] as Types.Point2;\n  const bottomMiddle = [left + halfWidth, top + height] as Types.Point2;\n  const rightMiddle = [left + width, top + halfHeight] as Types.Point2;\n\n  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\n\nexport default drawLink;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawLinkedTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textBoxUID: string,\n  //\n  textLines: Array<string>,\n  textBoxPosition: Types.Point2,\n  annotationAnchorPoints: Array<Types.Point2>,\n  textBox: unknown,\n  options = {}\n  // TODO: yCenter as an option\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      handleRadius: '6',\n      centering: {\n        x: false,\n        y: true, // yCenter,\n      },\n    },\n    options\n  );\n\n  // Draw the text box\n  const canvasBoundingBox = drawTextBox(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    textLines,\n    textBoxPosition,\n    mergedOptions\n  );\n  // if (textBox.hasMoved) {\n  //   // Draw dashed link line between tool and text\n  drawLink(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    annotationAnchorPoints, // annotationAnchorPoints\n    textBoxPosition, // refPoint (text)\n    canvasBoundingBox, // textBoxBoundingBox\n    mergedOptions\n  );\n  // }\n\n  // const { top, left, width, height } = canvasBoundingBox\n\n  // textBox.worldBoundingBox = {\n  //   topLeft: canvasToWorld([left, top]),\n  //   topRight: canvasToWorld([left + width, top]),\n  //   bottomLeft: canvasToWorld([left, top + height]),\n  //   bottomRight: canvasToWorld([left + width, top + height]),\n  // }\n\n  return canvasBoundingBox;\n}\n\nexport default drawLinkedTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nimport { SVGDrawingHelper } from '../types';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRect(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  rectangleUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'transparent',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    _setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    if (dataId !== '') {\n      svgRectElement.setAttribute('data-id', dataId);\n    }\n\n    _setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\nimport drawLine from './drawLine';\n\nexport default function drawArrow(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  arrowUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {}\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // The line itself\n  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n    color,\n    width,\n    lineWidth,\n    lineDash,\n  });\n\n  // Drawing the head arrow with two lines\n  // Variables to be used when creating the arrow\n  const headLength = 10;\n  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n\n  const firstLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle - Math.PI / 7),\n      end[1] - headLength * Math.sin(angle - Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  const secondLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle + Math.PI / 7),\n      end[1] - headLength * Math.sin(angle + Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '2',\n    firstLine.start,\n    firstLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '3',\n    secondLine.start,\n    secondLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param columnPixelSpacing - Spacing in column direction\n * @param renderingEngine - Cornerstone RenderingEngine instance\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  rowPixelSpacing: number,\n  columnPixelSpacing: number\n): void {\n  // 1. Add the calibratedPixelSpacing metadata to the metadata provider\n  // If no column spacing provided, assume square pixels\n  if (!columnPixelSpacing) {\n    columnPixelSpacing = rowPixelSpacing;\n  }\n\n  calibratedPixelSpacingMetadataProvider.add(imageId, [\n    rowPixelSpacing,\n    columnPixelSpacing,\n  ]);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: Types.Point3;\n  pointLPS: Types.Point3;\n}) => void;\n\nexport type ShapeFnCriteria = (\n  pointIJK: Types.Point3,\n  pointLPS: Types.Point3\n) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): void {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n\n  for (let k = kMin; k <= kMax; k++) {\n    for (let j = jMin; j <= jMax; j++) {\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n        const dI = i - iMin;\n        const dJ = j - jMin;\n        const dK = k - kMin;\n\n        const startWorld = worldPosStart;\n\n        const pointLPS: Types.Point3 = [\n          startWorld[0] +\n            dI * rowStep[0] +\n            dJ * columnStep[0] +\n            dK * scanAxisStep[0],\n          startWorld[1] +\n            dI * rowStep[1] +\n            dJ * columnStep[1] +\n            dK * scanAxisStep[1],\n          startWorld[2] +\n            dI * rowStep[2] +\n            dJ * columnStep[2] +\n            dK * scanAxisStep[2],\n        ];\n\n        if (pointInShapeFn(pointLPS, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i;\n          const value = scalarData[index];\n\n          callback({ value, index, pointIJK, pointLPS });\n        }\n      }\n    }\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * With a given vertices (points) coordinates in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If dimensions are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates (IJK)\n * @param dimensions - dimensions of the image\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nfunction getBoundingBoxAroundShape(\n  points: Types.Point3[],\n  dimensions?: Types.Point3\n): [Types.Point2, Types.Point2, Types.Point2] {\n  let xMin = Infinity;\n  let xMax = 0;\n  let yMin = Infinity;\n  let yMax = 0;\n  let zMin = Infinity;\n  let zMax = 0;\n\n  points.forEach((p) => {\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n    zMin = Math.min(p[2], zMin);\n    zMax = Math.max(p[2], zMax);\n  });\n\n  xMin = Math.floor(xMin);\n  xMax = Math.floor(xMax);\n  yMin = Math.floor(yMin);\n  yMax = Math.floor(yMax);\n  zMin = Math.floor(zMin);\n  zMax = Math.floor(zMax);\n\n  if (dimensions) {\n    // clip the min, max to the provided width, height and depth\n    const [width, height, depth] = dimensions;\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(width - 1, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(height - 1, yMax);\n    zMin = Math.max(0, zMin);\n    zMax = Math.min(depth - 1, zMax);\n  }\n\n  return [\n    [xMin, xMax],\n    [yMin, yMax],\n    [zMin, zMax],\n  ];\n}\n\nexport default getBoundingBoxAroundShape;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * @param sphere - Sphere object with center and radius\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(\n  sphere: Sphere,\n  pointLPS: Types.Point3\n): boolean {\n  const { center, radius } = sphere;\n\n  return (\n    (pointLPS[0] - center[0]) ** 2 +\n      (pointLPS[1] - center[1]) ** 2 +\n      (pointLPS[2] - center[2]) ** 2 <=\n    radius ** 2\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInSurroundingSphereCallback } from '../../../utilities';\n\ntype OperationData = {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n  volume: Types.IImageVolume;\n  segmentIndex: number;\n  segmentationId: string;\n  segmentsLocked: number[];\n  viewPlaneNormal: Types.Point3;\n  viewUp: Types.Point3;\n  constraintFn: () => boolean;\n};\n\nfunction fillSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  _inside = true\n): void {\n  const { viewport } = enabledElement;\n  const {\n    volume: segmentation,\n    segmentsLocked,\n    segmentIndex,\n    segmentationId,\n    points,\n  } = operationData;\n\n  const { imageData, dimensions } = segmentation;\n  const scalarData = segmentation.getScalarData();\n  const scalarIndex = [];\n\n  const callback = ({ index, value }) => {\n    if (segmentsLocked.includes(value)) {\n      return;\n    }\n    scalarData[index] = segmentIndex;\n    scalarIndex.push(index);\n  };\n\n  pointInSurroundingSphereCallback(\n    imageData,\n    [points[0], points[1]],\n    callback,\n    viewport as Types.IVolumeViewport\n  );\n\n  // Since the scalar indexes start from the top left corner of the cube, the first\n  // slice that needs to be rendered can be calculated from the first mask coordinate\n  // divided by the zMultiple, as well as the last slice for the last coordinate\n  const zMultiple = dimensions[0] * dimensions[1];\n  const minSlice = Math.floor(scalarIndex[0] / zMultiple);\n  const maxSlice = Math.floor(scalarIndex[scalarIndex.length - 1] / zMultiple);\n  const sliceArray = Array.from(\n    { length: maxSlice - minSlice + 1 },\n    (v, k) => k + minSlice\n  );\n\n  triggerSegmentationDataModified(segmentationId, sliceArray);\n}\n\n/**\n * Fill inside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nexport function fillInsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillSphere(enabledElement, operationData, true);\n}\n\n/**\n * Fill outside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nexport function fillOutsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillSphere(enabledElement, operationData, false);\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { fillInsideSphere } from './fillSphere';\n\ntype OperationData = {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n  volume: Types.IImageVolume;\n  segmentIndex: number;\n  segmentationId: string;\n  segmentsLocked: number[];\n  viewPlaneNormal: Types.Point3;\n  viewUp: Types.Point3;\n  constraintFn: () => boolean;\n};\n\nexport function eraseInsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillInsideCircle functionality.\n  const eraseOperationData = Object.assign({}, operationData, {\n    segmentIndex: 0,\n  });\n\n  fillInsideSphere(enabledElement, eraseOperationData);\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype canvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: canvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Ellipse = {\n  center: Types.Point3;\n  xRadius: number;\n  yRadius: number;\n  zRadius: number;\n};\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse: Ellipse,\n  pointLPS: Types.Point3\n): boolean {\n  const { center: circleCenterWorld, xRadius, yRadius, zRadius } = ellipse;\n  const [x, y, z] = pointLPS;\n  const [x0, y0, z0] = circleCenterWorld;\n\n  let inside = 0;\n  if (xRadius !== 0) {\n    inside += ((x - x0) * (x - x0)) / (xRadius * xRadius);\n  }\n\n  if (yRadius !== 0) {\n    inside += ((y - y0) * (y - y0)) / (yRadius * yRadius);\n  }\n\n  if (zRadius !== 0) {\n    inside += ((z - z0) * (z - z0)) / (zRadius * zRadius);\n  }\n\n  return inside <= 1;\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport {\n  getCanvasEllipseCorners,\n  pointInEllipse,\n} from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInShapeCallback } from '../../../utilities';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype OperationData = {\n  segmentationId: string;\n  imageVolume: Types.IImageVolume;\n  points: any; // Todo:fix\n  volume: Types.IImageVolume;\n  segmentIndex: number;\n  segmentsLocked: number[];\n  viewPlaneNormal: number[];\n  viewUp: number[];\n  strategySpecificConfiguration: any;\n  constraintFn: () => boolean;\n};\n\nfunction fillCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  threshold = false\n): void {\n  const {\n    volume: segmentationVolume,\n    imageVolume,\n    points,\n    segmentsLocked,\n    segmentIndex,\n    segmentationId,\n    strategySpecificConfiguration,\n  } = operationData;\n  const { imageData, dimensions } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n  const { viewport } = enabledElement;\n\n  // Average the points to get the center of the ellipse\n  const center = vec3.fromValues(0, 0, 0);\n  points.forEach((point) => {\n    vec3.add(center, center, point);\n  });\n  vec3.scale(center, center, 1 / points.length);\n\n  const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n  // 1. From the drawn tool: Get the ellipse (circle) topLeft and bottomRight\n  // corners in canvas coordinates\n  const [topLeftCanvas, bottomRightCanvas] =\n    getCanvasEllipseCorners(canvasCoordinates);\n\n  // 2. Find the extent of the ellipse (circle) in IJK index space of the image\n  const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n  const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n\n  const ellipsoidCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, topLeftWorld),\n    <Types.Point3>transformWorldToIndex(imageData, bottomRightWorld),\n  ];\n\n  const boundsIJK = getBoundingBoxAroundShape(ellipsoidCornersIJK, dimensions);\n\n  if (boundsIJK.every(([min, max]) => min !== max)) {\n    throw new Error('Oblique segmentation tools are not supported yet');\n  }\n\n  // using circle as a form of ellipse\n  const ellipseObj = {\n    center: center as Types.Point3,\n    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n  };\n\n  const modifiedSlicesToUse = new Set() as Set<number>;\n\n  let callback;\n\n  if (threshold) {\n    callback = ({ value, index, pointIJK }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n\n      if (\n        isWithinThreshold(index, imageVolume, strategySpecificConfiguration)\n      ) {\n        scalarData[index] = segmentIndex;\n        //Todo: I don't think this will always be index 2 in streamingImageVolume?\n        modifiedSlicesToUse.add(pointIJK[2]);\n      }\n    };\n  } else {\n    callback = ({ value, index, pointIJK }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n      scalarData[index] = segmentIndex;\n      //Todo: I don't think this will always be index 2 in streamingImageVolume?\n      modifiedSlicesToUse.add(pointIJK[2]);\n    };\n  }\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n\n  const arrayOfSlices: number[] = Array.from(modifiedSlicesToUse);\n\n  triggerSegmentationDataModified(segmentationId, arrayOfSlices);\n}\n\nfunction isWithinThreshold(\n  index: number,\n  imageVolume: Types.IImageVolume,\n  strategySpecificConfiguration: any\n) {\n  const { THRESHOLD_INSIDE_CIRCLE } = strategySpecificConfiguration;\n\n  const voxelValue = imageVolume.getScalarData()[index];\n  const { threshold } = THRESHOLD_INSIDE_CIRCLE;\n\n  return threshold[0] <= voxelValue && voxelValue <= threshold[1];\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function fillInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillCircle(enabledElement, operationData, false);\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function thresholdInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  const { volume, imageVolume } = operationData;\n\n  if (\n    !csUtils.isEqual(volume.dimensions, imageVolume.dimensions) ||\n    !csUtils.isEqual(volume.direction, imageVolume.direction)\n  ) {\n    throw new Error(\n      'Only source data the same dimensions/size/orientation as the segmentation currently supported.'\n    );\n  }\n\n  fillCircle(enabledElement, operationData, true);\n}\n\n/**\n * Fill outside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels outside the  defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function fillOutsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  throw new Error('Not yet implemented');\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { fillInsideCircle } from './fillCircle';\n\ntype OperationData = {\n  segmentationId: string;\n  imageVolume: Types.IImageVolume;\n  points: any; // Todo:fix\n  volume: Types.IImageVolume;\n  segmentIndex: number;\n  segmentsLocked: number[];\n  viewPlaneNormal: number[];\n  viewUp: number[];\n  strategySpecificConfiguration: any;\n  constraintFn: () => boolean;\n};\n\nexport function eraseInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillInsideCircle functionality.\n  const eraseOperationData = {\n    ...operationData,\n    segmentIndex: 0,\n  };\n\n  fillInsideCircle(enabledElement, eraseOperationData);\n}\n","import { ToolGroupSpecificRepresentation } from '../../types/SegmentationStateTypes';\nimport { getDefaultSegmentationStateManager } from './segmentationState';\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the active segmentation representation for the tool group with\n * the given toolGroupId.\n * @param toolGroupId - The Id of the tool group\n * @returns The active segmentation representation for the tool group.\n */\nfunction getActiveSegmentationRepresentation(\n  toolGroupId: string\n): ToolGroupSpecificRepresentation {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const toolGroupSegmentationRepresentations =\n    segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const activeRepresentation = toolGroupSegmentationRepresentations.find(\n    (representation) => representation.active\n  );\n\n  return activeRepresentation;\n}\n\n/**\n * Set the active segmentation for the given tool group for all its viewports\n *\n * @param toolGroupId - The Id of the tool group to set the active\n * segmentation for.\n * @param segmentationRepresentationUID - The id of the segmentation representation to set as\n * active.\n */\nfunction setActiveSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  segmentationStateManager.setActiveSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  // get\n  getActiveSegmentationRepresentation,\n  // set\n  setActiveSegmentationRepresentation,\n};\n","import { getActiveSegmentationRepresentation } from './activeSegmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the locked status for a segment index in a segmentation\n * @param segmentationId - The id of the segmentation that the segment\n * belongs to.\n * @param segmentIndex - The index of the segment\n * @returns A boolean value indicating whether the segment is locked or not.\n */\nfunction isSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number\n): boolean {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return segmentsLocked.has(segmentIndex);\n}\n\n/**\n * Set the locked status of a segment index in a segmentation\n * @param segmentationId - The id of the segmentation whose segment\n * index is being modified.\n * @param segmentIndex - The index of the segment to lock/unlock.\n */\nfunction setSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number,\n  locked = true\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n\n  if (locked) {\n    segmentsLocked.add(segmentIndex);\n  } else {\n    segmentsLocked.delete(segmentIndex);\n  }\n\n  triggerSegmentationModified(segmentationId);\n}\n\n/**\n * Get the locked segments for a segmentation\n * @param segmentationId - The id of the segmentation to get locked\n * segments for.\n * @returns An array of locked segment indices.\n */\nfunction getLockedSegments(segmentationId: string): number[] | [] {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return Array.from(segmentsLocked);\n}\n\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\n","import { getSegmentation } from './segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Set the active segment index for a segmentation Id. It fires a global state\n * modified event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param segmentationId - The id of the segmentation that the segment belongs to.\n * @param segmentIndex - The index of the segment to be activated.\n */\nfunction setActiveSegmentIndex(\n  segmentationId: string,\n  segmentIndex: number\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation?.activeSegmentIndex !== segmentIndex) {\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    triggerSegmentationModified(segmentationId);\n  }\n}\n\n/**\n * Get the active segment index for a segmentation in the global state\n * @param segmentationId - The id of the segmentation to get the active segment index from.\n * @returns The active segment index for the given segmentation.\n */\nfunction getActiveSegmentIndex(segmentationId: string): number | undefined {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation) {\n    return segmentation.activeSegmentIndex;\n  }\n}\n\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\n","import { utilities } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { Color } from '../../../types/SegmentationStateTypes';\nimport { ColorLUT } from '../../../types/SegmentationStateTypes';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nimport { SegmentationRepresentations } from '../../../enums';\n\n/**\n * addColorLUT - Adds a new color LUT to the state at the given colorLUTIndex.\n * If no colorLUT is provided, a new color LUT is generated.\n *\n * @param colorLUTIndex - the index of the colorLUT in the state\n * @param colorLUT - An array of The colorLUT to set.\n * @returns\n */\nfunction addColorLUT(colorLUT: ColorLUT, colorLUTIndex: number): void {\n  if (!colorLUT) {\n    throw new Error('addColorLUT: colorLUT is required');\n  }\n\n  // Append the \"zero\" (no label) color to the front of the LUT, if necessary.\n  if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\n    console.warn(\n      'addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it'\n    );\n    colorLUT.unshift([0, 0, 0, 0]);\n  }\n\n  SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\n}\n\n/**\n * It sets the toolGroup's segmentationRepresentation to use the provided\n * colorLUT at the given colorLUTIndex.\n * @param toolGroupId - the id of the toolGroup that renders the representation\n * @param segmentationRepresentationUID - the representationUID for the segmentation\n * @param colorLUTIndex - the index of the colorLUT to use\n */\nfunction setColorLUT(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  colorLUTIndex: number\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    throw new Error(\n      `setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`\n    );\n  }\n\n  if (!SegmentationState.getColorLUT(colorLUTIndex)) {\n    throw new Error(\n      `setColorLUT: could not find colorLUT with index ${colorLUTIndex}`\n    );\n  }\n\n  segRepresentation.colorLUTIndex = colorLUTIndex;\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Given a tool group UID, a segmentation representationUID, and a segment index, return the\n * color for that segment. It can be used for segmentation tools that need to\n * display the color of their annotation.\n *\n * @param toolGroupId - The Id of the tool group that owns the segmentation representation.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment in the segmentation\n * @returns A color.\n */\nfunction getColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): Color {\n  const segmentationRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segmentationRepresentation) {\n    throw new Error(\n      `segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`\n    );\n  }\n\n  const { colorLUTIndex } = segmentationRepresentation;\n\n  // get colorLUT\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  return colorLUT[segmentIndex];\n}\n\nfunction setColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  color: Color\n): void {\n  // Get the reference to the color in the colorLUT.\n  const colorReference = getColorForSegmentIndex(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n\n  // Modify the values by reference\n  for (let i = 0; i < color.length; i++) {\n    colorReference[i] = color[i];\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  getColorForSegmentIndex,\n  addColorLUT,\n  setColorLUT,\n  setColorForSegmentIndex,\n};\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\n\nimport type { Types } from '@cornerstonejs/core';\nimport type {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BaseTool } from '../base';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport {\n  thresholdInsideCircle,\n  fillInsideCircle,\n} from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events, ToolModes } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  state as segmentationState,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\n/**\n * @public\n */\nclass BrushTool extends BaseTool {\n  static toolName;\n  private _editData: {\n    segmentation: Types.IImageVolume;\n    imageVolume: Types.IImageVolume; //\n    segmentsLocked: number[]; //\n  } | null;\n  private _hoverData?: {\n    brushCursor: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentationRepresentationUID: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    centerCanvas?: Array<number>;\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE_CIRCLE: fillInsideCircle,\n          THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n          ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n          FILL_INSIDE_SPHERE: fillInsideSphere,\n          ERASE_INSIDE_SPHERE: eraseInsideSphere,\n        },\n        strategySpecificConfiguration: {\n          THRESHOLD_INSIDE_CIRCLE: {\n            threshold: [-150, -70], // E.g. CT Fat // Only used during threshold strategies.\n          },\n        },\n        defaultStrategy: 'FILL_INSIDE_CIRCLE',\n        activeStrategy: 'FILL_INSIDE_CIRCLE',\n        brushSize: 25,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolPassive = () => {\n    this.disableCursor();\n  };\n\n  onSetToolEnabled = () => {\n    this.disableCursor();\n  };\n\n  onSetToolDisabled = () => {\n    this.disableCursor();\n  };\n\n  private disableCursor() {\n    this._hoverData = undefined;\n  }\n\n  preMouseDownCallback = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): boolean => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const { representationData } =\n      segmentationState.getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with this tool?\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n\n    const actors = viewport.getActors();\n\n    // Note: For tools that need the source data. Assumed to use\n    // First volume actor for now.\n    const firstVolumeActorUID = actors[0].uid;\n    const imageVolume = cache.getVolume(firstVolumeActorUID);\n\n    const viewportIdsToRender = [viewport.id];\n\n    this._editData = {\n      segmentation,\n      imageVolume,\n      segmentsLocked,\n    };\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    return true;\n  };\n\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    if (this.mode === ToolModes.Active) {\n      this.updateCursor(evt);\n    }\n  };\n\n  private updateCursor(evt: EventTypes.InteractionEventType) {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { currentPoints } = eventData;\n    const centerCanvas = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      console.warn(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n      return;\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const viewportIdsToRender = [viewport.id];\n\n    // Center of circle in canvas Coordinates\n\n    const brushCursor = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {},\n    };\n\n    this._hoverData = {\n      brushCursor,\n      centerCanvas,\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n      viewportIdsToRender,\n    };\n\n    this._calculateCursor(element, centerCanvas);\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { imageVolume, segmentation, segmentsLocked } = this._editData;\n\n    this.updateCursor(evt);\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n      viewportIdsToRender,\n    } = this._hoverData;\n\n    const { data } = brushCursor;\n    const { viewPlaneNormal, viewUp } = brushCursor.metadata;\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation, // todo: just pass the segmentationId instead\n      imageVolume,\n      segmentIndex,\n      segmentsLocked,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  private _calculateCursor(element, centerCanvas) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n    const { brushSize } = this.configuration;\n    // Center of circle in canvas Coordinates\n\n    const radius = brushSize;\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    const { brushCursor } = this._hoverData;\n    const { data } = brushCursor;\n\n    if (data.handles === undefined) {\n      data.handles = {};\n    }\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    data.invalidated = false;\n  }\n\n  private _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { imageVolume, segmentation, segmentsLocked } = this._editData;\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n    } = this._hoverData;\n\n    const { data } = brushCursor;\n    const { viewPlaneNormal, viewUp } = brushCursor.metadata;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this._editData = null;\n    this.updateCursor(evt);\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation,\n      imageVolume,\n      segmentIndex,\n      segmentsLocked,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  private _activateDraw = (element: HTMLDivElement): void => {\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  private _deactivateDraw = (element: HTMLDivElement): void => {\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  public invalidateBrushCursor() {\n    if (this._hoverData !== undefined) {\n      const { data } = this._hoverData.brushCursor;\n\n      data.invalidated = true;\n    }\n  }\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): void {\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return;\n    }\n\n    const brushCursor = this._hoverData.brushCursor;\n\n    if (brushCursor.data.invalidated === true) {\n      const { centerCanvas } = this._hoverData;\n      const { element } = viewport;\n\n      // This can be set true when changing the brush size programmatically\n      // whilst the cursor is being rendered.\n      this._calculateCursor(element, centerCanvas);\n    }\n\n    const toolMetadata = brushCursor.metadata;\n    const annotationUID = toolMetadata.brushCursorUID;\n\n    const data = brushCursor.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n  }\n}\n\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport getBoundingBoxAroundShape from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport default function getBrushToolInstances(toolGroupId) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = voxelCenter;\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShape(voxelCornersIJK, dimensions);\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing, imageData: segmentationImageData } =\n    segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    // Todo: make the segmentIndex a parameter\n    if (insert) scalarData[index] = 1;\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IStackViewport | Types.IVolumeViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IStackViewport | Types.IVolumeViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Annotations, Annotation } from '../../types';\nimport { debug } from 'console';\n\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * given some `Annotations`, and the slice defined by the camera's normal\n * direction and the spacing in the normal, filter the `Annotations` which\n * is within the slice.\n *\n * @param annotations - Annotations\n * @param camera - The camera\n * @param spacingInNormalDirection - The spacing in the normal direction\n * @returns The filtered `Annotations`.\n */\nexport default function filterAnnotationsWithinSlice(\n  annotations: Annotations,\n  camera: Types.ICamera,\n  spacingInNormalDirection: number\n): Annotations {\n  const { viewPlaneNormal } = camera;\n\n  // The reason we use parallel normals instead of actual orientation is that\n  // flipped action is done through camera API, so we can't rely on the\n  // orientation (viewplaneNormal and viewUp) since even the same image and\n  // same slice if flipped will have different orientation, but still rendering\n  // the same slice. Instead, we choose to use the parallel normals to filter\n  // the annotations and later we fine tune it with the annotation within slice\n  // logic down below.\n  const annotationsWithParallelNormals = annotations.filter(\n    (td: Annotation) => {\n      let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n      if (!annotationViewPlaneNormal) {\n        // This code is run to set the annotation view plane normal\n        // for historical data which was saved without the normal.\n        const { referencedImageId } = td.metadata;\n        const { imageOrientationPatient } = metaData.get(\n          'imagePlaneModule',\n          referencedImageId\n        );\n        const rowCosineVec = vec3.fromValues(\n          imageOrientationPatient[0],\n          imageOrientationPatient[1],\n          imageOrientationPatient[2]\n        );\n\n        const colCosineVec = vec3.fromValues(\n          imageOrientationPatient[3],\n          imageOrientationPatient[4],\n          imageOrientationPatient[5]\n        );\n\n        annotationViewPlaneNormal = vec3.create() as Types.Point3;\n\n        vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n        td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n      }\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      return annotationViewPlaneNormal && isParallel;\n    }\n  );\n\n  // No in plane annotations.\n  if (!annotationsWithParallelNormals.length) {\n    return [];\n  }\n\n  // Annotation should be within the slice, which means that it should be between\n  // camera's focalPoint +/- spacingInNormalDirection.\n\n  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n  const { focalPoint } = camera;\n\n  const annotationsWithinSlice = [];\n\n  for (const annotation of annotationsWithParallelNormals) {\n    const data = annotation.data;\n    const point = data.handles.points[0];\n\n    if (!annotation.isVisible) {\n      continue;\n    }\n    // A = point\n    // B = focal point\n    // P = normal\n\n    // B-A dot P  => Distance in the view direction.\n    // this should be less than half the slice distance.\n\n    const dir = vec3.create();\n\n    vec3.sub(dir, focalPoint, point);\n\n    const dot = vec3.dot(dir, viewPlaneNormal);\n\n    if (Math.abs(dot) < halfSpacingInNormalDirection) {\n      annotationsWithinSlice.push(annotation);\n    }\n  }\n\n  return annotationsWithinSlice;\n}\n","import {\n  StackViewport,\n  VolumeViewport,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport { Annotations } from '../../types';\n\n/**\n * Given the viewport and the annotations, it filters the annotations array and only\n * return those annotation that should be displayed on the viewport\n * @param annotations - Annotations\n * @returns A filtered version of the annotations.\n */\nexport default function filterAnnotationsForDisplay(\n  viewport: Types.IViewport,\n  annotations: Annotations\n): Annotations {\n  if (viewport instanceof StackViewport) {\n    // 1. Get the currently displayed imageId from the StackViewport\n    const imageId = viewport.getCurrentImageId();\n\n    // 2. remove the dataLoader scheme since it might be an annotation that was\n    // created on the volumeViewport initially and has the volumeLoader scheme\n    // but shares the same imageId\n    const colonIndex = imageId.indexOf(':');\n    const imageURI = imageId.substring(colonIndex + 1);\n\n    // 3. Filter annotation in the frame of reference by the referenced image ID property\n    // Note: With the current implementation drawing on the stack (PT stack) will not\n    // show the annotation on a volume that does not share the same imageURIs (CT Volume),\n    // and we don't have a proper way to check distance either since a stack can be\n    // composed of multiple unrelated images\n    return annotations.filter((annotation) => {\n      if (!annotation.isVisible) {\n        return false;\n      }\n\n      const imageId = annotation.metadata.referencedImageId;\n\n      if (imageId === undefined) {\n        // This annotation was not drawn on a non-coplanar reformat, and such does\n        // note have a referenced imageId.\n        return false;\n      }\n\n      const colonIndex = imageId.indexOf(':');\n      const referenceImageURI = imageId.substring(colonIndex + 1);\n      return referenceImageURI === imageURI;\n    });\n  } else if (viewport instanceof VolumeViewport) {\n    const camera = viewport.getCamera();\n\n    const { spacingInNormalDirection } =\n      csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n    // Get data with same normal and within the same slice\n    return filterAnnotationsWithinSlice(\n      annotations,\n      camera,\n      spacingInNormalDirection\n    );\n  } else {\n    throw new Error(`Viewport Type ${viewport.type} not supported`);\n  }\n}\n","import { Annotation } from '../../../types';\nimport { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\n\n/**\n * Given a Annotation object, return the annotationStyle State that it\n * should be in based on its data\n * @param annotation - The annotation that we want to style.\n * @returns The state of the annotation whether it is Default, Highlighted, Locked, or Selected.\n */\nfunction getState(annotation?: Annotation): AnnotationStyleStates {\n  if (annotation) {\n    if (annotation.data && annotation.highlighted)\n      return AnnotationStyleStates.Highlighted;\n    if (isAnnotationSelected(annotation.annotationUID))\n      return AnnotationStyleStates.Selected;\n\n    // Todo: make annotation lock api not to rely on the annotation itself\n    if (isAnnotationLocked(annotation)) return AnnotationStyleStates.Locked;\n  }\n\n  return AnnotationStyleStates.Default;\n}\n\nexport default getState;\n","import {\n  utilities,\n  getEnabledElement,\n  VolumeViewport,\n  StackViewport,\n  cache,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec4 } from 'gl-matrix';\n\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport { Annotation, Annotations, SVGDrawingHelper } from '../../types';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationDisplayTool extends BaseTool {\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  /**\n   * @abstract renderAnnotation it used to draw the tool's annotation in each\n   * request animation frame\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  abstract renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  );\n\n  /**\n   * @virtual Given the element and annotations which is an array of annotation, it\n   * filters the annotations array to only include the annotation based on the viewportType.\n   * If the viewport is StackViewport, it filters based on the current imageId of the viewport,\n   * if the viewport is volumeViewport, it only returns those that are within the\n   * same slice as the current rendered slice in the volume viewport.\n   * imageId as the enabledElement.\n   * @param element - The HTML element\n   * @param annotations - The annotations to filter (array of annotation)\n   * @returns The filtered annotations\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    return filterAnnotationsForDisplay(viewport, annotations);\n  }\n\n  /**\n   * On Image Calibration, take all the annotation from the AnnotationState manager,\n   * and invalidate them to force them to be re-rendered and their stats to be recalculated.\n   * Then use the old and new imageData (non-calibrated and calibrated) to calculate the\n   * new position for the annotations in the space of the new imageData.\n   *\n   * @param evt - The calibration event\n   *\n   */\n  public onImageSpacingCalibrated = (\n    evt: Types.EventTypes.ImageSpacingCalibratedEvent\n  ) => {\n    const {\n      element,\n      rowScale,\n      columnScale,\n      imageId,\n      imageData: calibratedImageData,\n      worldToIndex: noneCalibratedWorldToIndex,\n    } = evt.detail;\n\n    const { viewport } = getEnabledElement(element);\n\n    if (viewport instanceof VolumeViewport) {\n      throw new Error('Cannot calibrate a volume viewport');\n    }\n\n    const calibratedIndexToWorld = calibratedImageData.getIndexToWorld();\n\n    const imageURI = utilities.imageIdToURI(imageId);\n    const stateManager = getAnnotationManager();\n    const framesOfReference = stateManager.getFramesOfReference();\n\n    // For each frame Of Reference\n    framesOfReference.forEach((frameOfReference) => {\n      const frameOfReferenceSpecificAnnotations =\n        stateManager.getAnnotations(frameOfReference);\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[this.getToolName()];\n\n      if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n        return;\n      }\n\n      // for this specific tool\n      toolSpecificAnnotations.forEach((annotation) => {\n        // if the annotation is drawn on the same imageId\n        const referencedImageURI = utilities.imageIdToURI(\n          annotation.metadata.referencedImageId\n        );\n\n        if (referencedImageURI === imageURI) {\n          // make them invalid since the image has been calibrated so that\n          // we can update the cachedStats and also rendering\n          annotation.invalidated = true;\n          annotation.data.cachedStats = {};\n\n          // Update annotation points to the new calibrated points. Basically,\n          // using the worldToIndex function we get the index on the non-calibrated\n          // image and then using the calibratedIndexToWorld function we get the\n          // corresponding point on the calibrated image world.\n          annotation.data.handles.points = annotation.data.handles.points.map(\n            (point) => {\n              const p = vec4.fromValues(...(point as Types.Point3), 1);\n              const pCalibrated = vec4.fromValues(0, 0, 0, 1);\n              const nonCalibratedIndexVec4 = vec4.create();\n              vec4.transformMat4(\n                nonCalibratedIndexVec4,\n                p,\n                noneCalibratedWorldToIndex\n              );\n              const calibratedIndex = [\n                columnScale * nonCalibratedIndexVec4[0],\n                rowScale * nonCalibratedIndexVec4[1],\n                nonCalibratedIndexVec4[2],\n              ];\n\n              vec4.transformMat4(\n                pCalibrated,\n                vec4.fromValues(\n                  calibratedIndex[0],\n                  calibratedIndex[1],\n                  calibratedIndex[2],\n                  1\n                ),\n                calibratedIndexToWorld\n              );\n\n              return pCalibrated.slice(0, 3) as Types.Point3;\n            }\n          );\n        }\n      });\n\n      triggerAnnotationRender(element);\n    });\n  };\n\n  protected getReferencedImageId(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      const volumeId = targetId.split('volumeId:')[1];\n      const imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = utilities.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal,\n        viewUp\n      );\n    }\n\n    return referencedImageId;\n  }\n\n  /**\n   * It takes the property (color, lineDash, etc.) and based on the state of the\n   * annotation (selected, highlighted etc.) it returns the appropriate value\n   * based on the central toolStyle settings for each level of specification.\n   * @param property - The name of the style property to get.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns The value of the property.\n   */\n  public getStyle(\n    property: string,\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): unknown {\n    return getStyleProperty(\n      property,\n      specifications,\n      getState(annotation),\n      this.mode\n    );\n  }\n}\n\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points, textBox } = data.handles;\n    const { worldBoundingBox } = textBox;\n\n    if (worldBoundingBox) {\n      const canvasBoundingBox = {\n        topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n        topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n        bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n        bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n      };\n\n      if (\n        canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n        canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n        canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n        canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n      ) {\n        data.handles.activeHandleIndex = null;\n        return textBox;\n      }\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { Types } from '@cornerstonejs/core';\n\nfunction dist2(p1: Types.Point2, p2: Types.Point2): number {\n  return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\n}\n\n/**\n * Calculates the distance-squared of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  const d2 = dist2(lineStart, lineEnd);\n\n  if (d2 === 0) {\n    return dist2(point, lineStart);\n  }\n\n  const t =\n    ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n      (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n    d2;\n\n  if (t < 0) {\n    return dist2(point, lineStart);\n  }\n  if (t > 1) {\n    return dist2(point, lineEnd);\n  }\n\n  const pt: Types.Point2 = [\n    lineStart[0] + t * (lineEnd[0] - lineStart[0]),\n    lineStart[1] + t * (lineEnd[1] - lineStart[1]),\n  ];\n\n  return dist2(point, pt);\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined\n * by a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates\n * of the rectangle defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param topLeftWorld - The first world position.\n * @param bottomRightWorld - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromCorners(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  topLeftWorld: Types.Point3,\n  bottomRightWorld: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...topLeftWorld);\n  const pos2 = vec3.fromValues(...bottomRightWorld);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","function getModalityUnit(modality: string, isPreScaled: boolean): string {\n  if (modality === 'CT') {\n    return 'HU';\n  } else if (modality === 'PT' && isPreScaled === true) {\n    return 'SUV';\n  } else {\n    return '';\n  }\n}\n\nexport { getModalityUnit };\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const volumeId = targetId.split('volumeId:')[1];\n    const volume = cache.getVolume(volumeId);\n    return volume.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData();\n    return preScale.scaled;\n  } else {\n    throw new Error('Viewport is not a valid type');\n  }\n}\n\nexport { isViewportPreScaled };\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  ToolProps,\n  PublicToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * RectangleROIAnnotation let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of a Rectangular region of interest.\n * You can use RectangleROIAnnotation in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. RectangleROI tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(RectangleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(RectangleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(RectangleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\nclass RectangleROITool extends AnnotationTool {\n  static toolName;\n\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a RectangleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): RectangleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: RectangleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]];\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point as Types.Point2\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - Move the text boxes world position\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventDetail;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit === undefined\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-rect`;\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      const isPreScaled = isViewportPreScaled(viewport, targetId);\n\n      const textLines = this._getTextLines(data, targetId, isPreScaled);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  /**\n   * _getTextLines - Returns the Area, mean and std deviation of the area of the\n   * target volume enclosed by the rectangle.\n   *\n   * @param data - The annotation tool-specific data.\n   * @param targetId - The volumeId of the volume to display the stats for.\n   * @param isPreScaled - Whether the viewport is pre-scaled or not.\n   */\n  _getTextLines = (\n    data,\n    targetId: string,\n    isPreScaled: boolean\n  ): string[] | undefined => {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, max, stdDev, Modality, areaUnit } = cachedVolumeStats;\n\n    if (mean === undefined) {\n      return;\n    }\n\n    const textLines: string[] = [];\n    const unit = getModalityUnit(Modality, isPreScaled);\n\n    textLines.push(`Area: ${area.toFixed(2)} ${areaUnit}\\xb2`);\n    textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n    textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n    textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n\n    return textLines;\n  };\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param data - The annotation tool-specific data.\n   * @param viewPlaneNormal - The normal vector of the camera.\n   * @param viewUp - The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const area = Math.abs(worldWidth * worldHeight);\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n        let max = -Infinity;\n\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        //Todo: this can be replaced by pointInShapeCallback....\n        // This is a triple loop, but one of these 3 values will be constant\n        // In the planar view.\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              if (value > max) {\n                max = value;\n              }\n\n              count++;\n              mean += value;\n            }\n          }\n        }\n\n        mean /= count;\n\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              const valueMinusMean = value - mean;\n\n              stdDev += valueMinusMean * valueMinusMean;\n            }\n          }\n        }\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          stdDev,\n          max,\n          areaUnit: hasPixelSpacing ? 'mm' : 'px',\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { Events } from '../../enums';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = targetId.split('volumeId:')[1];\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal,\n        viewUp\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngineId } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId: viewport.id,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  metaData,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = targetId.split('volumeId:')[1];\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal,\n        viewUp\n      );\n    }\n\n    if (!referencedImageId) {\n      throw new Error('This tool does not work on non-acquisition planes');\n    }\n\n    const startIndex = viewport.getCurrentImageIdIndex();\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startSlice: startIndex,\n        endSlice: endIndex,\n        cachedStats: {\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n        },\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n\n    // Find the imageIds for the projection points\n    const projectionPointsImageIds = [];\n    for (const RectanglePoints of newProjectionPoints) {\n      const imageId = csUtils.getClosestImageId(\n        imageVolume,\n        RectanglePoints[0],\n        viewPlaneNormal,\n        metadata.viewUp\n      );\n      projectionPointsImageIds.push(imageId);\n    }\n\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const volumeId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(volumeId.split('volumeId:')[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, endPos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport getBoundingBoxAroundShape from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import { _cloneDeep } from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId?: string;\n    scalarData?: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer?: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata?: any;\n    dimensions?: Types.Point3;\n    spacing?: Types.Point3;\n    origin?: Types.Point3;\n    direction?: Float32Array;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = _cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.\n *\n * @param {function} getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param {number[]} seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param {function} [options.onFlood] An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param {function} [options.onBoundary] An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param {function} [options.equals] An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param {boolean} [options.diagonals] Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns {Object}\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals || defaultEquals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = {};\n  const bounds = {};\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  function visited(key) {\n    return visits[key] === true;\n  }\n\n  function markAsVisited(key) {\n    visits[key] = true;\n  }\n\n  function member(getArgs) {\n    const node = safely(get, [getArgs]);\n\n    return safely(equals, [node, startNode]);\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    bounds[prevArgs] = prevArgs;\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  function safely(f, args) {\n    try {\n      return f(...args);\n    } catch (error) {\n      return;\n    }\n  }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = [];\n\n    for (const key in bounds) {\n      if (bounds[key] !== undefined) {\n        array.unshift(bounds[key]);\n      }\n    }\n\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushSizeForToolGroup(toolGroupId: string): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD_INSIDE_CIRCLE.threshold =\n      threshold;\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  if (!viewportsInfo.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfo[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the\n  return brushToolInstance.configuration.strategySpecificConfiguration\n    .THRESHOLD_INSIDE_CIRCLE.threshold;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.VolumeScalarData,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.VolumeScalarData,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) return num < 0;\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) return 0;\n    if (t > tE) c[0] = t;\n  } else {\n    if (t < tE) return 0;\n    if (t < tL) c[1] = t;\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Orientation algoritm to determine if two lines cross.\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n */\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n */\nfunction getFirstIntersectionWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n */\nfunction getClosestIntersectionWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  const intersections = [];\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      intersections.push([j, i]);\n    }\n\n    j = i;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an orientation algorithm.\n */\nfunction doesIntersect(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport { getFirstIntersectionWithPolyline, getClosestIntersectionWithPolyline };\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewPlaneNormalDotI = Math.abs(vec3.dot(viewPlaneNormal, iVector));\n    const absViewPlaneNormalDotJ = Math.abs(vec3.dot(viewPlaneNormal, jVector));\n    const absViewPlaneNormalDotK = Math.abs(vec3.dot(viewPlaneNormal, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewPlaneNormalDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewPlaneNormalDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewPlaneNormalDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function calculateAreaOfPoints(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y of the point\n * @param p2 - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  p1: Types.Point2,\n  p2: Types.Point2\n): number {\n  if (p1?.length !== 2 || p2?.length !== 2) {\n    throw Error('points should have 2 elements of [x, y]');\n  }\n\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n/**\n * Returns a point based on some criteria (e.g., minimum or maximum intensity) in\n * the line of sight (on the line between the passed worldPosition and camera position).\n * It iterated over the points with a step size on the line.\n *\n * @param viewport - Volume viewport\n * @param worldPos - World coordinates of the clicked location\n * @param targetVolumeId - target Volume ID in the viewport\n * @param criteriaFunction - A function that returns the point if it passes a certain\n * written logic, for instance, it can be a maxValue function that keeps the\n * records of all intensity values, and only return the point if its intensity\n * is greater than the maximum intensity of the points passed before.\n * @param stepsSize - Percentage of the spacing in the normal direction, default value\n * is 0.25 which means steps = 1/4 of the spacing in the normal direction.\n * @returns the World pos of the point that passes the criteriaFunction\n */\nexport default function getPointInLineOfSightWithCriteria(\n  viewport: Types.IVolumeViewport,\n  worldPos: Types.Point3,\n  targetVolumeId: string,\n  criteriaFunction: (intensity: number, point: Types.Point3) => Types.Point3,\n  stepSize = 0.25\n): Types.Point3 {\n  // 1. Getting the camera from the event details\n  const camera = viewport.getCamera();\n  const { position: cameraPosition } = camera;\n\n  // 2. Calculating the spacing in the normal direction, this will get\n  // used as the step size for iterating over the points in the line of sight\n  const { spacingInNormalDirection } =\n    csUtils.getTargetVolumeAndSpacingInNormalDir(\n      viewport,\n      camera,\n      targetVolumeId\n    );\n  // 2.1 Making sure, we are not missing any point\n  const step = spacingInNormalDirection * stepSize;\n\n  // 3. Getting the bounds of the viewports. Search for brightest point is\n  // limited to the visible bound\n  // Todo: this might be a problem since bounds will change to spatial bounds.\n  const bounds = viewport.getBounds();\n  const xMin = bounds[0];\n  const xMax = bounds[1];\n\n  // 5. Calculating the line, we use a parametric line definition\n  const vector = <Types.Point3>[0, 0, 0];\n\n  // 5.1 Point coordinate on the line\n  let point = <Types.Point3>[0, 0, 0];\n\n  // 5.2 Calculating the line direction, and storing in vector\n  vtkMath.subtract(worldPos, cameraPosition, vector);\n\n  let pickedPoint;\n\n  // 6. Iterating over the line from the lower bound to the upper bound, with the\n  // specified step size\n  for (let pointT = xMin; pointT <= xMax; pointT = pointT + step) {\n    // 6.1 Calculating the point x location\n    point = [pointT, 0, 0];\n    // 6.2 Calculating the point y,z location based on the line equation\n    const t = (pointT - cameraPosition[0]) / vector[0];\n    point[1] = t * vector[1] + cameraPosition[1];\n    point[2] = t * vector[2] + cameraPosition[2];\n\n    // 6.3 Checking if the points is inside the bounds\n    if (_inBounds(point, bounds)) {\n      // 6.4 Getting the intensity of the point\n      const intensity = viewport.getIntensityFromWorld(point);\n      // 6.5 Passing the intensity to the maximum value functions which decides\n      // whether the current point is of interest based on some criteria\n      const pointToPick = criteriaFunction(intensity, point);\n      if (pointToPick) {\n        pickedPoint = pointToPick;\n      }\n    }\n  }\n\n  return pickedPoint;\n}\n\n/**\n * Returns whether the point in the world is inside the bounds of the viewport\n * @param point - coordinates in the world\n * @returns boolean\n */\nconst _inBounds = function (\n  point: Types.Point3,\n  bounds: Array<number>\n): boolean {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  return (\n    point[0] > xMin &&\n    point[0] < xMax &&\n    point[1] > yMin &&\n    point[1] < yMax &&\n    point[2] > zMin &&\n    point[2] < zMax\n  );\n};\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n};\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst loop = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, isDynamicCinePlaying);\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, isDynamicCinePlaying);\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement): void {\n  _stopClip(element, true);\n}\n\nfunction _stopClip(element: HTMLDivElement, stopDynamicCine: boolean): void {\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) return;\n  const { viewport } = enabledElement;\n  const cineToolData = getToolState(viewport.element);\n\n  if (cineToolData) {\n    _stopClipWithData(cineToolData);\n  }\n\n  if (stopDynamicCine) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const actorEntry = viewport.getDefaultActor();\n\n  if (!actorEntry) {\n    // This can happen during setup/teardown of viewports.\n    return;\n  }\n\n  const volumeId = actorEntry.uid;\n  return cache.getVolume(volumeId);\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    scroll(delta: number): void {\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(viewport);\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","export function basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nexport default function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n","import min from \"./min.js\";\n\nexport default function transpose(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n","export default function min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","import { Types } from '@cornerstonejs/core';\nimport { interpolatePoints } from './algorithms/bspline';\n\n/**\n * Returns a list of uniform distributed values. This list contains the max amount of values which has at least a minimum distance between two consecutive values.\n * minDistributionDistance means the min distance between two consecutive distributed values.\n * Closed interval contains the min/max values.\n *\n * Formula for reference\n * For given {x  R | x  0} and {minDis  R | minDis  0},  D(x) where D(x)  a and D(x)  b  =>\n *         |\n * D(x)  = |                  (b - a)\n *         |  round( ------------------------ * x  )   + a\n *         |                (b - a + 1)\n *         |        round( -----------  )\n *         |                 minDis\n */\nfunction getContinuousUniformDistributionValues(\n  minDistributionDistance: number,\n  closedInterval: [number, number]\n): number[] {\n  const result = [];\n  const [intervalIni, intervalEnd] = closedInterval;\n\n  const intervalSize = intervalEnd - intervalIni + 1;\n  const intensity = Math.floor(intervalSize / minDistributionDistance);\n\n  let x = 0;\n  let continuosDistributionValue =\n    Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n\n  while (continuosDistributionValue <= intervalEnd) {\n    result.push(continuosDistributionValue);\n    x++;\n    continuosDistributionValue =\n      Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n  }\n\n  return result;\n}\n\n/**\n * Interpolates a segment of points from iniIndex until endIndex.\n * The process of interpolation considers the param knotsRatioPercentage as being the percentage of points from Segment that are likely to be considered.\n * By default it uses b-spline algorithm.\n * The result total of points is equal to original points.\n */\nexport default function interpolateSegmentPoints(\n  points: (Types.Point2 | Types.Point3)[],\n  iniIndex: number,\n  endIndex: number,\n  knotsRatioPercentage: number\n): (Types.Point2 | Types.Point3)[] {\n  const segmentSize = endIndex - iniIndex + 1;\n\n  const amountOfKnots =\n    Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n  const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n\n  if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n    return points;\n  }\n\n  // segment should be at least the double of desired minKnot distance. This will ensure at there will enough knots to interpolate.\n  if (segmentSize / minKnotDistance < 2) {\n    return points;\n  }\n\n  const interpolationIniIndex = Math.max(0, iniIndex);\n  const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n  const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n\n  const segmentPointsUnchangedEnd = points.slice(\n    interpolationEndIndex + 1,\n    points.length\n  );\n\n  const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n    interpolationIniIndex,\n    interpolationEndIndex,\n  ]);\n\n  const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n\n  return [\n    ...segmentPointsUnchangedBeg,\n    ...interpolatedPoints,\n    ...segmentPointsUnchangedEnd,\n  ];\n}\n","import {\n  interpolateBasis as d3InterpolateBasis,\n  quantize as d3Quantize,\n} from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nimport { Types } from '@cornerstonejs/core';\n\nfunction isPoints3D(\n  points: (Types.Point2 | Types.Point3)[]\n): points is Types.Point3[] {\n  return (points as Types.Point3[])[0]?.length === 3;\n}\n\n/**\n * Returns an array of the originalPoints length containing the interpolated data.\n * It interpolates a set of points indexed by knotsIndexes.\n * That is, it DISCARDS all points except those in knotsIndexes. Then, a new set of points is created by using a b-spline on the remaining points, in order to re-create a new set of points.\n */\nexport function interpolatePoints(\n  originalPoints: (Types.Point2 | Types.Point3)[],\n  knotsIndexes: number[]\n): (Types.Point2 | Types.Point3)[] {\n  if (\n    !knotsIndexes ||\n    knotsIndexes.length === 0 ||\n    knotsIndexes.length === originalPoints.length\n  ) {\n    return originalPoints;\n  }\n\n  const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n  const xInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][0])\n  );\n  const yInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][1])\n  );\n\n  if (isPoints3D(originalPoints)) {\n    const zInterpolator = d3InterpolateBasis(\n      knotsIndexes.map((k) => originalPoints[k][2])\n    );\n    return <Types.Point3[]>(\n      d3Zip(\n        d3Quantize(xInterpolator, n),\n        d3Quantize(yInterpolator, n),\n        d3Quantize(zInterpolator, n)\n      )\n    );\n  } else {\n    return <Types.Point2[]>(\n      d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n))\n    );\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nexport function shouldInterpolate(configuration: Record<any, any>): boolean {\n  return (\n    configuration?.interpolation?.interpolateOnAdd === true ||\n    configuration?.interpolation?.interpolateOnEdit === true\n  );\n}\n\n/**\n * Tells whether two points are equal by proximity or not as far as interpolation goes.\n */\nfunction isEqualByProximity(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) < 0.001;\n}\n\n/**\n * Tells whether two points are strictly equal or not as far as interpolation goes.\n */\nfunction isEqual(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) === 0;\n}\n\n/**\n * Finds the indexes of points list and otherPoints list that points are identical.\n */\nfunction findMatchIndexes(\n  points: Types.Point2[],\n  otherPoints: Types.Point2[]\n): [number, number] | undefined {\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < otherPoints.length; j++) {\n      if (isEqual(points[i], otherPoints[j])) {\n        return [i, j];\n      }\n    }\n  }\n}\n/**\n * Returns the following index value (on circular basis) of index param on the given direction.\n */\nfunction followingIndex(\n  index: number,\n  size: number,\n  direction: number\n): number {\n  return (index + size + direction) % size;\n}\n/**\n * Array of params to be used on circular find next index.\n * The values respresent start index, indexDelimiter, list of points\n */\ntype ListParamsType = [number, number, Types.Point2[]];\n\n/**\n * Circular finding that returns the next index for two list where the criteria is met.\n *\n * It can compare two lists out of sync considering it does a circular iteration over them.\n *\n * @example\n *\n * ```\n * const pointsA = [[0, 1], [1, 3], [1, 5], [1,2]];\n * const pointsB = [[1, 2], [1, 5], [1, 3], [0,0]];\n * let firstParam = [0, 0, pointsA]\n * let secondParam = [1, 1, pointsB]\n * const criteria = (pointA, pointB) => areSamePosition(pointA, pointB)\n * const direction = 1;\n * let result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * console.log(result);\n * // prints [1, 2]\n * // use this result and find again\n * firstParam = [result[0]+1, result[0], pointsA]\n * secondParam = [result[1]+1, result[1], pointsB]\n * result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * * // prints [3, 0]\n *\n */\nfunction circularFindNextIndexBy(\n  listParams: ListParamsType,\n  otherListParams: ListParamsType,\n  criteria: (pointA: Types.Point2, pointB: Types.Point2) => boolean,\n  direction: number\n): [number | undefined, number | undefined] {\n  const [, indexDelimiter, points] = listParams;\n  const [, otherIndexDelimiter, otherPoints] = otherListParams;\n\n  const pointsLength = points.length;\n  const otherPointsLength = otherPoints.length;\n\n  let startIndex = listParams[0];\n  let otherStartIndex = otherListParams[0];\n\n  if (\n    !points[startIndex] ||\n    !otherPoints[otherStartIndex] ||\n    !points[indexDelimiter] ||\n    !otherPoints[otherIndexDelimiter]\n  ) {\n    return [undefined, undefined];\n  }\n\n  while (\n    startIndex !== indexDelimiter &&\n    otherStartIndex !== otherIndexDelimiter\n  ) {\n    if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n      return [startIndex, otherStartIndex];\n    }\n\n    startIndex = followingIndex(startIndex, pointsLength, direction);\n    otherStartIndex = followingIndex(\n      otherStartIndex,\n      otherPointsLength,\n      direction\n    );\n  }\n\n  return [undefined, undefined];\n}\n\n/**\n * Given two list it will find the first and last index of segment from points that diverges from previousPoints\n */\nfunction findChangedSegment(\n  points: Types.Point2[],\n  previousPoints: Types.Point2[]\n): [number, number] {\n  const [firstMatchIndex, previousFirstMatchIndex] =\n    findMatchIndexes(points, previousPoints) || [];\n\n  const toBeNotEqualCriteria = (pointA, pointB) =>\n    isEqualByProximity(pointA, pointB) === false;\n\n  const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy(\n    [\n      followingIndex(firstMatchIndex, points.length, 1),\n      firstMatchIndex,\n      points,\n    ],\n    [\n      followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n      previousFirstMatchIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    1\n  );\n\n  const [highIndex] = circularFindNextIndexBy(\n    [followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points],\n    [\n      followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n      lowOtherDiffIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    -1\n  );\n\n  return [lowDiffIndex, highIndex];\n}\n\n/**\n * Interpolates the given list of points. In case there is a pointsOfReference the interpolation will occur only on segment disjoint of two list. I.e list of points from param points that are not on list of points from param pointsOfReference.\n */\nexport function getInterpolatedPoints(\n  configuration: Record<any, any>,\n  points: Types.Point2[],\n  pointsOfReference?: Types.Point2[]\n): Types.Point2[] {\n  const { interpolation } = configuration;\n\n  const result = points;\n\n  if (interpolation) {\n    const {\n      knotsRatioPercentageOnAdd,\n      knotsRatioPercentageOnEdit,\n      interpolateOnAdd = false,\n      interpolateOnEdit = false,\n    } = interpolation;\n\n    const knotsRatioPercentage = pointsOfReference\n      ? knotsRatioPercentageOnEdit\n      : knotsRatioPercentageOnAdd;\n    const isEnabled = pointsOfReference ? interpolateOnEdit : interpolateOnAdd;\n\n    if (isEnabled) {\n      // partial or total interpolation\n      const [changedIniIndex, changedEndIndex] = pointsOfReference\n        ? findChangedSegment(points, pointsOfReference)\n        : [0, points.length - 1];\n\n      // do not interpolate if there is no valid segment\n      if (!points[changedIniIndex] || !points[changedEndIndex]) {\n        return points;\n      }\n\n      return <Types.Point2[]>(\n        interpolateSegmentPoints(\n          points,\n          changedIniIndex,\n          changedEndIndex,\n          knotsRatioPercentage\n        )\n      );\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Finds the length of the longest line from the midpoint of the line\n * that joins the start and end of the open contour, to the surface of the\n * open contour.\n */\nexport default function findOpenUShapedContourVectorToPeak(\n  canvasPoints: Types.Point2[],\n  viewport: Types.IStackViewport | Types.IVolumeViewport\n): Types.Point3[] {\n  // Find chord from first to last point.\n  const first = canvasPoints[0];\n  const last = canvasPoints[canvasPoints.length - 1];\n\n  const firstToLastUnitVector = vec2.create();\n\n  vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n  vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n\n  // Get the two possible normal vector to this vector\n  // Note: Use the identity that the perpendicular line must have a gradient of\n  // 1 / gradient of the line.\n\n  const normalVector1 = vec2.create();\n  const normalVector2 = vec2.create();\n\n  vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n  vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n\n  // Find the center of the chord.\n  const centerOfFirstToLast: Types.Point2 = [\n    (first[0] + last[0]) / 2,\n    (first[1] + last[1]) / 2,\n  ];\n\n  // Get furthest point.\n\n  const furthest = {\n    dist: 0,\n    index: null,\n  };\n\n  for (let i = 0; i < canvasPoints.length; i++) {\n    const canvasPoint = canvasPoints[i];\n\n    const distance = vec2.dist(canvasPoint, <vec2>centerOfFirstToLast);\n\n    if (distance > furthest.dist) {\n      furthest.dist = distance;\n      furthest.index = i;\n    }\n  }\n\n  const toFurthest: [Types.Point2, Types.Point2] = [\n    canvasPoints[furthest.index],\n    centerOfFirstToLast,\n  ];\n  const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n\n  return toFurthestWorld;\n}\n\nexport function findOpenUShapedContourVectorToPeakOnRender(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): Types.Point3[] {\n  const { viewport } = enabledElement;\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { Events } from '../../../enums';\nimport { EventTypes } from '../../../types';\nimport { state } from '../../../store';\nimport { vec3 } from 'gl-matrix';\nimport {\n  shouldInterpolate,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\n\nconst {\n  addCanvasPointsToArray,\n  pointsAreWithinCloseContourProximity,\n  getFirstIntersectionWithPolyline,\n  getSubPixelSpacingAndXYDirections,\n} = polyline;\n\n/**\n * Activates the contour drawing event loop.\n */\nfunction activateDraw(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.drawData = {\n    canvasPoints: [canvasPos],\n    polylineIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n/**\n * Dectivates and cleans up the contour drawing event loop.\n */\nfunction deactivateDraw(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to a set of preview canvas points of the contour being created.\n * Checks if crossing of lines means early completion and editing needs to be started.\n */\nfunction mouseDragDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { polylineIndex, canvasPoints } = this.drawData;\n\n  const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n\n  if (crossingIndex !== undefined) {\n    // If we have crossed our drawing line, create a closed contour and then\n    // start an edit.\n    this.applyCreateOnCross(evt, crossingIndex);\n  } else {\n    const numPointsAdded = addCanvasPointsToArray(\n      element,\n      canvasPoints,\n      canvasPos,\n      this.commonData\n    );\n\n    this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the contour on mouse up. If the `allowOpenContours` configuration\n * option is `true`, checks if we should create an open or closed contour.\n * If the `allowOpenContours` configuration option is `false`, always creates a\n * closed contour.\n */\nfunction mouseUpDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element);\n  } else {\n    this.completeDrawClosedContour(element);\n  }\n}\n\n/**\n * Completes the contour being drawn, creating a closed contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawClosedContour(element: HTMLDivElement): boolean {\n  this.removeCrossedLinesOnCompleteDraw();\n  const { canvasPoints } = this.drawData;\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  // Convert annotation to world coordinates\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[0],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  const updatedPoints = shouldInterpolate(this.configuration)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n  const worldPoints = updatedPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = false;\n\n  this.triggerAnnotationCompleted(annotation);\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * If lines are crossed during the draw loop, remove the points drawn over the\n * crossing.\n */\nfunction removeCrossedLinesOnCompleteDraw(): void {\n  const { canvasPoints } = this.drawData;\n  const numPoints = canvasPoints.length;\n\n  const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n  const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n\n  const lineSegment = getFirstIntersectionWithPolyline(\n    canvasPointsMinusEnds,\n    endToStart[0],\n    endToStart[1],\n    false\n  );\n\n  if (lineSegment) {\n    const indexToRemoveUpTo = lineSegment[1];\n\n    this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n  }\n}\n\n/**\n * Completes the contour being drawn, creating an open contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawOpenContour(element: HTMLDivElement): boolean {\n  const { canvasPoints } = this.drawData;\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const updatedPoints = shouldInterpolate(this.configuration)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n  const worldPoints = updatedPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n\n  // Add the first and last points to the list of handles. These means they\n  // will render handles on mouse hover.\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  // If the annotation is an open U-shaped annotation, find the annotation vector.\n  if (annotation.data.isOpenUShapeContour) {\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n  }\n\n  this.triggerAnnotationCompleted(annotation);\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * Searches for a crossing of the contour during create. If found, returns the\n * index of the point just before the lines cross.\n */\nfunction findCrossingIndexDuringCreate(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  // Note as we super sample the added points, we need to check the whole last mouse move, not the points\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { canvasPoints } = this.drawData;\n  const pointsLessLastOne = canvasPoints.slice(0, -1);\n\n  const lineSegment = getFirstIntersectionWithPolyline(\n    pointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (lineSegment === undefined) {\n    return;\n  }\n\n  const crossingIndex = lineSegment[0];\n\n  return crossingIndex;\n}\n\n/**\n * On crossing of the draw line, create a closed contour, and then start an edit\n * since this occurs during a mouse drag.\n */\nfunction applyCreateOnCross(\n  evt: EventTypes.InteractionEventType,\n  crossingIndex: number\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const { canvasPoints } = this.drawData;\n  const { annotation, viewportIdsToRender } = this.commonData;\n\n  // Add points between the end point and crossing point\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[crossingIndex],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  // Remove points up to just before the crossing index\n  for (let i = 0; i < crossingIndex; i++) {\n    canvasPoints.shift();\n  }\n\n  if (this.completeDrawClosedContour(element)) {\n    // pos complete operation\n    this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n  }\n}\n\n/**\n * Completes the contour on a cancel method call during the draw loop.\n */\nfunction cancelDrawing(element: HTMLElement) {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element);\n  } else {\n    this.completeDrawClosedContour(element);\n  }\n}\n\n/**\n * Tell whether a drawing should be halted or not. It will be true when canvas points is less than the minimum required.\n */\nfunction shouldHaltDrawing(\n  canvasPoints: any,\n  subPixelResolution: number\n): boolean {\n  const minPoints = Math.max(\n    /**\n     * The number of points to span 3 voxels in length, this is a realistically\n     * smallest open contour one could reasonably define (2 voxels should probably be a line).\n     */\n    subPixelResolution * 3,\n    /**\n     * Minimum 3 points, there are other annotations for one point (probe)\n     * or 2 points (line), so this comes only from a mistake in practice.\n     */\n    3\n  );\n  return canvasPoints.length < minPoints;\n}\n\n/**\n * Check and halt a drawing for a given event. It returns true in case drawing is halted, otherswise false.\n */\nfunction haltDrawing(element: HTMLDivElement, canvasPoints: any): boolean {\n  const { subPixelResolution } = this.configuration;\n\n  if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n    // Remove annotation instead of completing it.\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    removeAnnotation(annotation.annotationUID);\n\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.deactivateDraw(element);\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerDrawLoop(toolInstance): void {\n  toolInstance.activateDraw = activateDraw.bind(toolInstance);\n  toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n\n  toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n  toolInstance.findCrossingIndexDuringCreate =\n    findCrossingIndexDuringCreate.bind(toolInstance);\n  toolInstance.completeDrawOpenContour =\n    completeDrawOpenContour.bind(toolInstance);\n  toolInstance.removeCrossedLinesOnCompleteDraw =\n    removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n  toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n  toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n  toolInstance.completeDrawClosedContour =\n    completeDrawClosedContour.bind(toolInstance);\n  toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n  toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\n\nexport default registerDrawLoop;\n","import { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport { EventTypes } from '../../../types';\n\nconst { addCanvasPointsToArray, getFirstIntersectionWithPolyline } = polyline;\n\n/**\n * Check if the `editCanvasPoints` have crossed the `prevCanvasPoints` during\n * an edit.\n *\n * @privateRemarks The following tricks are required to make the UX smooth and\n * the editing not very picky on exactly where you click:\n * - If we don't cross after 2 points, but projecting the line backwards the\n * proximity distance means we cross, extend the line back.\n * - If we travel the full proximity in canvas points but don't cross a line, we\n * are likely drawing along the line, which is intuitive to the user. At this point\n * snap the start of the edit to the closest place on the `prevCanvasPoints`,\n * so that the edit can be executed in-line.\n */\nfunction checkForFirstCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): void {\n  const eventDetail = evt.detail;\n  const { element, currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (crossedLineSegment) {\n    this.editData.startCrossingIndex = crossedLineSegment[0];\n\n    // On the first crossing, remove the first lines prior to the crossing\n    this.removePointsUpUntilFirstCrossing(isClosedContour);\n    // prevent continue if there are not the minimum of points for this op.\n  } else if (prevCanvasPoints.length >= 2) {\n    if (\n      editCanvasPoints.length >\n      this.configuration.checkCanvasEditFallbackProximity\n    ) {\n      // At this point, likely we are drawing along the line, we are past the proximity for grabbing.\n      // Search for nearest line segment to the start of the edit.\n      // Set the crossing index to the lower index of the segment.\n\n      const firstEditCanvasPoint = editCanvasPoints[0];\n\n      const distanceIndexPairs = [];\n\n      for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n\n        distanceIndexPairs.push({ distance, index: i });\n      }\n\n      distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n      const twoClosestDistanceIndexPairs = [\n        distanceIndexPairs[0],\n        distanceIndexPairs[1],\n      ];\n\n      const lowestIndex = Math.min(\n        twoClosestDistanceIndexPairs[0].index,\n        twoClosestDistanceIndexPairs[1].index\n      );\n\n      this.editData.startCrossingIndex = lowestIndex;\n    } else {\n      // Check if extending a line back 6 (Proximity) canvas pixels would cross a line.\n\n      // Extend point back 6 canvas pixels from first point.\n      const dir = vec2.create();\n\n      vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n      vec2.normalize(dir, dir);\n\n      const proximity = 6;\n\n      const extendedPoint: Types.Point2 = [\n        editCanvasPoints[0][0] - dir[0] * proximity,\n        editCanvasPoints[0][1] - dir[1] * proximity,\n      ];\n\n      const crossedLineSegmentFromExtendedPoint =\n        getFirstIntersectionWithPolyline(\n          prevCanvasPoints,\n          extendedPoint,\n          editCanvasPoints[0],\n          isClosedContour\n        );\n\n      if (crossedLineSegmentFromExtendedPoint) {\n        // Add points.\n        const pointsToPrepend = [extendedPoint];\n\n        addCanvasPointsToArray(\n          element,\n          pointsToPrepend,\n          editCanvasPoints[0],\n          this.commonData\n        );\n\n        editCanvasPoints.unshift(...pointsToPrepend);\n\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n\n        this.editData.editIndex = editCanvasPoints.length - 1;\n        this.editData.startCrossingIndex =\n          crossedLineSegmentFromExtendedPoint[0];\n      }\n    }\n  }\n}\n\n/**\n * Removes the points from the `editCanvasPoints` up until the first crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsUpUntilFirstCrossing(isClosedContour: boolean): void {\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n  let numPointsToRemove = 0;\n\n  for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n    const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n\n    const didCrossLine = !!getFirstIntersectionWithPolyline(\n      prevCanvasPoints,\n      firstLine[0],\n      firstLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    numPointsToRemove++;\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n\n  // Remove the points\n  editCanvasPoints.splice(0, numPointsToRemove);\n\n  this.editData.editIndex = editCanvasPoints.length - 1;\n}\n\n/**\n * Returns `true` if the `editCanvasPoints` crosses the `prevCanvasPoints` a\n * second time.\n */\nfunction checkForSecondCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { prevCanvasPoints } = this.editData;\n\n  // Note this method is looking for the first corssing found of\n  // *the lines given* to it. The parameters given to it are specified to search\n  // for the second crossing of the prevCanvasPoints, by checking if the last\n  // mouse drag crossed these. This class method is only called if the edit loop\n  // has already has a crossing earlier in the edit.\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (!crossedLineSegment) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Removes the points from the `editCanvasPoints` after the second crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsAfterSecondCrossing(isClosedContour: boolean): void {\n  const { prevCanvasPoints, editCanvasPoints } = this.editData;\n\n  // Remove points after the crossing\n  for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n    const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n\n    const didCrossLine = !!getFirstIntersectionWithPolyline(\n      prevCanvasPoints,\n      lastLine[0],\n      lastLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    editCanvasPoints.pop();\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n}\n\n/**\n * During an edit, finds the index on the `prevCanvasPoints` that the\n * `editCanvasPoints` should snap to to create one continuous contour.\n *\n * Returns the index, but returns -1 if there is no index on the\n * `prevCanvasPoints` that can be snapped to with causing a crossing of the\n * `editCanvasPoints`.\n */\nfunction findSnapIndex(): number {\n  const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  if (\n    startCrossingIndex === undefined // Haven't crossed line yet\n  ) {\n    return;\n  }\n\n  const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n  const distanceIndexPairs = [];\n\n  for (let i = 0; i < prevCanvasPoints.length; i++) {\n    const prevCanvasPoint = prevCanvasPoints[i];\n    const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n\n    distanceIndexPairs.push({ distance, index: i });\n  }\n\n  distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n  // Search through from shortest distance and check which snap line doesn't\n  // Cross the edit line, in most cases the snap index will just be the first one.\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n\n  for (let i = 0; i < distanceIndexPairs.length; i++) {\n    const { index } = distanceIndexPairs[i];\n    const snapCanvasPosition = prevCanvasPoints[index];\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n    const crossedLineSegment = getFirstIntersectionWithPolyline(\n      editCanvasPointsLessLastOne,\n      snapCanvasPosition,\n      lastEditCanvasPoint,\n      false // The edit line is not a closed contour\n    );\n\n    if (!crossedLineSegment) {\n      return index;\n    }\n  }\n\n  // If all of the lines caused a crossing, this means we should start a new edit.\n  // Use -1 to signify this.\n  return -1;\n}\n\n/**\n * Checks if the `editCanvasPoints` cross themselves. If they do, remove the\n * region after the cross index, these removes isolated \"island\" loops that the\n * user can draw which make closed contours no longer simple polygons, or open\n * contours twisted.\n */\nfunction checkAndRemoveCrossesOnEditLine(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { editCanvasPoints } = this.editData;\n\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    editCanvasPointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (!crossedLineSegment) {\n    return;\n  }\n\n  // We have found a crossing, remove points after the crossing, cutting off\n  // the \"island\" loop drawn.\n\n  const editIndexCrossed = crossedLineSegment[0];\n  const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n\n  for (let i = 0; i < numPointsToRemove; i++) {\n    editCanvasPoints.pop();\n  }\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerEditLoopCommon(toolInstance) {\n  toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n  toolInstance.removePointsUpUntilFirstCrossing =\n    removePointsUpUntilFirstCrossing.bind(toolInstance);\n  toolInstance.checkForSecondCrossing =\n    checkForSecondCrossing.bind(toolInstance);\n  toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n  toolInstance.removePointsAfterSecondCrossing =\n    removePointsAfterSecondCrossing.bind(toolInstance);\n  toolInstance.checkAndRemoveCrossesOnEditLine =\n    checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\n\nexport default registerEditLoopCommon;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { EventTypes } from '../../../types';\nimport { polyline } from '../../../utilities/math';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport {\n  getInterpolatedPoints,\n  shouldInterpolate,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\n\nconst {\n  getSubPixelSpacingAndXYDirections,\n  addCanvasPointsToArray,\n  calculateAreaOfPoints,\n} = polyline;\n\n/**\n * Activates the closed contour edit event loop.\n */\nfunction activateClosedContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingClosed = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  hideElementCursor(element);\n}\n\n/**\n * Dectivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateClosedContourEdit(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by editing in\n * a way that requires a new edit to keep the contour a simple polygon.\n */\nfunction mouseDragClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    // If we haven't found the index of the first crossing yet,\n    // see if we can find it.\n    this.checkForFirstCrossing(evt, true);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  if (this.editData.snapIndex === -1) {\n    // No point on the prevCanvasPoints for the editCanvasPoints line to\n    // snap to. Apply edit, and start a new edit as we've gone back on ourselves.\n    this.finishEditAndStartNewEdit(evt);\n    return;\n  }\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, true)\n  ) {\n    // Crossed a second time, apply edit, and start a new edit from the crossing.\n    this.removePointsAfterSecondCrossing(true);\n    this.finishEditAndStartNewEdit(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Finish the current edit, and start a new one.\n */\nfunction finishEditAndStartNewEdit(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = false;\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n    snapIndex: undefined,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we combine a few tricks to find the optimal\n * contour:\n * - As the contour is closed, our edit might stradle the boundary between the\n * last and 0th point of the contour, e.g. a small edit might go from e.g. index\n * 960 to index 4. We therefore calculate two possible contours, and find the\n * one with the biggest area, which will define the actual edit the user desired.\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithClosedContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  // Generate two possible contours that could be intepreted from the edit:\n  //\n  // pointSet1 => 0 -> low -> edit -> high - max.\n  // pointSet2 => low -> high -> edit\n  //\n  // Depending on the placement of the edit and the origin, either of these could be the intended edit.\n  // We'll choose the one with the largest area, as edits are considered to be changes to the original area with\n  // A relative change of much less than unity.\n\n  // Point Set 1\n  const pointSet1 = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  let inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  let reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the orignal contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Point Set 2\n  const pointSet2 = [];\n\n  for (let i = lowIndex; i < highIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  inPlaceDistance =\n    distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n\n  reverseDistance =\n    distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const areaPointSet1 = calculateAreaOfPoints(pointSet1);\n  const areaPointSet2 = calculateAreaOfPoints(pointSet2);\n\n  const pointsToRender: Types.Point2[] =\n    areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n\n  return pointsToRender;\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction mouseUpClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction completeClosedContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldInterpolate(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    const worldPoints = updatedPoints.map((canvasPoint) =>\n      viewport.canvasToWorld(canvasPoint)\n    );\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = false;\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n  }\n\n  this.isEditingClosed = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateClosedContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the closed\n * contour edit loop.\n */\nfunction cancelClosedContourEdit(element: HTMLDivElement) {\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Registers the closed contour edit loop to the tool instance.\n */\nfunction registerClosedContourEditLoop(toolInstance): void {\n  toolInstance.activateClosedContourEdit =\n    activateClosedContourEdit.bind(toolInstance);\n  toolInstance.deactivateClosedContourEdit =\n    deactivateClosedContourEdit.bind(toolInstance);\n  toolInstance.mouseDragClosedContourEditCallback =\n    mouseDragClosedContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpClosedContourEditCallback =\n    mouseUpClosedContourEditCallback.bind(toolInstance);\n  toolInstance.finishEditAndStartNewEdit =\n    finishEditAndStartNewEdit.bind(toolInstance);\n  toolInstance.fuseEditPointsWithClosedContour =\n    fuseEditPointsWithClosedContour.bind(toolInstance);\n  toolInstance.cancelClosedContourEdit =\n    cancelClosedContourEdit.bind(toolInstance);\n  toolInstance.completeClosedContourEdit =\n    completeClosedContourEdit.bind(toolInstance);\n}\n\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport type { EventTypes, Annotation } from '../../../types';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport {\n  shouldInterpolate,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\n\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour edit event loop.\n */\nfunction activateOpenContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: Annotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingOpen = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  hideElementCursor(element);\n}\n\n/**\n * Deactivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateOpenContourEdit(element: HTMLDivElement) {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by dragging\n * the edit line past the end of the open contour.\n */\nfunction mouseDragOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Get pixel spacing in the direction.\n  // Check that we have moved at least one voxel in each direction.\n\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    this.checkForFirstCrossing(evt, false);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, false)\n  ) {\n    this.removePointsAfterSecondCrossing(false);\n    this.finishEditOpenOnSecondCrossing(evt);\n  } else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n    this.openContourEditOverwriteEnd(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Overwrite the end of the contour with the edit, and then switch to the\n * open contour end edit loop.\n */\nfunction openContourEditOverwriteEnd(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n  // Note: Contours generate from fusedCanvasPoints will be in the direction\n  // with the last point being the current mouse position\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n  annotation.data.handles.activeHandleIndex = 1;\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  // Jump to a normal line edit now.\n  this.deactivateOpenContourEdit(element);\n  this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender);\n}\n\n/**\n * Checks if we are moving the `editCanvasPoints` past the end of one of the\n * open contour's `prevCanvasPoint`s.\n */\nfunction checkIfShouldOverwriteAnEnd(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPos = lastPoints.canvas;\n\n  const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    // Edit not started\n    return false;\n  }\n\n  // No snap index can be found, so contour is being edited away from line.\n  if (snapIndex === -1) {\n    return true;\n  }\n\n  if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n    // Not snapping to final index\n    return false;\n  }\n\n  // Work out the angle between the last mouse move and\n  // And the current point to the snapped point.\n  const p1 = canvasPos;\n  const p2 = lastCanvasPos;\n  const p3 = prevCanvasPoints[snapIndex];\n\n  const a = vec2.create();\n  const b = vec2.create();\n\n  vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n  vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n\n  const aDotb = vec2.dot(a, b);\n  const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n  const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n\n  const theta = Math.acos(aDotb / (magA * magB));\n\n  if (theta < Math.PI / 2) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a single contour ready for\n * end editing.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsForOpenContourEndEdit(): Types.Point2[] {\n  const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  const newCanvasPoints = [];\n\n  // Note: Generated contours will both be in the direction with the\n  // last point being the current mouse position\n\n  if (snapIndex === 0) {\n    // end -> crossingpoint -> edit\n    // Add points from the end of the previous contour, to the crossing point.\n    for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // start -> crossingpoint -> edit\n    // Add points from the orignal contour origin up to the low index.\n    for (let i = 0; i < startCrossingIndex; i++) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[0]\n  );\n\n  const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[editCanvasPoints.length - 1]\n  );\n\n  if (\n    distanceBetweenCrossingIndexAndFirstPoint <\n    distanceBetweenCrossingIndexAndLastPoint\n  ) {\n    // In order\n    for (let i = 0; i < editCanvasPoints.length; i++) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // reverse\n    for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  return newCanvasPoints;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithOpenContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return undefined;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const pointsToRender = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  const inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  const reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the original contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  return pointsToRender;\n}\n\n/**\n * On a second crossing, apply edit, and start a new edit from the crossing.\n */\nfunction finishEditOpenOnSecondCrossing(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the edit of the open contour when the mouse button is released.\n */\nfunction mouseUpOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Completes the edit of the open contour.\n */\nfunction completeOpenContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldInterpolate(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    const worldPoints = updatedPoints.map((canvasPoint) =>\n      viewport.canvasToWorld(canvasPoint)\n    );\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n      worldPoints[0],\n      worldPoints[worldPoints.length - 1],\n    ];\n\n    // If the annotation is an open U-shaped annotation, find the annotation vector.\n    if (annotation.data.isOpenUShapeContour) {\n      annotation.data.openUShapeContourVectorToPeak =\n        findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n    }\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n  }\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateOpenContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the open\n * contour edit loop.\n */\nfunction cancelOpenContourEdit(element: HTMLDivElement) {\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Registers the open contour edit loop to the tool instance.\n */\nfunction registerOpenContourEditLoop(toolInstance) {\n  toolInstance.activateOpenContourEdit =\n    activateOpenContourEdit.bind(toolInstance);\n  toolInstance.deactivateOpenContourEdit =\n    deactivateOpenContourEdit.bind(toolInstance);\n  toolInstance.mouseDragOpenContourEditCallback =\n    mouseDragOpenContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpOpenContourEditCallback =\n    mouseUpOpenContourEditCallback.bind(toolInstance);\n  toolInstance.fuseEditPointsWithOpenContour =\n    fuseEditPointsWithOpenContour.bind(toolInstance);\n  toolInstance.finishEditOpenOnSecondCrossing =\n    finishEditOpenOnSecondCrossing.bind(toolInstance);\n  toolInstance.checkIfShouldOverwriteAnEnd =\n    checkIfShouldOverwriteAnEnd.bind(toolInstance);\n  toolInstance.fuseEditPointsForOpenContourEndEdit =\n    fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n  toolInstance.openContourEditOverwriteEnd =\n    openContourEditOverwriteEnd.bind(toolInstance);\n  toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n  toolInstance.completeOpenContourEdit =\n    completeOpenContourEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport type { EventTypes, Annotation } from '../../../types';\nimport { polyline } from '../../../utilities/math';\n\nconst { getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour end edit. This actually just sets up the state so\n * that the tool thinks we are mid draw, and then jumps into the drawing loop.\n */\nfunction activateOpenContourEndEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: Annotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n  const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n\n  // If 0, invert point direction, if 1, keep point direction the same.\n  // This is so we can just jump as into the state as if the annotation was just being drawn.\n  if (handleIndexGrabbed === 0) {\n    canvasPoints.reverse();\n  }\n\n  this.drawData = {\n    canvasPoints: canvasPoints,\n    polylineIndex: canvasPoints.length - 1,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n  };\n\n  state.isInteractingWithTool = true;\n\n  // Jump into drawing loop.\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n\n/**\n * Registers the open contour end edit loop to the tool instance.\n */\nfunction registerOpenContourEndEditLoop(toolInstance): void {\n  toolInstance.activateOpenContourEndEdit =\n    activateOpenContourEndEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEndEditLoop;\n","import type { Types } from '@cornerstonejs/core';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n} from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { SVGDrawingHelper } from '../../../types';\n\nconst { pointsAreWithinCloseContourProximity } = polyline;\n\ntype PlanarFreehandROIRenderOptions = {\n  color?: string;\n  width?: number;\n  connectFirstToLast?: boolean;\n};\n\nfunction _getRenderingOptions(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): PlanarFreehandROIRenderOptions {\n  const styleSpecifier: StyleSpecifier = {\n    toolGroupId: this.toolGroupId,\n    toolName: this.getToolName(),\n    viewportId: enabledElement.viewport.id,\n    annotationUID: annotation.annotationUID,\n  };\n\n  const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n  const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n  const color = this.getStyle('color', styleSpecifier, annotation);\n\n  const isOpenContour = annotation.data.isOpenContour;\n\n  const options = {\n    color: color === undefined ? undefined : <string>color,\n    width: lineWidth === undefined ? undefined : <number>lineWidth,\n    lineDash: lineDash === undefined ? undefined : <number[]>lineDash,\n    connectLastToFirst: !isOpenContour,\n  };\n\n  return options;\n}\n\n/**\n * Renders a `PlanarFreehandROIAnnotation` that is not currently being drawn or edited.\n */\nfunction renderContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  // prevent drawing or further calculation in case viewport data is not ready yet\n  if (!enabledElement?.viewport?.getImageData()) {\n    return;\n  }\n  // Check if the contour is an open contour\n  if (annotation.data.isOpenContour) {\n    // If its an open contour, check i its a U-shaped contour\n    if (annotation.data.isOpenUShapeContour) {\n      calculateUShapeContourVectorToPeakIfNotPresent(\n        enabledElement,\n        annotation\n      );\n\n      this.renderOpenUShapedContour(\n        enabledElement,\n        svgDrawingHelper,\n        annotation\n      );\n    } else {\n      // If not a U-shaped contour, render standard open contour.\n      this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    }\n  } else {\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n  }\n}\n\n/**\n * If the open U-shaped contour does not have a peak.\n */\nfunction calculateUShapeContourVectorToPeakIfNotPresent(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  if (!annotation.data.openUShapeContourVectorToPeak) {\n    // Annotation just been set to be an open U-shaped contour.\n    // calculate its peak vector here.\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n  }\n}\n\n/**\n * Renders an closed `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderClosedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Its unfortunate that we have to do this for each annotation,\n  // Even if its unchanged. In the future we could cache the canvas points per\n  // element on the tool? That feels very weird also as we'd need to manage\n  // it/clean them up. Its a pre-optimisation for now and we can tackle it if it\n  // becomes a problem.\n  const canvasPoints = annotation.data.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderOpenContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const canvasPoints = annotation.data.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n\n  const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n\n  if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n    const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n\n    // Draw highlighted points\n    const handleGroupUID = '0';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const handlePoints = [\n      canvasPoints[0],\n      canvasPoints[canvasPoints.length - 1],\n    ];\n\n    // Don't render a hovered handle, as this will be rendered larger in\n    // the next block.\n    if (activeHandleIndex === 0) {\n      handlePoints.shift();\n    } else if (activeHandleIndex === 1) {\n      handlePoints.pop();\n    }\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      handlePoints,\n      {\n        color: options.color,\n        handleRadius: radius,\n      }\n    );\n  }\n\n  if (activeHandleIndex !== null) {\n    // Draw highlighted points\n    const handleGroupUID = '1';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const indexOfCanvasPoints =\n      activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n\n    const handlePoint = canvasPoints[indexOfCanvasPoints];\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      [handlePoint],\n      { color: options.color }\n    );\n  }\n}\n\nfunction renderOpenUShapedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const { polyline, openUShapeContourVectorToPeak } = annotation.data;\n\n  this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n  // prevent rendering u shape in case openUShapeContourVectorToPeak is not set yet\n  if (!openUShapeContourVectorToPeak) {\n    return;\n  }\n\n  const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n  const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n\n  const openUShapeContourVectorToPeakCanvas = [\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n  ];\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Join first and last points\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'first-to-last',\n    [firstCanvasPoint, lastCanvasPoint],\n    {\n      color: options.color,\n      width: options.width,\n      connectLastToFirst: false,\n      lineDash: '2,2',\n    }\n  );\n\n  // Render midpoint to open contour surface line\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'midpoint-to-open-contour',\n    [\n      openUShapeContourVectorToPeakCanvas[0],\n      openUShapeContourVectorToPeakCanvas[1],\n    ],\n    {\n      color: options.color,\n      width: options.width,\n      connectLastToFirst: false,\n      lineDash: '2,2',\n    }\n  );\n}\n\n/**\n * Renders a new `PlanarFreehandROIAnnotation` annotation during\n * creation/drawing.\n */\nfunction renderContourBeingDrawn(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n\n  // Override rendering whilst drawing the contour, we don't know if its open\n  // or closed yet\n  options.connectLastToFirst = false;\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    '1',\n    canvasPoints,\n    options\n  );\n\n  if (allowOpenContours) {\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n    // Check if start and end are within close proximity\n    if (\n      pointsAreWithinCloseContourProximity(\n        firstPoint,\n        lastPoint,\n        this.configuration.closeContourProximity\n      )\n    ) {\n      // Preview join last points\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        '2',\n        [lastPoint, firstPoint],\n        options\n      );\n    } else {\n      // Draw start point\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        handleGroupUID,\n        [firstPoint],\n        { color: options.color, handleRadius: 2 }\n      );\n    }\n  }\n}\n\n/**\n * Renders a closed `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderClosedContourBeingEdited(\n  enabledElement,\n  svgDrawingHelper,\n  annotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderOpenContourBeingEdited(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Registers the render methods of various contour states to the tool instance.\n */\nfunction registerRenderMethods(toolInstance) {\n  toolInstance.renderContour = renderContour.bind(toolInstance);\n  toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n  toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n  toolInstance.renderOpenUShapedContour =\n    renderOpenUShapedContour.bind(toolInstance);\n\n  toolInstance.renderContourBeingDrawn =\n    renderContourBeingDrawn.bind(toolInstance);\n\n  toolInstance.renderClosedContourBeingEdited =\n    renderClosedContourBeingEdited.bind(toolInstance);\n  toolInstance.renderOpenContourBeingEdited =\n    renderOpenContourBeingEdited.bind(toolInstance);\n  toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\n\nexport default registerRenderMethods;\n","import {\n  CONSTANTS,\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../../stateManagement/annotation/annotationState';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport {\n  EventTypes,\n  ToolHandle,\n  Annotation,\n  Annotations,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\n\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n/**\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\n * support for oblique views is possible, but not yet supported, due to the implementation of\n * `getSubPixelSpacingAndXYDirections`.\n *\n * The resulting annotation's data and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\n * The interpolation process uses b-spline algorithm and consider 4 configurations properties:\n * - interpolation.interpolateOnAdd: to tell whether it should be interpolated or not (for editing it is considered the property interpolateOnEdit) (default: false)\n * - interpolation.interpolateOnEdit: to tell whether it should be interpolated or not when editing (default: false)\n * - interpolation.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during interpolation (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\n * - interpolation.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\n *\n * So, with that said the interpolation might occur when:\n * - drawing is done (i.e mouse is released) and interpolation.interpolateOnAdd is true. Interpolation algorithm uses knotsRatioPercentageOnAdd\n * - edit drawing is done (i.e mouse is released) and interpolation.interpolateOnEdit is true. Interpolation algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\n * Interpolation does not occur when:\n * - interpolation.interpolateOnAdd is false and drawing is completed\n * - interpolation.interpolateOnEdit is false and edit is completed\n * - drawing still happening (editing or not)\n *\n * The result of interpolation will be a smoother set of segments.\n * Changing tool configuration (see below) you can fine-tune the interpolation process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive interpolation.\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more agressive interpolation.\n *\n * ```js\n * cornerstoneTools.addTool(PlanarFreehandROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // set interpolation agressiveness while adding new annotation (ps: this does not change if interpolation is ON or OFF)\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   interpolation: { knotsRatioPercentageOnAdd: 30 },\n * });\n *\n * // set interpolation to be ON while editing only\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   interpolation: { interpolateOnAdd: false, interpolateOnEdit: true  },\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\nclass PlanarFreehandROITool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  private commonData?: PlanarFreehandROICommonData;\n  isDrawing = false;\n  isEditingClosed = false;\n  isEditingOpen = false;\n\n  private activateDraw: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateClosedContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEndEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private cancelDrawing: (element: HTMLDivElement) => void;\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\n\n  private renderContour: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderContourBeingDrawn: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderClosedContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderOpenContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        alwaysRenderOpenContourHandles: {\n          // When true, always render end points when you have an open contour, rather\n          // than just rendering a line.\n          enabled: false,\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\n          radius: 2,\n        },\n        allowOpenContours: true,\n        // Proximity in canvas coordinates used to join contours.\n        closeContourProximity: 10,\n        // The proximity at which we fallback to the simplest grabbing logic for\n        // determining what index of the contour to start editing.\n        checkCanvasEditFallbackProximity: 6,\n        // The relative distance that points should be dropped along the polyline\n        // in units of the image pixel spacing. A value of 1 means that nodes must\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\n        // nodes should be placed within the space of one image pixel size. A higher\n        // value gives more finese to the tool/smoother lines, but the value cannot\n        // be infinite as the lines become very computationally expensive to draw.\n        subPixelResolution: 4,\n        interpolation: {\n          interpolateOnAdd: false,\n          interpolateOnEdit: false, // used for edit only\n          knotsRatioPercentageOnAdd: 40,\n          knotsRatioPercentageOnEdit: 40,\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // Register event loops and rendering logic, which are stored in different\n    // Files due to their complexity/size.\n    registerDrawLoop(this);\n    registerEditLoopCommon(this);\n    registerClosedContourEditLoop(this);\n    registerOpenContourEditLoop(this);\n    registerOpenContourEndEditLoop(this);\n    registerRenderMethods(this);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current image, creates\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\n   *\n   * @param evt - `EventTypes.NormalizedMouseEventType`\n   * @returns The `PlanarFreehandROIAnnotation` object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): PlanarFreehandROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: PlanarFreehandROIAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          points: [], // Handle points for open contours\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        polyline: [<Types.Point3>[...worldPos]], // Polyline coordinates\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    this.activateDraw(evt, annotation, viewportIdsToRender);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * Begins an edit of an open contour, when the mouse has selected a handle\n   * (end) of the open contour.\n   *\n   * @param evt - `EventTypes.MouseDownEventType`\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\n   * @param handle - The handle index, 0 for the start and 1 for the end.\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender);\n  };\n\n  /**\n   * Edits the open or closed contour when the line is grabbed and dragged.\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    if (annotation.data.isOpenContour) {\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n    } else {\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n  };\n\n  /**\n   * Returns if the canvas point is near the line of the given annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: PlanarFreehandROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const points = annotation.data.polyline;\n\n    // NOTE: It is implemented this way so that we do not double calculate\n    // points when number crunching adjacent line segments.\n    let previousPoint = viewport.worldToCanvas(points[0]);\n\n    for (let i = 1; i < points.length; i++) {\n      const p1 = previousPoint;\n      const p2 = viewport.worldToCanvas(points[i]);\n\n      const distance = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n\n      if (distance === true) {\n        return true;\n      }\n\n      previousPoint = p2;\n    }\n\n    if (annotation.data.isOpenContour) {\n      // Contour is open, don't check last point to first point.\n      return false;\n    }\n\n    // check last point to first point\n    const pStart = viewport.worldToCanvas(points[0]);\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n\n    const distance = pointCanProjectOnLine(\n      canvasCoords,\n      pStart,\n      pEnd,\n      proximity\n    );\n\n    if (distance === true) {\n      return true;\n    }\n\n    return false;\n  };\n\n  cancel = (element: HTMLDivElement): void => {\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (isDrawing) {\n      this.cancelDrawing(element);\n    } else if (isEditingOpen) {\n      this.cancelOpenContourEdit(element);\n    } else if (isEditingClosed) {\n      this.cancelClosedContourEdit(element);\n    }\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: PlanarFreehandROIAnnotation,\n    enabledElement: Types.IEnabledElement\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation completed event.\n   */\n  triggerAnnotationCompleted = (\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventType = Events.ANNOTATION_COMPLETED;\n\n    const eventDetail: AnnotationCompletedEventDetail = {\n      annotation,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * @override We need to override this method as the tool doesn't always have\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\n   * `filterAnnotationsWithinSlice`.\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let annotationsToDisplay;\n\n    if (viewport instanceof StackViewport) {\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\n      // path doesn't require handles.\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n    } else if (viewport instanceof VolumeViewport) {\n      const camera = viewport.getCamera();\n\n      const { spacingInNormalDirection } =\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n      // Get data with same normal and within the same slice\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\n        annotations,\n        camera,\n        spacingInNormalDirection\n      );\n    } else {\n      throw new Error(`Viewport Type ${viewport.type} not supported`);\n    }\n\n    return annotationsToDisplay;\n  }\n\n  /**\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\n   * which uses the polyline position rather than the handle. As the polyline is\n   * always present.\n   */\n  private filterAnnotationsWithinSlice(\n    annotations: Annotations,\n    camera: Types.ICamera,\n    spacingInNormalDirection: number\n  ): Annotations {\n    const { viewPlaneNormal } = camera;\n\n    const annotationsWithParallelNormals = annotations.filter(\n      (td: Annotation) => {\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n        const isParallel =\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n          PARALLEL_THRESHOLD;\n\n        return annotationViewPlaneNormal && isParallel;\n      }\n    );\n\n    // No in plane annotations.\n    if (!annotationsWithParallelNormals.length) {\n      return [];\n    }\n\n    // Annotation should be within the slice, which means that it should be between\n    // camera's focalPoint +/- spacingInNormalDirection.\n\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n\n    const annotationsWithinSlice = [];\n\n    for (const annotation of annotationsWithParallelNormals) {\n      const data = annotation.data;\n      const point = data.polyline[0];\n\n      if (!annotation.isVisible) {\n        continue;\n      }\n\n      // A = point\n      // B = focal point\n      // P = normal\n\n      // B-A dot P  => Distance in the view direction.\n      // this should be less than half the slice distance.\n\n      const dir = vec3.create();\n\n      vec3.sub(dir, focalPoint, point);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        annotationsWithinSlice.push(annotation);\n      }\n    }\n\n    return annotationsWithinSlice;\n  }\n\n  /**\n   * Draws the `PlanarFreehandROIAnnotation`s at each request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = <PlanarFreehandROIAnnotation[]>(\n      getAnnotations(this.getToolName(), element)\n    );\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as PlanarFreehandROIAnnotation[];\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n      // No annotations are currently being modified, so we can just use the\n      // render contour method to render all of them\n      annotations.forEach((annotation) => {\n        if (!annotation) return;\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      });\n\n      return renderStatus;\n    }\n\n    // One of the annotations will need special rendering treatment, render all\n    // other annotations not being interacted with using the standard renderContour\n    // rendering path.\n    const activeAnnotationUID = this.commonData.annotation.annotationUID;\n\n    annotations.forEach((annotation) => {\n      if (annotation.annotationUID === activeAnnotationUID) {\n        if (isDrawing) {\n          this.renderContourBeingDrawn(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingClosed) {\n          this.renderClosedContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingOpen) {\n          this.renderOpenContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else {\n          throw new Error(\n            `Unknown ${this.getToolName()} annotation rendering state`\n          );\n        }\n      } else {\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      }\n    });\n\n    // Todo: return boolean flag for each rendering route in the planar tool.\n    return true;\n  };\n}\n\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROITool } from '../../tools';\nimport { ToolGroupManager } from '../../store';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nfunction shouldPreventInterpolation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  if (!annotation?.data?.polyline || knotsRatioPercentage <= 0) {\n    return true;\n  }\n\n  if (!enabledElement.viewport) {\n    return true;\n  }\n\n  const { renderingEngineId, viewportId, FrameOfReferenceUID } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (annotation.metadata.FrameOfReferenceUID !== FrameOfReferenceUID) {\n    return true;\n  }\n\n  if (!toolGroup) {\n    return true;\n  }\n\n  const toolInstance = toolGroup.getToolInstance(annotation.metadata.toolName);\n\n  // strategy to prevent non PlanarFreehandTool\n  if (!(toolInstance instanceof PlanarFreehandROITool)) {\n    return true;\n  }\n\n  return (\n    toolInstance.isDrawing ||\n    toolInstance.isEditingOpen ||\n    toolInstance.isEditingClosed\n  );\n}\n/**\n * Interpolates a given annotation from a given enabledElement.\n * It mutates annotation param.\n * The param knotsRatioPercentage defines the percentage of points to be considered as knots on the interpolation process.\n * Interpolation will be skipped in case: annotation is not present in enabledElement (or there is no toolGroup associated with it), related tool is being modified.\n */\nexport default function interpolateAnnotation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  // prevent running while there is any tool annotation being modified\n  if (\n    shouldPreventInterpolation(enabledElement, annotation, knotsRatioPercentage)\n  ) {\n    return false;\n  }\n\n  const { viewport } = enabledElement;\n  // use only 2 dimensions on interpolation (what visually matters),\n  // otherwise a 3d interpolation might have a totally different output as it consider one more dimension.\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n  const interpolatedCanvasPoints = <Types.Point2[]>(\n    interpolateSegmentPoints(\n      canvasPoints,\n      0,\n      canvasPoints.length,\n      knotsRatioPercentage\n    )\n  );\n\n  if (interpolatedCanvasPoints === canvasPoints) {\n    return false;\n  }\n\n  annotation.data.polyline = interpolatedCanvasPoints.map(\n    viewport.canvasToWorld\n  );\n\n  return true;\n}\n","import interpolateAnnotation from './interpolateAnnotation';\n\nexport default {\n  interpolateAnnotation,\n};\n\nexport { interpolateAnnotation };\n","import { getEnabledElement } from '@cornerstonejs/core';\n\nconst state: Record<number, any> = {};\n\nfunction addToolState(element: HTMLDivElement, data): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): any {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import {\n  getEnabledElement,\n  StackViewport,\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\n\nconst requestType = Enums.RequestType.Prefetch;\nconst priority = 0;\nconst addToBeginning = true;\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction range(lowEnd, highEnd) {\n  // Javascript version of Python's range function\n  // http://stackoverflow.com/questions/3895478/does-javascript-have-a-method-like-range-to-generate-an-array-based-on-suppl\n  lowEnd = Math.round(lowEnd) || 0;\n  highEnd = Math.round(highEnd) || 0;\n\n  const arr = [];\n  let c = highEnd - lowEnd + 1;\n\n  if (c <= 0) {\n    return arr;\n  }\n\n  while (c--) {\n    arr[c] = highEnd--;\n  }\n\n  return arr;\n}\n\nfunction nearestIndex(arr, x) {\n  // Return index of nearest values in array\n  // http://stackoverflow.com/questions/25854212/return-index-of-nearest-values-in-an-array\n  let low = 0;\n  let high = arr.length - 1;\n\n  arr.forEach((v, idx) => {\n    if (v < x) {\n      low = Math.max(idx, low);\n    } else if (v > x) {\n      high = Math.min(idx, high);\n    }\n  });\n\n  return { low, high };\n}\n\nfunction getStackData(element) {\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'stackPrefetch: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  const { viewport } = enabledElement;\n\n  if (!(viewport instanceof StackViewport)) {\n    throw new Error(\n      'stackPrefetch: element must be a StackViewport, VolumeViewport stackPrefetch not yet implemented'\n    );\n  }\n\n  return {\n    currentImageIdIndex: viewport.getCurrentImageIdIndex(),\n    imageIds: viewport.getImageIds(),\n  };\n}\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  if (\n    !stackPrefetch.indicesToRequest ||\n    !stackPrefetch.indicesToRequest.length\n  ) {\n    stackPrefetch.enabled = false;\n  }\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const imageLoadObject = cache.getImageLoadObject(imageId);\n\n    if (imageLoadObject) {\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n\n    // triggerEvent(element, EVENTS.STACK_PREFETCH_IMAGE_LOADED, {\n    //   element,\n    //   imageId: image.imageId,\n    //   imageIndex: imageIdIndex,\n    //   stackPrefetch,\n    //   stack,\n    // });\n\n    // If there are no more images to fetch\n    // if (\n    //   !(\n    //     stackPrefetch.indicesToRequest &&\n    //     stackPrefetch.indicesToRequest.length > 0\n    //   )\n    // ) {\n    //   triggerEvent(element, EVENTS.STACK_PREFETCH_DONE, {\n    //     element,\n    //     stackPrefetch,\n    //     stack,\n    //   });\n    // }\n  }\n\n  // Retrieve the errorLoadingHandler if one exists\n  // const errorLoadingHandler =\n  //   loadHandlerManager.getErrorLoadingHandler(element);\n\n  // function failCallback(error) {\n  //   logger.log('prefetch errored: %o', error);\n  //   if (errorLoadingHandler) {\n  //     errorLoadingHandler(element, imageId, error, 'stackPrefetch');\n  //   }\n  // }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction getPromiseRemovedHandler(element) {\n  return function (e) {\n    const eventData = e.detail;\n\n    // When an imagePromise has been pushed out of the cache, re-add its index\n    // It to the indicesToRequest list so that it will be retrieved later if the\n    // CurrentImageIdIndex is changed to an image nearby\n    let stackData;\n\n    try {\n      // It will throw an exception in some cases (eg: thumbnails)\n      stackData = getStackData(element);\n    } catch (error) {\n      return;\n    }\n\n    if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {\n      return;\n    }\n\n    const stack = stackData;\n    const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);\n\n    // Make sure the image that was removed is actually in this stack\n    // Before adding it to the indicesToRequest array\n    if (imageIdIndex < 0) {\n      return;\n    }\n\n    const stackPrefetchData = getToolState(element);\n\n    if (\n      !stackPrefetchData ||\n      !stackPrefetchData.data ||\n      !stackPrefetchData.data.length\n    ) {\n      return;\n    }\n\n    stackPrefetchData.indicesToRequest.push(imageIdIndex);\n  };\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.data.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nexport { enable, disable, getConfiguration, setConfiguration };\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import { utilities, cache, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume: 4D volume to compute time point data from\n * @param options: frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error('No ROI provided');\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('Please provide only one ROI');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    // Get the index of every non-zero voxel in mask by mapping indexes to\n    // new array, then using the array to filter\n    const indexArray = segmentationVolume\n      .getScalarData()\n      .map((_, i) => i)\n      .filter((i) => segmentationVolume.getScalarData()[i] !== 0);\n    const dataInTime = _getTimePointDataMask(frames, indexArray, dynamicVolume);\n\n    return dataInTime;\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, indexArray, volume) {\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  for (let i = 0; i < indexArray.length; i++) {\n    const indexValues = [];\n    frames.forEach((frame) => {\n      const activeScalarData = allScalarData[frame];\n      indexValues.push(activeScalarData[indexArray[i]]);\n    });\n    value.push(indexValues);\n  }\n  return value;\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D: volume to compute time frame data from\n * @param operation: operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers: an array of frame indexs to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\n\n/**\n * Set the cursor for an HTML element. cursorNames can be either\n * cornerstone3DTools cursors or standard cursors.\n *\n * @param element - The element to set the cursor on.\n * @param cursorName - The name of the cursor to set. This can be\n * any cursor name either Cornerstone-specific cursor names or the standard\n * CSS cursor names.\n */\nfunction setCursorForElement(\n  element: HTMLDivElement,\n  cursorName: string\n): void {\n  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n  if (!cursor) {\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  if (!cursor) {\n    console.log(\n      `Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`\n    );\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  setElementCursor(element, cursor);\n}\n\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport {\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n} from './SVGCursorDescriptor';\n\n// Todo: this should be enum\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\n\nexport {\n  MouseCursor,\n  ImageMouseCursor,\n  SVGMouseCursor,\n  elementCursor,\n  registerCursor,\n  CursorNames,\n  CursorSVG,\n  setCursorForElement,\n};\n","import { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport { getStyleProperty } from './helpers';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\n\n/**\n * getFont - Returns a font string of the form \"{fontSize}px fontName\" used by `canvas`.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns The font string.\n */\nfunction getFont(\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  const fontSize = getStyleProperty(\n    'textBoxFontSize',\n    styleSpecifier,\n    state,\n    mode\n  );\n  const fontFamily = getStyleProperty(\n    'textBoxFontFamily',\n    styleSpecifier,\n    state,\n    mode\n  );\n\n  return `${fontSize}px ${fontFamily}`;\n}\n\nexport default getFont;\n","import * as Enums from '../../../enums';\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport validateLabelmap from '../../../tools/displayTools/Labelmap/validateRepresentationData';\n\n/**\n * Checks if the segmentationInputArray is valid meaning it contains\n * correct representationProps for the representation type that is being used.\n *\n * @param segmentationInputArray - Array of segmentation inputs\n * @internal\n */\nfunction validateSegmentationInput(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  if (!segmentationInputArray || !segmentationInputArray.length) {\n    throw new Error('The segmentationInputArray is undefined or empty array');\n  }\n\n  segmentationInputArray.forEach((segmentationInput) => {\n    if (segmentationInput.segmentationId === undefined) {\n      throw new Error(\n        'The segmentationInput.segmentationId is undefined, please provide a valid segmentationId'\n      );\n    }\n\n    if (segmentationInput.representation === undefined) {\n      throw new Error(\n        'The segmentationInput.representation is undefined, please provide a valid representation'\n      );\n    }\n\n    if (\n      segmentationInput.representation.type ===\n      Enums.SegmentationRepresentations.Labelmap\n    ) {\n      validateLabelmap(segmentationInput);\n    }\n  });\n}\n\nexport default validateSegmentationInput;\n","import { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport { cache } from '@cornerstonejs/core';\nimport { LabelmapSegmentationData } from '../../../types/LabelmapTypes';\n\nfunction validate(segmentationInput: SegmentationPublicInput): void {\n  if (!segmentationInput.representation.data) {\n    throw new Error(\n      'The segmentationInput.representationData.data is undefined, please provide a valid representationData.data'\n    );\n  }\n\n  const representationData = segmentationInput.representation\n    .data as LabelmapSegmentationData;\n\n  if (!representationData.volumeId) {\n    throw new Error(\n      'The segmentationInput.representationData.volumeId is undefined, please provide a valid representationData.volumeId'\n    );\n  }\n\n  const cachedVolume = cache.getVolume(representationData.volumeId);\n\n  if (!cachedVolume) {\n    throw new Error(\n      `volumeId of ${representationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`\n    );\n  }\n}\n\nexport default validate;\n","import _cloneDeep from 'lodash.clonedeep';\nimport { SegmentationPublicInput } from '../../types/SegmentationStateTypes';\nimport { validateSegmentationInput } from './helpers';\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\n/**\n * Adds the segmentation to the cornerstone3D segmentation state. It should be\n * noted that segmentations are not added to any toolGroup's viewports. In order to\n * do so, you should add a \"representation\" of the segmentation to the toolGroup\n * using addSegmentationRepresentations helper. The reason for this is that there\n * can be multiple representations of the same segmentation (e.g. Labelmap and\n * Contour, etc. - Currently only Labelmap representations is supported).\n * @param segmentationInputArray - The array of segmentation input, each of which\n * defining the segmentationId and the main representation data for the segmentation.\n */\nfunction addSegmentations(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  validateSegmentationInput(segmentationInputArray);\n\n  segmentationInputArray.map((segInput) => {\n    const segmentationInput = _cloneDeep(segInput);\n\n    addSegmentationToState(segmentationInput);\n  });\n}\n\nexport default addSegmentations;\n","import _cloneDeep from 'lodash.clonedeep';\nimport {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n} from '../../types/SegmentationStateTypes';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\n\n/**\n * Set the specified segmentation representations on the viewports of the specified\n * toolGroup. It accepts a second argument which is a toolGroup specific representation\n * configuration.\n *\n * @param toolGroupId - The Id of the toolGroup to add the segmentation representations to\n * @param representationInputArray - An array of segmentation representations to add to the toolGroup\n * @param toolGroupSpecificRepresentationConfig - The toolGroup specific configuration\n * for the segmentation representations\n */\nasync function addSegmentationRepresentations(\n  toolGroupId: string,\n  representationInputArray: RepresentationPublicInput[],\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string[]> {\n  // Check if there exists a toolGroup with the toolGroupId\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (!toolGroup) {\n    throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\n  }\n\n  const promises = representationInputArray.map((representationInput) => {\n    return _addSegmentationRepresentation(\n      toolGroupId,\n      representationInput,\n      toolGroupSpecificRepresentationConfig\n    );\n  });\n\n  const segmentationRepresentationUIDs = await Promise.all(promises);\n\n  return segmentationRepresentationUIDs;\n}\n\nasync function _addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  let segmentationRepresentationUID;\n\n  if (representationInput.type === Representations.Labelmap) {\n    segmentationRepresentationUID =\n      await labelmapDisplay.addSegmentationRepresentation(\n        toolGroupId,\n        representationInput,\n        toolGroupSpecificRepresentationConfig\n      );\n  } else if (representationInput.type === Representations.Contour) {\n    segmentationRepresentationUID =\n      await contourDisplay.addSegmentationRepresentation(\n        toolGroupId,\n        representationInput,\n        toolGroupSpecificRepresentationConfig\n      );\n  } else {\n    throw new Error(\n      `The representation type ${representationInput.type} is not supported`\n    );\n  }\n\n  return segmentationRepresentationUID;\n}\n\nexport default addSegmentationRepresentations;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * Tool that pans the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass PanTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\n\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { BaseTool } from './base';\n\n/**\n * Tool that rotates the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass TrackballRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        rotateIncrementDegrees: 2,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  rotateCamera = (viewport, centerWorld, axis, angle) => {\n    const vtkCamera = viewport.getVtkActiveCamera();\n    const viewUp = vtkCamera.getViewUp();\n    const focalPoint = vtkCamera.getFocalPoint();\n    const position = vtkCamera.getPosition();\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, centerWorld);\n    mat4.rotate(transform, transform, angle, axis);\n    mat4.translate(transform, transform, [\n      -centerWorld[0],\n      -centerWorld[1],\n      -centerWorld[2],\n    ]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, axis);\n    vec3.transformMat4(newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n  };\n\n  // pseudocode inspired from\n  // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js\n  _dragCallback(evt: EventTypes.InteractionEventType): void {\n    const { element, currentPoints, lastPoints } = evt.detail;\n    const currentPointsCanvas = currentPoints.canvas;\n    const lastPointsCanvas = lastPoints.canvas;\n    const { rotateIncrementDegrees } = this.configuration;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const normalizedPosition = [\n      currentPointsCanvas[0] / width,\n      currentPointsCanvas[1] / height,\n    ];\n\n    const normalizedPreviousPosition = [\n      lastPointsCanvas[0] / width,\n      lastPointsCanvas[1] / height,\n    ];\n\n    const center: Types.Point2 = [width * 0.5, height * 0.5];\n    // NOTE: centerWorld corresponds to the focal point in cornerstone3D\n    const centerWorld = viewport.canvasToWorld(center);\n    const normalizedCenter = [0.5, 0.5];\n\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition[0], 0, 0];\n    const oe = [normalizedPosition[0], 0, 0];\n\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n\n    const nop: Types.Point3 = [op[0], 0, lop];\n    vtkMath.normalize(nop);\n    const noe: Types.Point3 = [oe[0], 0, loe];\n    vtkMath.normalize(noe);\n\n    const dot = vtkMath.dot(nop, noe);\n    if (Math.abs(dot) > 0.0001) {\n      const angleX =\n        -2 *\n        Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n        Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n        rotateIncrementDegrees;\n\n      const upVec = camera.viewUp;\n      const atV = camera.viewPlaneNormal;\n      const rightV: Types.Point3 = [0, 0, 0];\n      const forwardV: Types.Point3 = [0, 0, 0];\n\n      vtkMath.cross(upVec, atV, rightV);\n      vtkMath.normalize(rightV);\n\n      vtkMath.cross(atV, rightV, forwardV);\n      vtkMath.normalize(forwardV);\n      vtkMath.normalize(upVec);\n\n      this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n\n      const angleY =\n        (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n        rotateIncrementDegrees;\n\n      this.rotateCamera(viewport, centerWorld, rightV, angleY);\n\n      viewport.render();\n    }\n  }\n}\n\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  utilities,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * ProbeTool let you get the underlying voxel value by putting a probe in that\n * location. It will give index of the location and value of the voxel.\n * You can use ProbeTool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Probe tool's text box are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * To use the ProbeTool, you first need to add it to cornerstoneTools, then create\n * a toolGroup and add the ProbeTool to it. Finally, setToolActive on the toolGroup\n *\n * ```js\n * cornerstoneTools.addTool(ProbeTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(ProbeTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(ProbeTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n *\n */\nclass ProbeTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  // Not necessary for this tool but needs to be defined since it's an abstract\n  // method from the parent class.\n  isPointNearTool(): boolean {\n    return false;\n  }\n\n  toolSelectedCallback() {}\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Probe Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It checks if the mouse click is near ProveTool, it overwrites the baseAnnotationTool\n   * getHandleNearImagePoint method.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: ProbeAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const point = data.handles.points[0];\n    const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n    const near =\n      vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n    if (near === true) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ProbeAnnotation\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      //handle, // This would be useful for other tools with more than one handle\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { viewportId } = enabledElement;\n    this.eventDispatchDetail = {\n      viewportId,\n      renderingEngineId: renderingEngine.id,\n    };\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragCallback = (evt) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points[0] = [...worldPos];\n    annotation.invalidated = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the probe annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ProbeAnnotation;\n      const annotationUID = annotation.annotationUID;\n      const data = annotation.data;\n      const point = data.handles.points[0];\n      const canvasCoordinates = viewport.worldToCanvas(point);\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (!data.cachedStats[targetId]) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          index: null,\n          value: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        [canvasCoordinates],\n        { color }\n      );\n\n      renderStatus = true;\n\n      const isPreScaled = isViewportPreScaled(viewport, targetId);\n\n      const textLines = this._getTextLines(data, targetId, isPreScaled);\n      if (textLines) {\n        const textCanvasCoordinates = [\n          canvasCoordinates[0] + 6,\n          canvasCoordinates[1] - 6,\n        ];\n\n        const textUID = '0';\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textUID,\n          textLines,\n          [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n          this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _getTextLines(\n    data,\n    targetId: string,\n    isPreScaled: boolean\n  ): string[] | undefined {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, Modality, value, SUVBw, SUVLbm, SUVBsa } = cachedVolumeStats;\n\n    if (value === undefined && SUVBw === undefined) {\n      return;\n    }\n\n    const textLines = [];\n    const unit = getModalityUnit(Modality, isPreScaled);\n\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n    // Check if we have scaling for the other 2 SUV types for the PET.\n    if (Modality === 'PT' && isPreScaled === true && SUVBw !== undefined) {\n      textLines.push(`${SUVBw.toFixed(2)} SUV bw`);\n      if (SUVLbm) {\n        textLines.push(`${SUVLbm.toFixed(2)} SUV lbm`);\n      }\n      if (SUVBsa) {\n        textLines.push(`${SUVBsa.toFixed(2)} SUV bsa`);\n      }\n    } else {\n      textLines.push(`${value.toFixed(2)} ${unit}`);\n    }\n\n    return textLines;\n  }\n\n  _getValueForModality(value, imageVolume, modality) {\n    const values = {};\n\n    values['value'] = value;\n\n    // Check if we have scaling for the other 2 SUV types for the PET.\n    if (\n      modality === 'PT' &&\n      imageVolume.scaling.PET &&\n      (imageVolume.scaling.PET.suvbwToSuvbsa ||\n        imageVolume.scaling.PET.suvbwToSuvlbm)\n    ) {\n      const { suvbwToSuvlbm, suvbwToSuvbsa } = imageVolume.scaling.PET;\n\n      values['SUVBw'] = value;\n\n      if (suvbwToSuvlbm) {\n        const SUVLbm = value * suvbwToSuvlbm;\n        values['SUVLbm'] = SUVLbm;\n      }\n\n      if (suvbwToSuvbsa) {\n        const SUVBsa = value * suvbwToSuvbsa;\n        values['SUVBsa'] = SUVBsa;\n      }\n    }\n\n    return values;\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos = data.handles.points[0];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const modality = metadata.Modality;\n      const index = transformWorldToIndex(imageData, worldPos);\n\n      index[0] = Math.round(index[0]);\n      index[1] = Math.round(index[1]);\n      index[2] = Math.round(index[2]);\n\n      if (csUtils.indexWithinDimensions(index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        const value =\n          scalarData[index[2] * zMultiple + index[1] * yMultiple + index[0]];\n\n        // Index[2] for stackViewport is always 0, but for visualization\n        // we reset it to be imageId index\n        if (targetId.startsWith('imageId:')) {\n          const imageId = targetId.split('imageId:')[1];\n          const imageURI = csUtils.imageIdToURI(imageId);\n          const viewports = utilities.getViewportsWithImageURI(\n            imageURI,\n            renderingEngineId\n          );\n\n          const viewport = viewports[0];\n\n          index[2] = viewport.getCurrentImageIdIndex();\n        }\n\n        const values = this._getValueForModality(value, image, modality);\n\n        cachedStats[targetId] = {\n          index,\n          ...values,\n          Modality: modality,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          index,\n          Modality: modality,\n        };\n      }\n\n      annotation.invalidated = false;\n\n      // Dispatching annotation modified\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    return cachedStats;\n  }\n}\n\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  PublicToolProps,\n  SVGDrawingHelper,\n  ToolProps,\n} from '../../types';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nclass DragProbeTool extends ProbeTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  postMouseDownCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation: ProbeAnnotation = {\n      invalidated: true,\n      highlighted: true,\n      isVisible: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  postTouchStartCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    return this.postMouseDownCallback(evt);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const annotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      [this.editData.annotation]\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const annotation = this.editData.annotation;\n    const annotationUID = annotation.annotationUID;\n    const data = annotation.data;\n    const point = data.handles.points[0];\n    const canvasCoordinates = viewport.worldToCanvas(point);\n\n    styleSpecifier.annotationUID = annotationUID;\n\n    const color = this.getStyle('color', styleSpecifier, annotation);\n\n    if (!data.cachedStats[targetId]) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        index: null,\n        value: null,\n      };\n\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    } else if (annotation.invalidated) {\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    }\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const handleGroupUID = '0';\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      [canvasCoordinates],\n      { color }\n    );\n\n    renderStatus = true;\n\n    const isPreScaled = isViewportPreScaled(viewport, targetId);\n\n    const textLines = this._getTextLines(data, targetId, isPreScaled);\n    if (textLines) {\n      const textCanvasCoordinates = [\n        canvasCoordinates[0] + 6,\n        canvasCoordinates[1] - 6,\n      ];\n\n      const textUID = '0';\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textUID,\n        textLines,\n        [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n    }\n\n    return renderStatus;\n  };\n}\n\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n","import { BaseTool } from './base';\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  StackViewport,\n  utilities,\n  cache,\n  Types,\n} from '@cornerstonejs/core';\nimport { EventTypes } from '../types';\n\n// Todo: should move to configuration\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\n\n/**\n * WindowLevel tool manipulates the windowLevel applied to a viewport. It\n * provides a way to set the windowCenter and windowWidth of a viewport\n * by dragging mouse over the image.\n *\n */\nclass WindowLevelTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this.mouseDragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    let volumeId,\n      lower,\n      upper,\n      modality,\n      newRange,\n      viewportsContainingVolumeUID;\n    let isPreScaled = false;\n\n    if (viewport instanceof VolumeViewport) {\n      const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n      volumeId = targetId.split('volumeId:')[1];\n      viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n      const properties = viewport.getProperties();\n      ({ lower, upper } = properties.voiRange);\n      const volume = cache.getVolume(volumeId);\n      modality = volume.metadata.Modality;\n      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n    } else if (viewport instanceof StackViewport) {\n      const properties = viewport.getProperties();\n      modality = viewport.modality;\n      ({ lower, upper } = properties.voiRange);\n      const { preScale } = viewport.getImageData();\n      isPreScaled = preScale.scaled;\n    } else {\n      throw new Error('Viewport is not a valid type');\n    }\n\n    // If modality is PT, treat it special to not include the canvas delta in\n    // the x direction. For other modalities, use the canvas delta in both\n    // directions, and if the viewport is a volumeViewport, the multiplier\n    // is calculate using the volume min and max.\n    if (modality === PT && isPreScaled) {\n      newRange = this.getPTNewRange({\n        deltaPointsCanvas: deltaPoints.canvas,\n        lower,\n        upper,\n        clientHeight: element.clientHeight,\n      });\n    } else {\n      newRange = this.getNewRange({\n        viewport,\n        deltaPointsCanvas: deltaPoints.canvas,\n        volumeId,\n        lower,\n        upper,\n      });\n    }\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: newRange,\n      });\n\n      viewport.render();\n      return;\n    }\n\n    if (viewport instanceof VolumeViewport) {\n      viewport.setProperties({\n        voiRange: newRange,\n      });\n\n      viewportsContainingVolumeUID.forEach((vp) => {\n        vp.render();\n      });\n      return;\n    }\n  }\n\n  getPTNewRange({ deltaPointsCanvas, lower, upper, clientHeight }) {\n    const deltaY = deltaPointsCanvas[1];\n    const multiplier = 5 / clientHeight;\n    const wcDelta = deltaY * multiplier;\n\n    upper -= wcDelta;\n    upper = Math.max(upper, 0.1);\n\n    return { lower, upper };\n  }\n\n  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n    const multiplier =\n      this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n      DEFAULT_MULTIPLIER;\n\n    const wwDelta = deltaPointsCanvas[0] * multiplier;\n    const wcDelta = deltaPointsCanvas[1] * multiplier;\n\n    let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\n      lower,\n      upper\n    );\n\n    windowWidth += wwDelta;\n    windowCenter += wcDelta;\n\n    windowWidth = Math.max(windowWidth, 1);\n\n    // Convert back to range\n    return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n  }\n\n  _getMultiplierFromDynamicRange(viewport, volumeId) {\n    let imageDynamicRange;\n\n    if (volumeId) {\n      const imageVolume = cache.getVolume(volumeId);\n      const { dimensions } = imageVolume;\n      const scalarData = imageVolume.getScalarData();\n      const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(\n        scalarData,\n        dimensions\n      );\n      const BitsStored = imageVolume?.metadata?.BitsStored;\n      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n      // Burned in Pixels often use pixel values above the BitsStored.\n      // This results in a multiplier which is way higher than what you would\n      // want in practice. Thus we take the min between the metadata dynamic\n      // range and actual middel slice dynamic range.\n      imageDynamicRange = Math.min(\n        calculatedDynamicRange,\n        metadataDynamicRange\n      );\n    } else {\n      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n    }\n\n    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (ratio > 1) {\n      multiplier = Math.round(ratio);\n    }\n    return multiplier;\n  }\n\n  _getImageDynamicRangeFromViewport(viewport) {\n    const { imageData } = viewport.getImageData();\n    const dimensions = imageData.getDimensions();\n\n    let scalarData;\n    // if getScalarData is a method on imageData\n    if (imageData.getScalarData) {\n      scalarData = imageData.getScalarData();\n    } else {\n      scalarData = imageData.getPointData().getScalars();\n    }\n\n    if (dimensions[2] !== 1) {\n      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n    }\n\n    let range;\n    if (scalarData.getRange) {\n      range = scalarData.getRange();\n    } else {\n      const { min, max } = this._getMinMax(scalarData, scalarData.length);\n      range = [min, max];\n    }\n\n    return range[1] - range[0];\n  }\n\n  _getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n    const middleSliceIndex = Math.floor(dimensions[2] / 2);\n\n    const frameLength = dimensions[0] * dimensions[1];\n    let bytesPerVoxel;\n    let TypedArrayConstructor;\n\n    if (scalarData instanceof Float32Array) {\n      bytesPerVoxel = 4;\n      TypedArrayConstructor = Float32Array;\n    } else if (scalarData instanceof Uint8Array) {\n      bytesPerVoxel = 1;\n      TypedArrayConstructor = Uint8Array;\n    } else if (scalarData instanceof Uint16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Uint16Array;\n    } else if (scalarData instanceof Int16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Int16Array;\n    }\n\n    const buffer = scalarData.buffer;\n    const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n    const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n\n    const { max, min } = this._getMinMax(frame, frameLength);\n\n    return max - min;\n  };\n\n  private _getMinMax(frame: Uint8Array | Float32Array, frameLength: number) {\n    let min = Infinity;\n    let max = -Infinity;\n\n    for (let i = 0; i < frameLength; i++) {\n      const voxel = frame[i];\n\n      if (voxel < min) {\n        min = voxel;\n      }\n\n      if (voxel > max) {\n        max = voxel;\n      }\n    }\n    return { max, min };\n  }\n}\n\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement, Types } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * ZoomTool tool manipulates the camera zoom applied to a viewport. It\n * provides a way to set the zoom of a viewport by dragging mouse over the image.\n *\n */\nclass ZoomTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  initialMousePosWorld: Types.Point3;\n  dirVec: Types.Point3;\n\n  // Apparently TS says super _must_ be the first call? This seems a bit opinionated.\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        // whether zoom to the center of the image OR zoom to the mouse position\n        zoomToCenter: false,\n        minZoomScale: 0.1,\n        maxZoomScale: 30,\n        pinchToZoom: true,\n        pan: true,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.initialMousePosWorld = [0, 0, 0];\n    this.dirVec = [0, 0, 0];\n    if (this.configuration.pinchToZoom) {\n      this.touchDragCallback = this._pinchCallback.bind(this);\n    } else {\n      this.touchDragCallback = this._dragCallback.bind(this);\n    }\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint } = camera;\n\n    this.initialMousePosWorld = worldPos;\n\n    // The direction vector from the clicked location to the focal point\n    // which would act as the vector to translate the image (if zoomToCenter is false)\n    let dirVec = vec3.fromValues(\n      focalPoint[0] - worldPos[0],\n      focalPoint[1] - worldPos[1],\n      focalPoint[2] - worldPos[2]\n    );\n\n    dirVec = vec3.normalize(vec3.create(), dirVec);\n\n    this.dirVec = dirVec as Types.Point3;\n\n    // we should not return true here, returning true in the preMouseDownCallback\n    // means that the event is handled by the tool and no other methods\n    // can claim the event, which will result in a bug where having Zoom on primary\n    // and clicking on an annotation will not manipulate the annotation, but will\n    // instead zoom the image (which is not what we want), so we return false here\n    return false;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (!this.configuration.pinchToZoom) {\n      return this.preMouseDownCallback(evt);\n    }\n  };\n\n  _pinchCallback(evt: EventTypes.InteractionEventType) {\n    const pointsList = (evt as EventTypes.TouchStartEventType).detail\n      .currentPointsList;\n\n    if (pointsList.length > 1) {\n      const { element, currentPoints } = evt.detail;\n      const enabledElement = getEnabledElement(element);\n      const { viewport } = enabledElement;\n      const camera = viewport.getCamera();\n      const worldPos = currentPoints.world;\n      const { focalPoint } = camera;\n      this.initialMousePosWorld = worldPos;\n      // The direction vector from the clicked location to the focal point\n      // which would act as the vector to translate the image (if zoomToCenter is false)\n      let dirVec = vec3.fromValues(\n        focalPoint[0] - worldPos[0],\n        focalPoint[1] - worldPos[1],\n        focalPoint[2] - worldPos[2]\n      );\n      dirVec = vec3.normalize(vec3.create(), dirVec);\n\n      this.dirVec = dirVec as Types.Point3;\n      if (camera.parallelProjection) {\n        this._dragParallelProjection(evt, viewport, camera, true);\n      } else {\n        this._dragPerspectiveProjection(evt, viewport, camera, true);\n      }\n      viewport.render();\n    }\n\n    if (this.configuration.pan) {\n      this._panCallback(evt);\n    }\n  }\n\n  // Takes ICornerstoneEvent, Mouse or Touch\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n\n    if (camera.parallelProjection) {\n      this._dragParallelProjection(evt, viewport, camera);\n    } else {\n      this._dragPerspectiveProjection(evt, viewport, camera);\n    }\n\n    viewport.render();\n  }\n\n  _dragParallelProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { parallelScale, focalPoint, position } = camera;\n\n    const zoomScale = 1.5 / size[1];\n    const k = deltaY * zoomScale;\n\n    let parallelScaleToSet = (1.0 - k) * parallelScale;\n\n    let focalPointToSet = focalPoint;\n    let positionToSet = position;\n\n    // if we're not zooming to the center, we need to adjust the focal point\n    // and position to set the focal point and position to the value that\n    // would simulate the zoom to the mouse position\n    if (!this.configuration.zoomToCenter) {\n      // Distance of the initial mouse position (world) to the focal point\n      // which is always the center of the canvas.\n      const distanceToCanvasCenter = vec3.distance(\n        focalPoint,\n        this.initialMousePosWorld\n      );\n      // const initialYDistanceBetweenInitialAndFocalPoint;\n\n      // we need to move in the direction of the vector between the focal point\n      // and the initial mouse position by some amount until ultimately we\n      // reach the mouse position at the focal point\n      const zoomScale = 5 / size[1];\n      const k = deltaY * zoomScale;\n      parallelScaleToSet = (1.0 - k) * parallelScale;\n\n      positionToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        position,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n\n      focalPointToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        focalPoint,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n    }\n\n    // If it is a regular GPU accelerated viewport, then parallel scale\n    // has a physical meaning and we can use that to determine the threshold\n    // Added spacing preset in case there is no imageData on viewport\n    const imageData = viewport.getImageData();\n    let spacing = [1, 1, 1];\n    if (imageData) {\n      spacing = imageData.spacing;\n    }\n\n    const { minZoomScale, maxZoomScale } = this.configuration;\n\n    const t = element.clientHeight * spacing[1] * 0.5;\n    const scale = t / parallelScaleToSet;\n\n    let cappedParallelScale = parallelScaleToSet;\n    let thresholdExceeded = false;\n\n    if (imageData) {\n      if (scale < minZoomScale) {\n        cappedParallelScale = t / minZoomScale;\n        thresholdExceeded = true;\n      } else if (scale >= maxZoomScale) {\n        cappedParallelScale = t / maxZoomScale;\n        thresholdExceeded = true;\n      }\n    }\n\n    viewport.setCamera({\n      parallelScale: cappedParallelScale,\n      focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n      position: thresholdExceeded ? position : positionToSet,\n    });\n  };\n\n  _dragPerspectiveProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { position, focalPoint, viewPlaneNormal } = camera;\n\n    const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n    const zoomScale = Math.sqrt(distance) / size[1];\n\n    const directionOfProjection = [\n      -viewPlaneNormal[0],\n      -viewPlaneNormal[1],\n      -viewPlaneNormal[2],\n    ];\n\n    const k = deltaY * zoomScale;\n\n    let tmp = k * directionOfProjection[0];\n    position[0] += tmp;\n    focalPoint[0] += tmp;\n\n    tmp = k * directionOfProjection[1];\n    position[1] += tmp;\n    focalPoint[1] += tmp;\n\n    tmp = k * directionOfProjection[2];\n    position[2] += tmp;\n    focalPoint[2] += tmp;\n\n    viewport.setCamera({ position, focalPoint });\n  };\n\n  _panCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import {\n  getEnabledElementByIds,\n  VolumeViewport,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { scroll } from '../utilities';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The StackScrollTool is a tool that allows the user to scroll through a\n * stack of images by pressing the mouse click and dragging\n */\nclass StackScrollTool extends BaseTool {\n  static toolName;\n  deltaY: number;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.deltaY = 1;\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n\n    const targetId = this.getTargetId(viewport);\n    const { debounceIfNotLoaded, invert, loop } = this.configuration;\n\n    const deltaPointY = deltaPoints.canvas[1];\n\n    let volumeId;\n    if (viewport instanceof VolumeViewport) {\n      volumeId = targetId.split('volumeId:')[1];\n    }\n\n    const pixelsPerImage = this._getPixelPerImage(viewport);\n    const deltaY = deltaPointY + this.deltaY;\n\n    if (!pixelsPerImage) {\n      return;\n    }\n\n    if (Math.abs(deltaY) >= pixelsPerImage) {\n      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n\n      scroll(viewport, {\n        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n        volumeId,\n        debounceLoading: debounceIfNotLoaded,\n        loop: loop\n      });\n\n      this.deltaY = deltaY % pixelsPerImage;\n    } else {\n      this.deltaY = deltaY;\n    }\n  }\n\n  _getPixelPerImage(viewport) {\n    const { element } = viewport;\n    const numberOfSlices = this._getNumberOfSlices(viewport);\n\n    // The Math.max here makes it easier to mouseDrag-scroll small or really large image stacks\n    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n  }\n\n  _getNumberOfSlices(viewport) {\n    if (viewport instanceof VolumeViewport) {\n      const { numberOfSlices } =\n        csUtils.getImageSliceDataForVolumeViewport(viewport);\n      return numberOfSlices;\n    } else if (viewport instanceof StackViewport) {\n      return viewport.getImageIds().length;\n    }\n  }\n}\n\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Line = [Types.Point3, Types.Point3];\n\n/**\n * It returns the angle between two lines in degrees.\n * @param line1 - Line = [p1, p2]\n * @param line2 - Line = [p3, p4]\n * @returns The angle between two lines in degrees.\n */\nexport default function angleBetweenLines(line1: Line, line2: Line): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec3.sub(vec3.create(), p2, p1);\n  const v2 = vec3.sub(vec3.create(), p3, p4);\n\n  const dot = vec3.dot(v1, v2);\n\n  const v1Length = vec3.length(v1);\n  const v2Length = vec3.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n\n  const radian = Math.acos(cos);\n\n  return (radian * 180) / Math.PI;\n}\n","import {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Types,\n} from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The PlanarRotateTool is a tool that allows the user to rotate\n * the image by pressing the mouse click and dragging\n */\nclass PlanarRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n  mouseDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  _dragCallback(evt: EventTypes.MouseDragEventType) {\n    const { element, currentPoints, startPoints } = evt.detail;\n    const currentPointWorld = currentPoints.world;\n    const startPointWorld = startPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const centerCanvas: Types.Point2 = [width * 0.5, height * 0.5];\n    const centerWorld = viewport.canvasToWorld(centerCanvas);\n\n    let angle = angleBetweenLines(\n      [startPointWorld, centerWorld],\n      [centerWorld, currentPointWorld]\n    );\n\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n    const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n    const cross = vec3.cross(vec3.create(), v1, v2);\n    if (vec3.dot(viewPlaneNormal, cross) > 0) {\n      angle = -angle;\n    }\n\n    if (Number.isNaN(angle)) return;\n\n    if (viewport instanceof BaseVolumeViewport) {\n      const rotAngle = (angle * Math.PI) / 180;\n      const rotMat = mat4.identity(new Float32Array(16));\n      mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n      const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n      viewport.setCamera({ viewUp: rotatedViewUp as Types.Point3 });\n    } else {\n      const { rotation } = (viewport as Types.IStackViewport).getProperties();\n      viewport.setProperties({ rotation: rotation + angle });\n    }\n\n    viewport.render();\n  }\n}\n\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import {\n  getEnabledElement,\n  VolumeViewport,\n  StackViewport,\n} from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { MouseWheelEventType } from '../types/EventTypes';\nimport { scrollVolume } from '../utilities/scroll';\n\n/**\n * The StackScrollMouseWheelTool is a tool that allows the user to scroll through a\n * stack of images using the mouse wheel\n */\nclass StackScrollMouseWheelTool extends BaseTool {\n  static toolName;\n\n  _configuration: any;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType): void {\n    const { wheel, element } = evt.detail;\n    const { direction } = wheel;\n    const { invert } = this.configuration;\n    const { viewport } = getEnabledElement(element);\n    const delta = direction * (invert ? -1 : 1);\n\n    if (viewport instanceof StackViewport) {\n      viewport.scroll(\n        delta,\n        this.configuration.debounceIfNotLoaded,\n        this.configuration.loop\n      );\n    } else if (viewport instanceof VolumeViewport) {\n      const targetId = this.getTargetId(viewport);\n      const volumeId = targetId.split('volumeId:')[1];\n      // TODO: add loop implemention for scroll volume.\n      scrollVolume(viewport, volumeId, delta);\n    } else {\n      throw new Error('StackScrollMouseWheelTool: Unsupported viewport type');\n    }\n  }\n}\n\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\nexport default StackScrollMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { mat4, vec3 } from 'gl-matrix';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { MouseWheelEventType } from '../types/EventTypes';\n\nconst DIRECTIONS = {\n  X: [1, 0, 0],\n  Y: [0, 1, 0],\n  Z: [0, 0, 1],\n  CUSTOM: [],\n};\n\n/**\n * Tool that rotates the camera on mouse wheel.\n * It rotates the camera around the focal point, and around a defined axis. Default\n * axis is set to be Z axis, but it can be configured to any custom normalized axis.\n *\n */\nclass VolumeRotateMouseWheelTool extends BaseTool {\n  static toolName;\n  _configuration: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        direction: DIRECTIONS.Z,\n        rotateIncrementDegrees: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType) {\n    // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js#L73\n    const { element, wheel } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { direction, rotateIncrementDegrees } = this.configuration;\n\n    const camera = viewport.getCamera();\n    const { viewUp, position, focalPoint } = camera;\n\n    const { direction: deltaY } = wheel;\n\n    const [cx, cy, cz] = focalPoint;\n    const [ax, ay, az] = direction;\n\n    const angle = deltaY * rotateIncrementDegrees;\n\n    // position[3] = 1.0\n    // focalPoint[3] = 1.0\n    // viewUp[3] = 0.0\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    vec3.transformMat4(<Types.Point3>newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n\n    viewport.render();\n  }\n}\n\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\nimport { PublicToolProps, ToolProps } from '../types';\n\n/**\n * On a Maximum Intensity Projection (MIP) viewport, MIPJumpToClickTool allows the\n * user to click on a point in the MIP and the targetViewportIdS (provided in the\n * tool configuration) will be scrolled (jumped) to the location of the point with\n * the highest intensity value in the MIP.\n */\nclass MIPJumpToClickTool extends BaseTool {\n  static toolName;\n\n  _bounds: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        targetViewportIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Handles the click event, and move the camera's focal point the brightest\n   * point that is in the line of sight of camera. This function 1) search for the\n   * brightest point in the line of sight, 2) move the camera to that point,\n   * this triggers a cameraModified event which then 4) moves all other synced\n   * viewports and their crosshairs.\n   *\n   * @param evt - click event\n   */\n  mouseClickCallback(evt): void {\n    const { element, currentPoints } = evt.detail;\n\n    // 1. Getting the enabled element\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    // 2. Getting the target volume that is clicked on\n    const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n\n    if (!targetId.startsWith('volumeId')) {\n      throw new Error(\n        `MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`\n      );\n    }\n\n    const volumeId = targetId.split('volumeId:')[1];\n\n    // 3. Criteria function to search for the point (maximum intensity)\n    let maxIntensity = -Infinity;\n    const maxFn = (intensity, point) => {\n      if (intensity > maxIntensity) {\n        maxIntensity = intensity;\n        return point;\n      }\n    };\n\n    // 4. Search for the brightest point location in the line of sight\n    const brightestPoint = getPointInLineOfSightWithCriteria(\n      viewport as Types.IVolumeViewport,\n      currentPoints.world,\n      volumeId,\n      maxFn\n    );\n\n    if (!brightestPoint || !brightestPoint.length) {\n      return;\n    }\n\n    const { targetViewportIds } = this.configuration;\n\n    // 6. Update all the targetedViewports to jump\n    targetViewportIds.forEach((viewportId) => {\n      // Todo: current limitation is that we cannot jump in viewports\n      // that don't belong to the renderingEngine of the source clicked viewport\n      const viewport = renderingEngine.getViewport(viewportId);\n\n      if (viewport instanceof VolumeViewport) {\n        jumpToWorld(viewport, brightestPoint);\n      } else {\n        console.warn(\n          'Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport'\n        );\n      }\n    });\n  }\n}\n\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * LengthTool let you draw annotations that measures the length of two drawing\n * points on a slice. You can use the LengthTool in all imaging planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(LengthTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(LengthTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(LengthTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n\n */\n\nclass LengthTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): LengthAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LengthAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as LengthAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      // Todo: move these into annotationTool class\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit === undefined\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const textLines = this._getTextLines(data, targetId);\n\n      // Need to update to sync w/ annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  // text line for the current active length annotation\n  _getTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { length, unit } = cachedVolumeStats;\n\n    // Can be null on load\n    if (length === undefined || length === null || isNaN(length)) {\n      return;\n    }\n\n    const textLines = [`${length.toFixed(2)} ${unit}`];\n\n    return textLines;\n  }\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions, hasPixelSpacing } = image;\n\n      const length = this._calculateLength(worldPos1, worldPos2);\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n\n      this._isInsideVolume(index1, index2, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\n      // corner is off the canvas.\n\n      // todo: add insideVolume calculation, for removing tool if outside\n      cachedStats[targetId] = {\n        length,\n        unit: hasPixelSpacing ? 'mm' : 'px',\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\n\nimport { AnnotationTool } from './base';\n\nimport {\n  getEnabledElementByIds,\n  getEnabledElement,\n  utilities as csUtils,\n  Enums,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../store/ToolGroupManager';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\n\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\n\nimport * as lineSegment from '../utilities/math/line';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../types';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { RENDERING_DEFAULTS } = CONSTANTS;\n\n// TODO: nested config is weird\ninterface ToolConfiguration {\n  configuration?: {\n    getReferenceLineColor?: (viewportId: string) => string;\n    getReferenceLineControllable?: (viewportId: string) => boolean;\n    getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n    getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n    shadow?: boolean;\n    autopan?: {\n      enabled: boolean;\n      panSize: number;\n    };\n    mobile?: {\n      enabled: boolean;\n      opacity: number;\n      handleRadius: number;\n    };\n  };\n}\n\ninterface CrosshairsAnnotation extends Annotation {\n  data: {\n    handles: {\n      rotationPoints: any[]; // rotation handles, used for rotation interactions\n      slabThicknessPoints: any[]; // slab thickness handles, used for setting the slab thickness\n      activeOperation: number | null; // 0 translation, 1 rotation handles, 2 slab thickness handles\n      toolCenter: Types.Point3;\n    };\n    activeViewportIds: string[]; // a list of the viewport ids connected to the reference lines being translated\n    viewportId: string;\n  };\n}\n\nfunction defaultReferenceLineColor() {\n  return 'rgb(0, 200, 0)';\n}\n\nfunction defaultReferenceLineControllable() {\n  return true;\n}\n\nfunction defaultReferenceLineDraggableRotatable() {\n  return true;\n}\n\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n  return true;\n}\n\nconst OPERATION = {\n  DRAG: 1,\n  ROTATE: 2,\n  SLAB: 3,\n};\n\nconst EPSILON = 1e-3;\n\n/**\n * CrosshairsTool is a tool that provides reference lines between different viewports\n * of a toolGroup. Using crosshairs, you can jump to a specific location in one\n * viewport and the rest of the viewports in the toolGroup will be aligned to that location.\n * Crosshairs have grababble handles that can be used to rotate and translate the\n * reference lines. They can also be used to set the slab thickness of the viewports\n * by modifying the slab thickness handles.\n *\n */\nclass CrosshairsTool extends AnnotationTool {\n  static toolName;\n\n  toolCenter: Types.Point3 = [0, 0, 0]; // NOTE: it is assumed that all the active/linked viewports share the same crosshair center.\n  // This because the rotation operation rotates also all the other active/intersecting reference lines of the same angle\n  _getReferenceLineColor?: (viewportId: string) => string;\n  _getReferenceLineControllable?: (viewportId: string) => boolean;\n  _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n  _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n  editData: {\n    annotation: any;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse'],\n      configuration: {\n        shadow: true,\n        // renders a colored circle on top right of the viewports whose color\n        // matches the color of the reference line\n        viewportIndicators: true,\n        // Auto pan is a configuration which will update pan\n        // other viewports in the toolGroup if the center of the crosshairs\n        // is outside of the viewport. This might be useful for the case\n        // when the user is scrolling through an image (usually in the zoomed view)\n        // and the crosshairs will eventually get outside of the viewport for\n        // the other viewports.\n        autoPan: {\n          enabled: false,\n          panSize: 10,\n        },\n        // actorUIDs for slabThickness application, if not defined, the slab thickness\n        // will be applied to all actors of the viewport\n        filterActorUIDsToSetSlabThickness: [],\n        // blend mode for slabThickness modifications\n        slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n        mobile: {\n          enabled: false,\n          opacity: 0.8,\n          handleRadius: 9,\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._getReferenceLineColor =\n      toolProps.configuration?.getReferenceLineColor ||\n      defaultReferenceLineColor;\n    this._getReferenceLineControllable =\n      toolProps.configuration?.getReferenceLineControllable ||\n      defaultReferenceLineControllable;\n    this._getReferenceLineDraggableRotatable =\n      toolProps.configuration?.getReferenceLineDraggableRotatable ||\n      defaultReferenceLineDraggableRotatable;\n    this._getReferenceLineSlabThicknessControlsOn =\n      toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n      defaultReferenceLineSlabThicknessControlsOn;\n  }\n\n  /**\n   * Gets the camera from the viewport, and adds crosshairs annotation for the viewport\n   * to the annotationManager. If any annotation is found in the annotationManager, it\n   * overwrites it.\n   * @param viewportInfo - The viewportInfo for the viewport to add the crosshairs\n   * @returns viewPlaneNormal and center of viewport canvas in world space\n   */\n  initializeViewport = ({\n    renderingEngineId,\n    viewportId,\n  }: Types.IViewportId): {\n    normal: Types.Point3;\n    point: Types.Point3;\n  } => {\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    const { FrameOfReferenceUID, viewport } = enabledElement;\n    const { element } = viewport;\n    const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n\n    // Check if there is already annotation for this viewport\n    let annotations = this._getAnnotations(enabledElement);\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (annotations.length) {\n      // If found, it will override it by removing the annotation and adding it later\n      removeAnnotation(annotations[0].annotationUID);\n    }\n\n    const annotation = {\n      highlighted: false,\n      metadata: {\n        cameraPosition: <Types.Point3>[...position],\n        cameraFocalPoint: <Types.Point3>[...focalPoint],\n        FrameOfReferenceUID,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          rotationPoints: [], // rotation handles, used for rotation interactions\n          slabThicknessPoints: [], // slab thickness handles, used for setting the slab thickness\n          toolCenter: this.toolCenter,\n        },\n        activeOperation: null, // 0 translation, 1 rotation handles, 2 slab thickness handles\n        activeViewportIds: [], // a list of the viewport ids connected to the reference lines being translated\n        viewportId,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    return {\n      normal: viewPlaneNormal,\n      point: viewport.canvasToWorld([\n        viewport.canvas.clientWidth / 2,\n        viewport.canvas.clientHeight / 2,\n      ]),\n    };\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  onSetToolActive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    // Upon new setVolumes on viewports we need to update the crosshairs\n    // reference points in the new space, so we subscribe to the event\n    // and update the reference points accordingly.\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    this._subscribeToViewportNewVolumeSet(viewportsInfo);\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolPassive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolEnabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolDisabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n\n    // Crosshairs annotations in the state\n    // has no value when the tool is disabled\n    // since viewports can change (zoom, pan, scroll)\n    // between disabled and enabled/active states.\n    // so we just remove the annotations from the state\n    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const annotations = this._getAnnotations(enabledElement);\n\n      if (annotations?.length) {\n        annotations.forEach((annotation) => {\n          removeAnnotation(annotation.annotationUID);\n        });\n      }\n    });\n  }\n\n  /**\n   * When activated, it initializes the crosshairs. It begins by computing\n   * the intersection of viewports associated with the crosshairs instance.\n   * When all three views are accessible, the intersection (e.g., crosshairs tool centre)\n   * will be an exact point in space; however, with two viewports, because the\n   * intersection of two planes is a line, it assumes the last view is between the centre\n   * of the two rendering viewports.\n   * @param viewportsInfo Array of viewportInputs which each item containing {viewportId, renderingEngineId}\n   */\n  computeToolCenter = (viewportsInfo): void => {\n    if (!viewportsInfo.length || viewportsInfo.length === 1) {\n      throw new Error(\n        'For crosshairs to operate, at least two viewports must be given.'\n      );\n    }\n\n    // Todo: handle two same view viewport, or more than 3 viewports\n    const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n\n    // Initialize first viewport\n    const { normal: normal1, point: point1 } =\n      this.initializeViewport(firstViewport);\n\n    // Initialize second viewport\n    const { normal: normal2, point: point2 } =\n      this.initializeViewport(secondViewport);\n\n    let normal3 = <Types.Point3>[0, 0, 0];\n    let point3 = vec3.create();\n\n    // If there are three viewports\n    if (thirdViewport) {\n      ({ normal: normal3, point: point3 } =\n        this.initializeViewport(thirdViewport));\n    } else {\n      // If there are only two views (viewport) associated with the crosshairs:\n      // In this situation, we don't have a third information to find the\n      // exact intersection, and we \"assume\" the third view is looking at\n      // a location in between the first and second view centers\n      vec3.add(point3, point1, point2);\n      vec3.scale(point3, point3, 0.5);\n      vec3.cross(normal3, normal1, normal2);\n    }\n\n    // Planes of each viewport\n    const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n    const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n    const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n\n    // Calculating the intersection of 3 planes\n    // prettier-ignore\n    this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane)\n\n    // assuming all viewports are in the same rendering engine\n    const { renderingEngine } = getEnabledElementByIds(\n      viewportsInfo[0].viewportId,\n      viewportsInfo[0].renderingEngineId\n    );\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * addNewAnnotation acts as jump for the crosshairs tool. It is called when\n   * the user clicks on the image. It does not store the annotation in the stateManager though.\n   *\n   * @param evt - The mouse event\n   * @param interactionType - The type of interaction (e.g., mouse, touch, etc.)\n   * @returns Crosshairs annotation\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CrosshairsAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { currentPoints } = eventDetail;\n    const jumpWorld = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this._jump(enabledElement, jumpWorld);\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      annotations\n    );\n\n    // viewport Annotation\n    const { data } = filteredAnnotations[0];\n\n    const { rotationPoints } = data.handles;\n    const viewportIdArray = [];\n    // put all the draggable reference lines in the viewportIdArray\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n      viewportIdArray.push(otherViewport.id);\n      // rotation handles are two per viewport\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n    // set translation operation\n    data.handles.activeOperation = OPERATION.DRAG;\n\n    evt.preventDefault();\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n    return filteredAnnotations[0];\n  };\n\n  cancel = () => {\n    console.log('Not implemented yet');\n  };\n\n  /**\n   * It checks if the mouse click is near crosshairs handles, if yes\n   * it returns the handle location. If the mouse click is not near any\n   * of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let point = this._getRotationHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n\n    point = this._getSlabThicknessHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n\n    // NOTE: handle index or coordinates are not used when dragging.\n    // This because the handle points are actually generated in the renderTool and they are a derivative\n    // from the camera variables of the viewports and of the slab thickness variable.\n    // Remember that the translation and rotation operations operate on the camera\n    // variables and not really on the handles. Similar for the slab thickness.\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * It returns if the canvas point is near the provided crosshairs annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CrosshairsAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  onCameraModified = (evt) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const viewport = enabledElement.viewport as Types.IVolumeViewport;\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport that the camera modified is originating from\n    const viewportAnnotation =\n      filteredToolAnnotations[0] as CrosshairsAnnotation;\n\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    // -- Update the camera of other linked viewports containing the same volumeId that\n    //    have the same camera in case of translation\n    // -- Update the crosshair center in world coordinates in annotation.\n    // This is necessary because other tools can modify the position of the slices,\n    // e.g. stackScroll tool at wheel scroll. So we update the coordinates of the center always here.\n    // NOTE: rotation and slab thickness handles are created/updated in renderTool.\n    const currentCamera = viewport.getCamera();\n    const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n    const deltaCameraPosition: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.position,\n      oldCameraPosition,\n      deltaCameraPosition\n    );\n\n    const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.focalPoint,\n      oldCameraFocalPoint,\n      deltaCameraFocalPoint\n    );\n\n    // updated cached \"previous\" camera position and focal point\n    viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n    viewportAnnotation.metadata.cameraFocalPoint = [\n      ...currentCamera.focalPoint,\n    ];\n\n    const viewportControllable = this._getReferenceLineControllable(\n      viewport.id\n    );\n    const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(\n      viewport.id\n    );\n    if (\n      !csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n      viewportControllable &&\n      viewportDraggableRotatable\n    ) {\n      // Is camera Modified a TRANSLATION or ROTATION?\n      let isRotation = false;\n\n      // This is guaranteed to be the same diff for both position and focal point\n      // if the camera is modified by pan, zoom, or scroll BUT for rotation of\n      // crosshairs handles it will be different.\n      const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(\n        deltaCameraPosition,\n        deltaCameraFocalPoint,\n        1e-3\n      );\n\n      // NOTE: it is a translation if the the focal point and camera position shifts are the same\n      if (!cameraModifiedSameForPosAndFocalPoint) {\n        isRotation = true;\n      }\n\n      const cameraModifiedInPlane =\n        Math.abs(\n          vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)\n        ) < 1e-2;\n\n      // TRANSLATION\n      // NOTE1: if the camera modified is a result of a pan or zoom don't update the crosshair center\n      // NOTE2: rotation handles are updates in renderTool\n      if (!isRotation && !cameraModifiedInPlane) {\n        this.toolCenter[0] += deltaCameraPosition[0];\n        this.toolCenter[1] += deltaCameraPosition[1];\n        this.toolCenter[2] += deltaCameraPosition[2];\n      }\n    }\n\n    // AutoPan modification\n    if (this.configuration.autoPan?.enabled) {\n      const toolGroup = getToolGroupForViewport(\n        viewport.id,\n        renderingEngine.id\n      );\n\n      const otherViewportIds = toolGroup\n        .getViewportIds()\n        .filter((id) => id !== viewport.id);\n\n      otherViewportIds.forEach((viewportId) => {\n        this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n      });\n    }\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredToolAnnotations: Annotations\n  ): boolean => {\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let imageNeedsUpdate = false;\n\n    for (let i = 0; i < filteredToolAnnotations.length; i++) {\n      const annotation = filteredToolAnnotations[i] as CrosshairsAnnotation;\n\n      if (isAnnotationLocked(annotation)) {\n        continue;\n      }\n\n      const { data, highlighted } = annotation;\n      if (!data.handles) {\n        continue;\n      }\n\n      const previousActiveOperation = data.handles.activeOperation;\n      const previousActiveViewportIds =\n        data.activeViewportIds && data.activeViewportIds.length > 0\n          ? [...data.activeViewportIds]\n          : [];\n\n      // This init are necessary, because when we move the mouse they are not cleaned by _endCallback\n      data.activeViewportIds = [];\n      data.handles.activeOperation = null;\n\n      const handleNearImagePoint = this.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        6\n      );\n\n      let near = false;\n      if (handleNearImagePoint) {\n        near = true;\n      } else {\n        near = this._pointNearTool(element, annotation, canvasCoords, 6);\n      }\n\n      const nearToolAndNotMarkedActive = near && !highlighted;\n      const notNearToolAndMarkedActive = !near && highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !highlighted;\n        imageNeedsUpdate = true;\n      } else if (\n        data.handles.activeOperation !== previousActiveOperation ||\n        !this._areViewportIdArraysEqual(\n          data.activeViewportIds,\n          previousActiveViewportIds\n        )\n      ) {\n        imageNeedsUpdate = true;\n      }\n    }\n\n    return imageNeedsUpdate;\n  };\n\n  filterInteractableAnnotationsForElement = (element, annotations) => {\n    if (!annotations || !annotations.length) {\n      return [];\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n\n    const viewportUIDSpecificCrosshairs = annotations.filter(\n      (annotation) => annotation.data.viewportId === viewportId\n    );\n\n    return viewportUIDSpecificCrosshairs;\n  };\n\n  /**\n   * renders the crosshairs lines and handles in the requestAnimationFrame callback\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n    const annotations = this._getAnnotations(enabledElement);\n    const camera = viewport.getCamera();\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!annotations?.length || !viewportAnnotation?.data) {\n      // No annotations yet, and didn't just create it as we likely don't have a FrameOfReference/any data loaded yet.\n      return renderStatus;\n    }\n\n    const annotationUID = viewportAnnotation.annotationUID;\n\n    // Get cameras/canvases for each of these.\n    // -- Get two world positions for this canvas in this line (e.g. the diagonal)\n    // -- Convert these world positions to this canvas.\n    // -- Extend/confine this line to fit in this canvas.\n    // -- Render this line.\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n\n    const data = viewportAnnotation.data;\n    const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    const otherViewportAnnotations =\n      this._filterAnnotationsByUniqueViewportOrientations(\n        enabledElement,\n        annotations\n      );\n\n    const referenceLines = [];\n\n    otherViewportAnnotations.forEach((annotation) => {\n      const { data } = annotation;\n\n      data.handles.toolCenter = this.toolCenter;\n\n      const otherViewport = renderingEngine.getViewport(\n        data.viewportId\n      ) as Types.IVolumeViewport;\n\n      const otherCamera = otherViewport.getCamera();\n\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const otherViewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      const otherViewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      // get coordinates for the reference line\n      const { clientWidth, clientHeight } = otherViewport.canvas;\n      const otherCanvasDiagonalLength = Math.sqrt(\n        clientWidth * clientWidth + clientHeight * clientHeight\n      );\n      const otherCanvasCenter: Types.Point2 = [\n        clientWidth * 0.5,\n        clientHeight * 0.5,\n      ];\n      const otherViewportCenterWorld =\n        otherViewport.canvasToWorld(otherCanvasCenter);\n\n      const direction: Types.Point3 = [0, 0, 0];\n      vtkMath.cross(\n        camera.viewPlaneNormal,\n        otherCamera.viewPlaneNormal,\n        direction\n      );\n      vtkMath.normalize(direction);\n      vtkMath.multiplyScalar(\n        <Types.Point3>direction,\n        otherCanvasDiagonalLength\n      );\n\n      const pointWorld0: Types.Point3 = [0, 0, 0];\n      vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n\n      const pointWorld1: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n\n      // get canvas information for points and lines (canvas box, canvas horizontal distances)\n      const canvasBox = [0, 0, clientWidth, clientHeight];\n\n      const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n\n      const otherViewportCenterCanvas = viewport.worldToCanvas(\n        otherViewportCenterWorld\n      );\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        pointCanvas0,\n        otherViewportCenterCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      // Graphic:\n      // Mid -> SlabThickness handle\n      // Short -> Rotation handle\n      //                           Long\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      // Long --- Mid--- Short--- Center --- Short --- Mid --- Long\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                           Long\n      const canvasVectorFromCenterLong = vec2.create();\n\n      // Todo: configuration should provide constants below (100, 0.25, 0.15, 0.04)\n      vec2.scale(\n        canvasVectorFromCenterLong,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 100\n      );\n      const canvasVectorFromCenterMid = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterMid,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.25\n      );\n      const canvasVectorFromCenterShort = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterShort,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.15\n      );\n      const canvasVectorFromCenterStart = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        // Don't put a gap if the the third view is missing\n        otherViewportAnnotations.length === 2 ? canvasDiagonalLength * 0.04 : 0\n      );\n\n      // Computing Reference start and end (4 lines per viewport in case of 3 view MPR)\n      const refLinePointOne = vec2.create();\n      const refLinePointTwo = vec2.create();\n      const refLinePointThree = vec2.create();\n      const refLinePointFour = vec2.create();\n\n      let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n      if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n        refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n      vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n      vec2.subtract(\n        refLinePointThree,\n        refLinesCenter,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        refLinePointFour,\n        refLinesCenter,\n        canvasVectorFromCenterLong\n      );\n\n      // Clipping lines to be only included in a box (canvas), we don't want\n      // the lines goes beyond canvas\n      liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n      liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n\n      // Computing rotation handle positions\n      const rotHandleOne = vec2.create();\n      vec2.subtract(\n        rotHandleOne,\n        crosshairCenterCanvas,\n        canvasVectorFromCenterMid\n      );\n\n      const rotHandleTwo = vec2.create();\n      vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n\n      // Computing SlabThickness (st below) position\n\n      // SlabThickness center in canvas\n      let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      // SlabThickness center in world\n      let stHandlesCenterWorld: Types.Point3 = [...this.toolCenter];\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterWorld = [...otherViewportCenterWorld];\n      }\n\n      const worldUnitVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n      vtkMath.normalize(worldUnitVectorFromCenter);\n\n      const { viewPlaneNormal } = camera;\n      // @ts-ignore // Todo: fix after vtk pr merged\n      const { matrix } = vtkMatrixBuilder\n        .buildFromDegree()\n        // @ts-ignore fix after vtk pr merged\n        .rotate(90, viewPlaneNormal);\n\n      const worldUnitOrthoVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vec3.transformMat4(\n        worldUnitOrthoVectorFromCenter,\n        worldUnitVectorFromCenter,\n        matrix\n      );\n\n      const slabThicknessValue = otherViewport.getSlabThickness();\n      const worldOrthoVectorFromCenter: Types.Point3 = [\n        ...worldUnitOrthoVectorFromCenter,\n      ];\n      vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n\n      const worldVerticalRefPoint: Types.Point3 = [0, 0, 0];\n      vtkMath.add(\n        stHandlesCenterWorld,\n        worldOrthoVectorFromCenter,\n        worldVerticalRefPoint\n      );\n\n      // convert vertical world distances in canvas coordinates\n      const canvasVerticalRefPoint = viewport.worldToCanvas(\n        worldVerticalRefPoint\n      );\n\n      // points for slab thickness lines\n      const canvasOrthoVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasOrthoVectorFromCenter,\n        stHandlesCenterCanvas,\n        canvasVerticalRefPoint\n      );\n\n      const stLinePointOne = vec2.create();\n      vec2.subtract(\n        stLinePointOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n\n      const stLinePointTwo = vec2.create();\n      vec2.add(\n        stLinePointTwo,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n\n      liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n\n      const stLinePointThree = vec2.create();\n      vec2.add(\n        stLinePointThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointThree,\n        stLinePointThree,\n        canvasOrthoVectorFromCenter\n      );\n\n      const stLinePointFour = vec2.create();\n      vec2.subtract(\n        stLinePointFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointFour,\n        stLinePointFour,\n        canvasOrthoVectorFromCenter\n      );\n\n      liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n\n      // points for slab thickness handles\n      const stHandleOne = vec2.create();\n      const stHandleTwo = vec2.create();\n      const stHandleThree = vec2.create();\n      const stHandleFour = vec2.create();\n\n      vec2.subtract(\n        stHandleOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n      vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n      vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n      vec2.subtract(\n        stHandleThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n      vec2.add(\n        stHandleFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n\n      referenceLines.push([\n        otherViewport,\n        refLinePointOne,\n        refLinePointTwo,\n        refLinePointThree,\n        refLinePointFour,\n        stLinePointOne,\n        stLinePointTwo,\n        stLinePointThree,\n        stLinePointFour,\n        rotHandleOne,\n        rotHandleTwo,\n        stHandleOne,\n        stHandleTwo,\n        stHandleThree,\n        stHandleFour,\n      ]);\n    });\n\n    const newRtpoints = [];\n    const newStpoints = [];\n    const viewportColor = this._getReferenceLineColor(viewport.id);\n    const color =\n      viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n    referenceLines.forEach((line, lineIndex) => {\n      // get color for the reference line\n      const otherViewport = line[0];\n      const viewportColor = this._getReferenceLineColor(otherViewport.id);\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const selectedViewportId = data.activeViewportIds.find(\n        (id) => id === otherViewport.id\n      );\n\n      let color =\n        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n      let lineWidth = 1;\n\n      const lineActive =\n        data.handles.activeOperation !== null &&\n        data.handles.activeOperation === OPERATION.DRAG &&\n        selectedViewportId;\n\n      if (lineActive) {\n        lineWidth = 2.5;\n      }\n\n      let lineUID = `${lineIndex}`;\n      if (viewportControllable && viewportDraggableRotatable) {\n        lineUID = `${lineIndex}One`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[1],\n          line[2],\n          {\n            color,\n            lineWidth,\n          }\n        );\n\n        lineUID = `${lineIndex}Two`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[3],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      } else {\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[2],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      if (viewportControllable) {\n        color =\n          viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n        const rotHandlesActive =\n          data.handles.activeOperation === OPERATION.ROTATE;\n        const rotationHandles = [line[9], line[10]];\n\n        const rotHandleWorldOne = [\n          viewport.canvasToWorld(line[9]),\n          otherViewport,\n          line[1],\n          line[2],\n        ];\n        const rotHandleWorldTwo = [\n          viewport.canvasToWorld(line[10]),\n          otherViewport,\n          line[3],\n          line[4],\n        ];\n        newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n\n        const slabThicknessHandlesActive =\n          data.handles.activeOperation === OPERATION.SLAB;\n        const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n\n        const slabThicknessHandleWorldOne = [\n          viewport.canvasToWorld(line[11]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldTwo = [\n          viewport.canvasToWorld(line[12]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldThree = [\n          viewport.canvasToWorld(line[13]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        const slabThicknessHandleWorldFour = [\n          viewport.canvasToWorld(line[14]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        newStpoints.push(\n          slabThicknessHandleWorldOne,\n          slabThicknessHandleWorldTwo,\n          slabThicknessHandleWorldThree,\n          slabThicknessHandleWorldFour\n        );\n\n        if (\n          (lineActive || this.configuration.mobile?.enabled) &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw all handles inactive (rotation and slab thickness)\n          let handleUID = `${lineIndex}One`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n          handleUID = `${lineIndex}Two`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (\n          lineActive &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw rotation handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n        } else if (\n          selectedViewportId &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportSlabThicknessControlsOn\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw slab thickness handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (rotHandlesActive && viewportDraggableRotatable) {\n          const handleUID = `${lineIndex}`;\n          // draw all rotation handles as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'circle',\n            }\n          );\n        } else if (\n          slabThicknessHandlesActive &&\n          selectedViewportId &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw only the slab thickness handles for the active viewport as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'rect',\n            }\n          );\n        }\n        const slabThicknessValue = otherViewport.getSlabThickness();\n        if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n          // draw slab thickness reference lines\n          lineUID = `${lineIndex}STOne`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[5],\n            line[6],\n            {\n              color,\n              width: 1,\n              lineDash: [2, 3],\n            }\n          );\n\n          lineUID = `${lineIndex}STTwo`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[7],\n            line[8],\n            {\n              color,\n              width: line,\n              lineDash: [2, 3],\n            }\n          );\n        }\n      }\n    });\n\n    renderStatus = true;\n\n    // Save new handles points in annotation\n    data.handles.rotationPoints = newRtpoints;\n    data.handles.slabThicknessPoints = newStpoints;\n\n    if (this.configuration.viewportIndicators) {\n      // render a circle to pin point the viewport color\n      // TODO: This should not be part of the tool, and definitely not part of the renderAnnotation loop\n      const referenceColorCoordinates = [\n        clientWidth * 0.95,\n        clientHeight * 0.05,\n      ] as Types.Point2;\n      const circleRadius = canvasDiagonalLength * 0.01;\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        referenceColorCoordinates,\n        circleRadius,\n        { color, fill: color }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _getAnnotations = (enabledElement: Types.IEnabledElement) => {\n    const { viewport } = enabledElement;\n    return getAnnotations(this.getToolName(), viewport.element);\n  };\n\n  _onNewVolume = (e: any) => {\n    const viewportsInfo = this._getViewportsInfo();\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _subscribeToViewportNewVolumeSet(viewports) {\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.addEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _autoPanViewportIfNecessary(\n    viewportId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): void {\n    // 1. Compute the current world bounding box of the viewport from corner to corner\n    // 2. Check if the toolCenter is outside of the world bounding box\n    // 3. If it is outside, pan the viewport to fit in the toolCenter\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const topLefWorld = viewport.canvasToWorld([0, 0]);\n    const bottomRightWorld = viewport.canvasToWorld([\n      clientWidth,\n      clientHeight,\n    ]);\n    const topRightWorld = viewport.canvasToWorld([clientWidth, 0]);\n    const bottomLeftWorld = viewport.canvasToWorld([0, clientHeight]);\n\n    // find the minimum and maximum world coordinates in each x,y,z\n    const minX = Math.min(\n      topLefWorld[0],\n      bottomRightWorld[0],\n      topRightWorld[0],\n      bottomLeftWorld[0]\n    );\n    const maxX = Math.max(\n      topLefWorld[0],\n      bottomRightWorld[0],\n      topRightWorld[0],\n      bottomLeftWorld[0]\n    );\n    const minY = Math.min(\n      topLefWorld[1],\n      bottomRightWorld[1],\n      topRightWorld[1],\n      bottomLeftWorld[1]\n    );\n    const maxY = Math.max(\n      topLefWorld[1],\n      bottomRightWorld[1],\n      topRightWorld[1],\n      bottomLeftWorld[1]\n    );\n    const minZ = Math.min(\n      topLefWorld[2],\n      bottomRightWorld[2],\n      topRightWorld[2],\n      bottomLeftWorld[2]\n    );\n    const maxZ = Math.max(\n      topLefWorld[2],\n      bottomRightWorld[2],\n      topRightWorld[2],\n      bottomLeftWorld[2]\n    );\n\n    // pan the viewport to fit the toolCenter in the direction\n    // that is out of bounds\n    let deltaPointsWorld;\n    const pan = this.configuration.autoPan.panSize;\n\n    if (this.toolCenter[0] < minX - EPSILON) {\n      deltaPointsWorld = [minX - this.toolCenter[0] + pan, 0, 0];\n    } else if (this.toolCenter[0] > maxX + EPSILON) {\n      deltaPointsWorld = [maxX - this.toolCenter[0] - pan, 0, 0];\n    } else if (this.toolCenter[1] < minY - EPSILON) {\n      deltaPointsWorld = [0, minY - this.toolCenter[1] + pan, 0];\n    } else if (this.toolCenter[1] > maxY + EPSILON) {\n      deltaPointsWorld = [0, maxY - this.toolCenter[1] - pan, 0];\n    } else if (this.toolCenter[2] < minZ - EPSILON) {\n      deltaPointsWorld = [0, 0, minZ - this.toolCenter[2] + pan];\n    } else if (this.toolCenter[2] > maxZ + EPSILON) {\n      deltaPointsWorld = [0, 0, maxZ - this.toolCenter[2] - pan];\n    } else {\n      return;\n    }\n\n    const camera = viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    viewport.render();\n  }\n\n  _areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n    if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n      return false;\n    }\n\n    viewportIdArrayOne.forEach((id) => {\n      let itemFound = false;\n      for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n        if (id === viewportIdArrayTwo[i]) {\n          itemFound = true;\n          break;\n        }\n      }\n      if (itemFound === false) {\n        return false;\n      }\n    });\n\n    return true;\n  };\n\n  // It filters the viewports with crosshairs and only return viewports\n  // that have different camera.\n  _getAnnotationsForViewportsWithDifferentCameras = (\n    enabledElement,\n    annotations\n  ) => {\n    const { viewportId, renderingEngine, viewport } = enabledElement;\n\n    const otherViewportAnnotations = annotations.filter(\n      (annotation) => annotation.data.viewportId !== viewportId\n    );\n\n    if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, position } = camera;\n\n    const viewportsWithDifferentCameras = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { viewportId } = annotation.data;\n        const targetViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfTarget = targetViewport.getCamera();\n\n        return !(\n          csUtils.isEqual(\n            cameraOfTarget.viewPlaneNormal,\n            viewPlaneNormal,\n            1e-2\n          ) && csUtils.isEqual(cameraOfTarget.position, position, 1)\n        );\n      }\n    );\n\n    return viewportsWithDifferentCameras;\n  };\n\n  _filterViewportWithSameOrientation = (\n    enabledElement,\n    referenceAnnotation,\n    annotations\n  ) => {\n    const { renderingEngine } = enabledElement;\n    const { data } = referenceAnnotation;\n    const viewport = renderingEngine.getViewport(data.viewportId);\n\n    const linkedViewportAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      const otherViewport = renderingEngine.getViewport(data.viewportId);\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n\n      return otherViewportControllable === true;\n    });\n\n    if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherViewportsAnnotationsWithSameCameraDirection =\n      linkedViewportAnnotations.filter((annotation) => {\n        const { viewportId } = annotation.data;\n        const otherViewport = renderingEngine.getViewport(viewportId);\n        const otherCamera = otherViewport.getCamera();\n        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n        vtkMath.normalize(otherViewPlaneNormal);\n\n        return (\n          csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n          csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2)\n        );\n      });\n\n    return otherViewportsAnnotationsWithSameCameraDirection;\n  };\n\n  _filterAnnotationsByUniqueViewportOrientations = (\n    enabledElement,\n    annotations\n  ) => {\n    const { renderingEngine, viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable === true\n        );\n      }\n    );\n\n    const otherViewportsAnnotationsWithUniqueCameras = [];\n    // Iterate first on other viewport from the same scene linked\n    for (\n      let i = 0;\n      i < otherLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable !== true\n        );\n      }\n    );\n\n    // Iterate second on other viewport from the same scene non linked\n    for (\n      let i = 0;\n      i < otherNonLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    // Iterate on all the viewport\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n      const annotation = otherViewportAnnotations[i];\n      if (\n        otherViewportsAnnotationsWithUniqueCameras.find(\n          (element) => element === annotation\n        ) === true\n      ) {\n        continue;\n      }\n\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    return otherViewportsAnnotationsWithUniqueCameras;\n  };\n\n  _checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n    const actors = viewport.getActors();\n    const otherViewportActors = otherViewport.getActors();\n\n    let sameScene = true;\n\n    actors.forEach((actor) => {\n      if (\n        actors.length !== otherViewportActors.length ||\n        otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined\n      ) {\n        sameScene = false;\n      }\n    });\n\n    return sameScene;\n  };\n\n  _jump = (enabledElement, jumpWorld) => {\n    state.isInteractingWithTool = true;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const annotations = this._getAnnotations(enabledElement);\n\n    const delta: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n\n    // TRANSLATION\n    // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n\n        const sameScene = this._checkIfViewportsRenderingSameScene(\n          viewport,\n          otherViewport\n        );\n\n        return (\n          this._getReferenceLineControllable(otherViewport.id) &&\n          this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n          sameScene\n        );\n      }\n    );\n\n    if (viewportsAnnotationsToUpdate.length === 0) {\n      state.isInteractingWithTool = false;\n      return false;\n    }\n\n    this._applyDeltaShiftToSelectedViewportCameras(\n      renderingEngine,\n      viewportsAnnotationsToUpdate,\n      delta\n    );\n\n    state.isInteractingWithTool = false;\n\n    return true;\n  };\n\n  _activateModify = (element) => {\n    // mobile sometimes has lingering interaction even when touchEnd triggers\n    // this check allows for multiple handles to be active which doesn't affect\n    // tool usage.\n    state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this.editData.annotation.data.handles.activeOperation = null;\n    this.editData.annotation.data.activeViewportIds = [];\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const delta = eventDetail.deltaPoints.world;\n\n    if (\n      Math.abs(delta[0]) < 1e-3 &&\n      Math.abs(delta[1]) < 1e-3 &&\n      Math.abs(delta[2]) < 1e-3\n    ) {\n      return;\n    }\n\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const annotations = this._getAnnotations(\n      enabledElement\n    ) as CrosshairsAnnotation[];\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    const { handles } = viewportAnnotation.data;\n    const { currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n\n    if (handles.activeOperation === OPERATION.DRAG) {\n      // TRANSLATION\n      // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      this._applyDeltaShiftToSelectedViewportCameras(\n        renderingEngine,\n        viewportsAnnotationsToUpdate,\n        delta\n      );\n    } else if (handles.activeOperation === OPERATION.ROTATE) {\n      // ROTATION\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true\n          );\n        }\n      );\n\n      const dir1 = vec2.create();\n      const dir2 = vec2.create();\n\n      const center: Types.Point3 = [\n        this.toolCenter[0],\n        this.toolCenter[1],\n        this.toolCenter[2],\n      ];\n\n      const centerCanvas = viewport.worldToCanvas(center);\n\n      const finalPointCanvas = eventDetail.currentPoints.canvas;\n      const originalPointCanvas = vec2.create();\n      vec2.sub(\n        originalPointCanvas,\n        finalPointCanvas,\n        eventDetail.deltaPoints.canvas\n      );\n      vec2.sub(dir1, originalPointCanvas, <vec2>centerCanvas);\n      vec2.sub(dir2, finalPointCanvas, <vec2>centerCanvas);\n\n      let angle = vec2.angle(dir1, dir2);\n\n      if (\n        this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)\n      ) {\n        angle *= -1;\n      }\n\n      // Rounding the angle to allow rotated handles to be undone\n      // If we don't round and rotate handles clockwise by 0.0131233 radians,\n      // there's no assurance that the counter-clockwise rotation occurs at\n      // precisely -0.0131233, resulting in the drawn annotations being lost.\n      angle = Math.round(angle * 100) / 100;\n\n      const rotationAxis = viewport.getCamera().viewPlaneNormal;\n      // @ts-ignore : vtkjs incorrect typing\n      const { matrix } = vtkMatrixBuilder\n        .buildFromRadian()\n        .translate(center[0], center[1], center[2])\n        // @ts-ignore\n        .rotate(angle, rotationAxis) //todo: why we are passing\n        .translate(-center[0], -center[1], -center[2]);\n\n      const otherViewportsIds = [];\n      // update camera for the other viewports.\n      // NOTE: The lines then are rendered by the onCameraModified\n      viewportsAnnotationsToUpdate.forEach((annotation) => {\n        const { data } = annotation;\n        data.handles.toolCenter = center;\n\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const camera = otherViewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n\n        viewUp[0] += position[0];\n        viewUp[1] += position[1];\n        viewUp[2] += position[2];\n\n        vec3.transformMat4(focalPoint, focalPoint, matrix);\n        vec3.transformMat4(position, position, matrix);\n        vec3.transformMat4(viewUp, viewUp, matrix);\n\n        viewUp[0] -= position[0];\n        viewUp[1] -= position[1];\n        viewUp[2] -= position[2];\n\n        otherViewport.setCamera({\n          position,\n          viewUp,\n          focalPoint,\n        });\n        otherViewportsIds.push(otherViewport.id);\n      });\n      renderingEngine.renderViewports(otherViewportsIds);\n    } else if (handles.activeOperation === OPERATION.SLAB) {\n      // SLAB THICKNESS\n      // this should be just the active one under the mouse,\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const referenceAnnotations = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportSlabThicknessControlsOn =\n            this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportSlabThicknessControlsOn === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      if (referenceAnnotations.length === 0) {\n        return;\n      }\n      const viewportsAnnotationsToUpdate =\n        this._filterViewportWithSameOrientation(\n          enabledElement,\n          referenceAnnotations[0],\n          annotations\n        );\n\n      const viewportsIds = [];\n      viewportsIds.push(viewport.id);\n      viewportsAnnotationsToUpdate.forEach(\n        (annotation: CrosshairsAnnotation) => {\n          const { data } = annotation;\n\n          const otherViewport = renderingEngine.getViewport(\n            data.viewportId\n          ) as Types.IVolumeViewport;\n          const camera = otherViewport.getCamera();\n          const normal = camera.viewPlaneNormal;\n\n          const dotProd = vtkMath.dot(delta, normal);\n          const projectedDelta: Types.Point3 = [...normal];\n          vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n          if (\n            Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3\n          ) {\n            const mod = Math.sqrt(\n              projectedDelta[0] * projectedDelta[0] +\n                projectedDelta[1] * projectedDelta[1] +\n                projectedDelta[2] * projectedDelta[2]\n            );\n\n            const currentPoint = eventDetail.lastPoints.world;\n            const direction: Types.Point3 = [0, 0, 0];\n\n            const currentCenter: Types.Point3 = [\n              this.toolCenter[0],\n              this.toolCenter[1],\n              this.toolCenter[2],\n            ];\n\n            // use this.toolCenter only if viewportDraggableRotatable\n            const viewportDraggableRotatable =\n              this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n              const { rotationPoints } = this.editData.annotation.data.handles;\n              // Todo: what is a point uid?\n              const otherViewportRotationPoints = rotationPoints.filter(\n                (point) => point[1].uid === otherViewport.id\n              );\n              if (otherViewportRotationPoints.length === 2) {\n                const point1 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[0][3]\n                );\n                const point2 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[1][3]\n                );\n                vtkMath.add(point1, point2, currentCenter);\n                vtkMath.multiplyScalar(<Types.Point3>currentCenter, 0.5);\n              }\n            }\n\n            vtkMath.subtract(currentPoint, currentCenter, direction);\n            const dotProdDirection = vtkMath.dot(direction, normal);\n            const projectedDirection: Types.Point3 = [...normal];\n            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n            const normalizedProjectedDirection: Types.Point3 = [\n              projectedDirection[0],\n              projectedDirection[1],\n              projectedDirection[2],\n            ];\n            vec3.normalize(\n              normalizedProjectedDirection,\n              normalizedProjectedDirection\n            );\n            const normalizedProjectedDelta: Types.Point3 = [\n              projectedDelta[0],\n              projectedDelta[1],\n              projectedDelta[2],\n            ];\n            vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n\n            let slabThicknessValue = otherViewport.getSlabThickness();\n            if (\n              csUtils.isOpposite(\n                normalizedProjectedDirection,\n                normalizedProjectedDelta,\n                1e-3\n              )\n            ) {\n              slabThicknessValue -= mod;\n            } else {\n              slabThicknessValue += mod;\n            }\n\n            slabThicknessValue = Math.abs(slabThicknessValue);\n            slabThicknessValue = Math.max(\n              RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS,\n              slabThicknessValue\n            );\n\n            const near = this._pointNearReferenceLine(\n              viewportAnnotation,\n              canvasCoords,\n              6,\n              otherViewport\n            );\n\n            if (near) {\n              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n            }\n\n            // We want to set the slabThickness for the viewport's actors but\n            // since the crosshairs tool instance has configuration regarding which\n            // actorUIDs (in case of volume -> actorUID = volumeIds) to set the\n            // slabThickness for, we need to delegate the slabThickness setting\n            // to the crosshairs tool instance of the toolGroup since configurations\n            // exist on the toolInstance and each toolGroup has its own crosshairs\n            // tool instance (Otherwise, we would need to set this filterActorUIDsToSetSlabThickness at\n            // the viewport level which makes tool and viewport state convoluted).\n            const toolGroup = getToolGroupForViewport(\n              otherViewport.id,\n              renderingEngine.id\n            );\n            const crosshairsInstance = toolGroup.getToolInstance(\n              this.getToolName()\n            );\n            crosshairsInstance.setSlabThickness(\n              otherViewport,\n              slabThicknessValue\n            );\n\n            viewportsIds.push(otherViewport.id);\n          }\n        }\n      );\n      renderingEngine.renderViewports(viewportsIds);\n    }\n  };\n\n  setSlabThickness(viewport, slabThickness) {\n    let actorUIDs;\n    const { filterActorUIDsToSetSlabThickness } = this.configuration;\n    if (\n      filterActorUIDsToSetSlabThickness &&\n      filterActorUIDsToSetSlabThickness.length > 0\n    ) {\n      actorUIDs = filterActorUIDsToSetSlabThickness;\n    }\n\n    let blendModeToUse = this.configuration.slabThicknessBlendMode;\n    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n      blendModeToUse = Enums.BlendModes.COMPOSITE;\n    }\n\n    const immediate = false;\n    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n    viewport.setSlabThickness(slabThickness, actorUIDs);\n  }\n\n  _isClockWise(a, b, c) {\n    // return true if the rotation is clockwise\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n  }\n\n  _applyDeltaShiftToSelectedViewportCameras(\n    renderingEngine,\n    viewportsAnnotationsToUpdate,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    viewportsAnnotationsToUpdate.forEach((annotation) => {\n      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n    });\n  }\n\n  _applyDeltaShiftToViewportCamera(\n    renderingEngine: Types.IRenderingEngine,\n    annotation,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    const { data } = annotation;\n\n    const viewport = renderingEngine.getViewport(data.viewportId);\n    const camera = viewport.getCamera();\n    const normal = camera.viewPlaneNormal;\n\n    // Project delta over camera normal\n    // (we don't need to pan, we need only to scroll the camera as in the wheel stack scroll tool)\n    const dotProd = vtkMath.dot(delta, normal);\n    const projectedDelta: Types.Point3 = [...normal];\n    vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n    if (\n      Math.abs(projectedDelta[0]) > 1e-3 ||\n      Math.abs(projectedDelta[1]) > 1e-3 ||\n      Math.abs(projectedDelta[2]) > 1e-3\n    ) {\n      const newFocalPoint: Types.Point3 = [0, 0, 0];\n      const newPosition: Types.Point3 = [0, 0, 0];\n\n      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n      vtkMath.add(camera.position, projectedDelta, newPosition);\n\n      viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n      });\n      viewport.render();\n    }\n  }\n\n  _pointNearReferenceLine = (\n    annotation,\n    canvasCoords,\n    proximity,\n    lineViewport\n  ) => {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      if (otherViewport.id !== lineViewport.id) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        return true;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    return false;\n  };\n\n  _getRotationHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length; i++) {\n      const point = rotationPoints[i][0];\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportDraggableRotatable) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.ROTATE;\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _getSlabThicknessHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { slabThicknessPoints } = data.handles;\n\n    for (let i = 0; i < slabThicknessPoints.length; i++) {\n      const point = slabThicknessPoints[i][0];\n      const otherViewport = slabThicknessPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n      if (!viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.SLAB;\n\n        data.activeViewportIds = [otherViewport.id];\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _pointNearTool(element, annotation, canvasCoords, proximity) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const { data } = annotation;\n\n    const { rotationPoints } = data.handles;\n    const { slabThicknessPoints } = data.handles;\n    const viewportIdArray = [];\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id);\n        data.handles.activeOperation = OPERATION.DRAG;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n      const otherViewport = slabThicknessPoints[i][1];\n      if (viewportIdArray.find((id) => id === otherViewport.id)) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const stPointLineCanvas1 = slabThicknessPoints[i][2];\n      const stPointLineCanvas2 = slabThicknessPoints[i][3];\n\n      const centerCanvas = vec2.create();\n      vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n      vec2.scale(centerCanvas, centerCanvas, 0.5);\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        stPointLineCanvas1,\n        centerCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      const canvasVectorFromCenterStart = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.05\n      );\n\n      const stPointLineCanvas1Start = vec2.create();\n      const stPointLineCanvas2Start = vec2.create();\n      vec2.add(\n        stPointLineCanvas1Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        stPointLineCanvas2Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n\n      const lineSegment1 = {\n        start: {\n          x: stPointLineCanvas1Start[0],\n          y: stPointLineCanvas1Start[1],\n        },\n        end: {\n          x: stPointLineCanvas1[0],\n          y: stPointLineCanvas1[1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: stPointLineCanvas2Start[0],\n          y: stPointLineCanvas2Start[1],\n        },\n        end: {\n          x: stPointLineCanvas2[0],\n          y: stPointLineCanvas2[1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id); // we still need this to draw inactive slab thickness handles\n        data.handles.activeOperation = null; // no operation\n      }\n\n      // slab thickness handles are in couples\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n\n    this.editData = {\n      annotation,\n    };\n\n    return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n  }\n}\n\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { vec3 } from 'gl-matrix';\nimport {\n  getRenderingEngines,\n  CONSTANTS,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport { ReferenceLineAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\n/**\n * @public\n */\n\nclass ReferenceLines extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    sourceViewport: any;\n    annotation: ReferenceLineAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceViewportId: '',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // this._throttledCalculateCachedStats = throttle(\n    //   this._calculateCachedStats,\n    //   100,\n    //   { trailing: true }\n    // );\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    // Todo: handle this case where it is too soon to get the rendering engine\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    const sourceViewport = renderingEngine.getViewport(\n      this.configuration.sourceViewportId\n    ) as Types.IVolumeViewport;\n\n    if (!sourceViewport || !sourceViewport.getImageData()) {\n      return;\n    }\n\n    const { element } = sourceViewport;\n    const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n\n    const sourceViewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(sourceViewport);\n\n    let annotation = this.editData.annotation;\n    const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n\n    if (!annotation) {\n      const newAnnotation: ReferenceLineAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: sourceViewportCanvasCornersInWorld,\n          },\n        },\n      };\n\n      addAnnotation(newAnnotation, element);\n      annotation = newAnnotation;\n    } else {\n      this.editData.annotation.data.handles.points =\n        sourceViewportCanvasCornersInWorld;\n    }\n\n    this.editData = {\n      sourceViewport,\n      renderingEngine,\n      annotation,\n    };\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewports\n        .filter((viewport) => viewport.id !== sourceViewport.id)\n        .map((viewport) => viewport.id)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the reference lines\n    // we really don't care which viewport triggered the\n    // camera modification, since we want to update all of them\n    // with respect to the targetViewport\n    this._init();\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport: targetViewport } = enabledElement;\n    const { annotation, sourceViewport } = this.editData;\n\n    let renderStatus = false;\n\n    if (!sourceViewport) {\n      return renderStatus;\n    }\n\n    if (sourceViewport.id === targetViewport.id) {\n      // If the source viewport is the same as the current viewport, we don't need to render\n      return renderStatus;\n    }\n\n    if (!annotation || !annotation?.data?.handles?.points) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n    const { viewPlaneNormal: sourceViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    let pointSetToUse = pointSet1;\n\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const newNormal = vec3.cross(\n      vec3.create(),\n      topBottomVec,\n      topRightVec\n    ) as Types.Point3;\n\n    if (this.isParallel(newNormal, viewPlaneNormal)) {\n      return renderStatus;\n    }\n\n    // check if it is perpendicular to the viewPlaneNormal which means\n    // the line does not intersect the viewPlaneNormal\n    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n      // 'use pointSet2';\n      pointSetToUse = pointSet2;\n    }\n\n    const lineStartWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[0],\n      pointSetToUse[1],\n      targetViewportPlane\n    );\n\n    const lineEndWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[2],\n      pointSetToUse[3],\n      targetViewportPlane\n    );\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n      targetViewport.worldToCanvas(world)\n    );\n\n    const dataId = `${annotationUID}-line`;\n    const lineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      lineUID,\n      canvasCoordinates[0],\n      canvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      dataId\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  isPerpendicular = (vec1: Types.Point3, vec2: Types.Point3): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n}\n\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined by\n * a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates of the rectangle\n * defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param worldPos1 - The first world position.\n * @param worldPos2 - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromTwoPoints(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  worldPos1: Types.Point3,\n  worldPos2: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...worldPos1);\n  const pos2 = vec3.fromValues(...worldPos2);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawEllipse as drawEllipseSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  pointInEllipse,\n  getCanvasEllipseCorners,\n} from '../../utilities/math/ellipse';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { EllipticalROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n  MouseDragEventType,\n  MouseMoveEventType,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * EllipticalROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use EllipticalROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Elliptical tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(EllipticalROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(EllipticalROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(EllipticalROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(EllipticalROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\nclass EllipticalROITool extends AnnotationTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    centerCanvas?: Array<number>;\n    canvasWidth?: number;\n    canvasHeight?: number;\n    originalHandleCanvas?: Array<number>;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the ellipse.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a EllipticalROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): EllipticalROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n          ] as [Types.Point3, Types.Point3, Types.Point3, Types.Point3],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        initialRotation: viewport.getRotation(),\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      centerCanvas: canvasPos,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: EllipticalROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n    const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n\n    const [canvasPoint1, canvasPoint2] = canvasCorners;\n\n    const minorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n    };\n\n    const majorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n    };\n\n    const pointInMinorEllipse = this._pointInEllipseCanvas(\n      minorEllipse,\n      canvasCoords\n    );\n    const pointInMajorEllipse = this._pointInEllipseCanvas(\n      majorEllipse,\n      canvasCoords\n    );\n\n    if (pointInMajorEllipse && !pointInMinorEllipse) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    let centerCanvas;\n    let canvasWidth;\n    let canvasHeight;\n    let originalHandleCanvas;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas } = enabledElement.viewport;\n\n      handleIndex = points.findIndex((p) => p === handle);\n\n      const pointsCanvas = points.map(worldToCanvas);\n\n      originalHandleCanvas = pointsCanvas[handleIndex];\n\n      canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n      canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n\n      centerCanvas = [\n        (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n        (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n      ];\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      canvasWidth,\n      canvasHeight,\n      centerCanvas,\n      originalHandleCanvas,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Elliptical ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the ellipse,\n    // and they are by definition not in the ellipse on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n\n    // Todo: why bottom is -dY, it should be +dY\n    const bottomCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] - dY];\n    const topCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] + dY];\n    const leftCanvas = <Types.Point2>[centerCanvas[0] - dX, centerCanvas[1]];\n    const rightCanvas = <Types.Point2>[centerCanvas[0] + dX, centerCanvas[1]];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvasToWorld } = enabledElement.viewport;\n\n    const {\n      annotation,\n      canvasWidth,\n      canvasHeight,\n      handleIndex,\n      centerCanvas,\n      originalHandleCanvas,\n    } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0 || handleIndex === 1) {\n      // Dragging top or bottom point\n      const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - dYCanvas,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n\n      const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n      const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n    } else {\n      // Dragging left or right point\n      const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - dXCanvas,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + dXCanvas,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n\n      const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n      const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - newHalfCanvasHeight,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + newHalfCanvasHeight,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the ellipticalROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as EllipticalROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2, Types.Point2, Types.Point2];\n\n      const rotation = Math.abs(\n        viewport.getRotation() - (data.initialRotation || 0)\n      );\n      let canvasCorners;\n\n      if (rotation == 90 || rotation == 270) {\n        canvasCorners = <Array<Types.Point2>>getCanvasEllipseCorners([\n          canvasCoordinates[2], // bottom\n          canvasCoordinates[3], // top\n          canvasCoordinates[0], // left\n          canvasCoordinates[1], // right\n        ]);\n      } else {\n        canvasCorners = <Array<Types.Point2>>(\n          getCanvasEllipseCorners(canvasCoordinates) // bottom, top, left, right, keep as is\n        );\n      }\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit === undefined\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-ellipse`;\n      const ellipseUID = '0';\n      drawEllipseSvg(\n        svgDrawingHelper,\n        annotationUID,\n        ellipseUID,\n        canvasCorners[0],\n        canvasCorners[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        const minRadius = Math.min(\n          Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, // horizontal radius\n          Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2 // vertical radius\n        );\n        if (minRadius > 3 * centerPointRadius) {\n          const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${ellipseUID}-center`,\n            centerPoint,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const isPreScaled = isViewportPreScaled(viewport, targetId);\n\n      const textLines = this._getTextLines(data, targetId, isPreScaled);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getTextLines = (data, targetId: string, isPreScaled: boolean): string[] => {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, max, isEmptyArea, Modality, areaUnit } =\n      cachedVolumeStats;\n\n    const textLines: string[] = [];\n    const unit = getModalityUnit(Modality, isPreScaled);\n\n    if (area) {\n      const areaLine = isEmptyArea\n        ? `Area: Oblique not supported`\n        : `Area: ${area.toFixed(2)} ${areaUnit}\\xb2`;\n      textLines.push(areaLine);\n    }\n\n    if (mean) {\n      textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n    }\n\n    if (max) {\n      textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n    }\n\n    if (stdDev) {\n      textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n    }\n\n    return textLines;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasEllipseCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2));\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n        let max = -Infinity;\n\n        const meanMaxCalculator = ({ value: newValue }) => {\n          if (newValue > max) {\n            max = newValue;\n          }\n\n          mean += newValue;\n          count += 1;\n        };\n\n        pointInShapeCallback(\n          imageData,\n          (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS),\n          meanMaxCalculator,\n          boundsIJK\n        );\n\n        mean /= count;\n\n        const stdCalculator = ({ value }) => {\n          const valueMinusMean = value - mean;\n\n          stdDev += valueMinusMean * valueMinusMean;\n        };\n\n        pointInShapeCallback(\n          imageData,\n          (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS),\n          stdCalculator,\n          boundsIJK\n        );\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          max,\n          stdDev,\n          isEmptyArea,\n          areaUnit: hasPixelSpacing ? 'mm' : 'px',\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  /**\n   * This is a temporary function to use the old ellipse's canvas-based\n   * calculation for isPointNearTool, we should move the the world-based\n   * calculation to the tool's isPointNearTool function.\n   *\n   * @param ellipse - The ellipse object\n   * @param location - The location to check\n   * @returns True if the point is inside the ellipse\n   */\n  _pointInEllipseCanvas(ellipse, location: Types.Point2): boolean {\n    const xRadius = ellipse.width / 2;\n    const yRadius = ellipse.height / 2;\n\n    if (xRadius <= 0.0 || yRadius <= 0.0) {\n      return false;\n    }\n\n    const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n    const normalized = [location[0] - center[0], location[1] - center[1]];\n\n    const inEllipse =\n      (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n        (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n      1.0;\n\n    return inEllipse;\n  }\n\n  /**\n   * It takes the canvas coordinates of the ellipse corners and returns the center point of it\n   *\n   * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n   * @returns center point.\n   */\n  _getCanvasEllipseCenter(ellipseCanvasPoints: Types.Point2[]): Types.Point2 {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [\n      (topLeft[0] + bottomRight[0]) / 2,\n      (topLeft[1] + bottomRight[1]) / 2,\n    ] as Types.Point2;\n  }\n}\n\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n","import { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleRadius(\n  circleCanvasPoints: canvasCoordinates\n): number {\n  const [center, end] = circleCanvasPoints;\n  return distanceToPoint(center, end);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners (wrapping square rectangle)\n * and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleCorners(\n  circleCanvasPoints: canvasCoordinates\n): Array<Types.Point2> {\n  const [center, end] = circleCanvasPoints;\n  const radius = distanceToPoint(center, end);\n\n  const topLeft = <Types.Point2>[center[0] - radius, center[1] - radius];\n  const bottomRight = <Types.Point2>[center[0] + radius, center[1] + radius];\n\n  return [topLeft, bottomRight];\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n  MouseDragEventType,\n  MouseMoveEventType,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * CircleROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use CircleROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Circle tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(CircleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(CircleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(CircleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(CircleROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\nclass CircleROITool extends AnnotationTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the circle.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CircleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CircleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const radius = getCanvasCircleRadius(canvasCoordinates);\n    const radiusPoint = getCanvasCircleRadius([\n      canvasCoordinates[0],\n      canvasCoords,\n    ]);\n\n    if (Math.abs(radiusPoint - radius) < proximity / 2) return true;\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points = [\n      data.handles.points[0], // center stays\n      canvasToWorld(currentCanvasPoints), // end point moves (changing radius)\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n\n    const { annotation, handleIndex } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0) {\n      // Dragging center, move the circle ROI\n      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n\n      const canvasCenter = currentCanvasPoints as Types.Point2;\n      const canvasEnd = <Types.Point2>[\n        canvasCoordinates[1][0] + dXCanvas,\n        canvasCoordinates[1][1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasCenter);\n      points[1] = canvasToWorld(canvasEnd);\n    } else {\n      // Dragging end point, center stays\n      points[1] = canvasToWorld(currentCanvasPoints);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit === undefined\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n          radius: null,\n          radiusUnit: null,\n          perimeter: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-circle`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const isPreScaled = isViewportPreScaled(viewport, targetId);\n\n      const textLines = this._getTextLines(data, targetId, isPreScaled);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getTextLines = (data, targetId: string, isPreScaled: boolean): string[] => {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const {\n      radius,\n      radiusUnit,\n      area,\n      mean,\n      stdDev,\n      max,\n      isEmptyArea,\n      Modality,\n      areaUnit,\n    } = cachedVolumeStats;\n\n    const textLines: string[] = [];\n    const unit = getModalityUnit(Modality, isPreScaled);\n\n    if (radius) {\n      const radiusLine = isEmptyArea\n        ? `Radius: Oblique not supported`\n        : `Radius: ${radius.toFixed(2)} ${radiusUnit}`;\n      textLines.push(radiusLine);\n    }\n\n    if (area) {\n      const areaLine = isEmptyArea\n        ? `Area: Oblique not supported`\n        : `Area: ${area.toFixed(2)} ${areaUnit}\\xb2`;\n      textLines.push(areaLine);\n    }\n\n    if (mean) {\n      textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n    }\n\n    if (max) {\n      textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n    }\n\n    if (stdDev) {\n      textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n    }\n\n    return textLines;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasCircleCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2));\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n        let max = -Infinity;\n\n        const meanMaxCalculator = ({ value: newValue }) => {\n          if (newValue > max) {\n            max = newValue;\n          }\n\n          mean += newValue;\n          count += 1;\n        };\n\n        pointInShapeCallback(\n          imageData,\n          (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS),\n          meanMaxCalculator,\n          boundsIJK\n        );\n\n        mean /= count;\n\n        const stdCalculator = ({ value }) => {\n          const valueMinusMean = value - mean;\n\n          stdDev += valueMinusMean * valueMinusMean;\n        };\n\n        pointInShapeCallback(\n          imageData,\n          (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS),\n          stdCalculator,\n          boundsIJK\n        );\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          max,\n          stdDev,\n          isEmptyArea,\n          areaUnit: hasPixelSpacing ? 'mm' : 'px',\n          radius: worldWidth / 2,\n          radiusUnit: hasPixelSpacing ? 'mm' : 'px',\n          perimeter: 2 * Math.PI * (worldWidth / 2),\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n","import { vec2, vec3, mat2, mat3, mat2d } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n  MouseDragEventType,\n  MouseMoveEventType,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit === undefined\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const textLines = this._getTextLines(data, targetId);\n\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  /**\n   * get text box content\n   */\n  _getTextLines = (data, targetId) => {\n    const { cachedStats } = data;\n    const { length, width, unit } = cachedStats[targetId];\n\n    if (length === undefined) {\n      return;\n    }\n\n    // spaceBetweenSlices & pixelSpacing &\n    // magnitude in each direction? Otherwise, this is \"px\"?\n    const textLines = [\n      `L: ${length.toFixed(2)} ${unit}`,\n      `W: ${width.toFixed(2)} ${unit}`,\n    ];\n\n    return textLines;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions, hasPixelSpacing } = image;\n\n      const dist1 = this._calculateLength(worldPos1, worldPos2);\n      const dist2 = this._calculateLength(worldPos3, worldPos4);\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: hasPixelSpacing ? 'mm' : 'px',\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawArrow as drawArrowSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { AnnotationCompletedEventDetail } from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ArrowAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass ArrowAnnotateTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        getTextCallback,\n        changeTextCallback,\n        preventHandleOutsideImage: false,\n        arrowFirst: true,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ArrowAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const { arrowFirst } = this.configuration;\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          arrowFirst,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: ArrowAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    if (newAnnotation) {\n      this.configuration.getTextCallback((text) => {\n        if (!text) {\n          removeAnnotation(annotation.annotationUID);\n          triggerAnnotationRenderForViewportIds(\n            renderingEngine,\n            viewportIdsToRender\n          );\n          this.editData = null;\n          this.isDrawing = false;\n          return;\n        }\n        annotation.data.text = text;\n\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n      });\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  touchTapCallback = (evt: EventTypes.TouchTapEventType) => {\n    if (evt.detail.taps == 2) {\n      this.doubleClickCallback(evt);\n    }\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as ArrowAnnotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as ArrowAnnotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const { renderingEngine, viewportId, renderingEngineId } =\n      getEnabledElement(element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    triggerEvent(eventTarget, eventType, {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    });\n  }\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ArrowAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles, text } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      const arrowUID = '1';\n      if (this.configuration.arrowFirst) {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[1],\n          canvasCoordinates[0],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      } else {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!text) {\n        continue;\n      }\n\n      // Need to update to sync w/ annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        [text],\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass AngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2, point3] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const line2 = {\n      start: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n      end: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 2;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      this.angleStartedNotYetCompleted = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (!data.cachedStats[targetId]) {\n        data.cachedStats[targetId] = {\n          angle: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      let lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add textBox until annotation has 3 anchor points (actually 4 because of the center point)\n      if (canvasCoordinates.length !== 3) {\n        return renderStatus;\n      }\n\n      lineUID = '2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[1],\n        canvasCoordinates[2],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const textLines = this._getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  // text line for the current active angle annotation\n  _getTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n\n    if (angle === undefined) {\n      return;\n    }\n\n    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n\n    return textLines;\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all three anchors bail out\n    if (data.handles.points.length !== 3) {\n      return;\n    }\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const angle = angleBetweenLines(\n        [worldPos1, worldPos2],\n        [worldPos2, worldPos3]\n      );\n\n      cachedStats[targetId] = {\n        angle,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n}\n\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Return the midpoint (think average) of all the provided points.\n */\nconst midPoint = (\n  ...args: (Types.Point2 | Types.Point3)[]\n): Types.Point2 | Types.Point3 => {\n  const ret =\n    args[0].length === 2 ? <Types.Point2>[0, 0] : <Types.Point3>[0, 0, 0];\n  const len = args.length;\n  for (const arg of args) {\n    ret[0] += arg[0] / len;\n    ret[1] += arg[1] / len;\n    if (ret.length === 3) ret[2] += arg[2] / len;\n  }\n  return ret;\n};\n\nconst midPoint2 = midPoint as (...args: Types.Point2[]) => Types.Point2;\n\nexport default midPoint;\n\nexport { midPoint2 };\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass CobbAngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): AngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2, point3, point4] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n    const canvasPoint4 = viewport.worldToCanvas(point4);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const line2 = {\n      start: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n      end: {\n        x: canvasPoint4[0],\n        y: canvasPoint4[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.MouseDownEventType,\n    annotation: AngleAnnotation,\n    interactionType: InteractionTypes\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.MouseDownEventType,\n    annotation: AngleAnnotation,\n    handle: ToolHandle,\n    interactionType = 'mouse'\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _mouseUpCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n      resetElementCursor(element);\n\n      // adds the first point of the second line\n      this.editData.handleIndex = data.handles.points.length;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _mouseDragCallback = (\n    evt: EventTypes.MouseDragEventType | EventTypes.MouseMoveEventType\n  ) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      this.angleStartedNotYetCompleted = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (!data.cachedStats[targetId]) {\n        data.cachedStats[targetId] = {\n          angle: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      let lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add textBox until annotation has 4 anchor points\n      if (canvasCoordinates.length < 4) {\n        return renderStatus;\n      }\n\n      lineUID = '2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      lineUID = '3';\n      const mid1 = midPoint2(canvasCoordinates[0], canvasCoordinates[1]);\n      const mid2 = midPoint2(canvasCoordinates[2], canvasCoordinates[3]);\n      drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n        color,\n        lineWidth: '1',\n        lineDash: '1,4',\n      });\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const textLines = this._getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  // text line for the current active angle annotation\n  _getTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n\n    if (angle === undefined) {\n      return;\n    }\n\n    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n\n    return textLines;\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all four anchors bail out\n    if (data.handles.points.length !== 4) {\n      return;\n    }\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const angle = angleBetweenLines(\n        [worldPos1, worldPos2],\n        [worldPos3, worldPos4]\n      );\n\n      cachedStats[targetId] = {\n        angle,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n}\n\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\n\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store';\nimport { Enums } from '@cornerstonejs/core';\n\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { IPoints } from '../types';\n\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\n\nclass MagnifyTool extends BaseTool {\n  static toolName;\n  _bounds: any;\n  editData: {\n    referencedImageId: string;\n    viewportIdsToRender: string[];\n    enabledElement: Types.IEnabledElement;\n    renderingEngine: Types.IRenderingEngine;\n    currentPoints: IPoints;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        magnifySize: 10, // parallel scale , higher more zoom\n        magnifyWidth: 250, //px\n        magnifyHeight: 250, //px\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _getReferencedImageId(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    }\n\n    return referencedImageId;\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error('MagnifyTool only works on StackViewports');\n    }\n\n    const referencedImageId = this._getReferencedImageId(viewport);\n\n    if (!referencedImageId) {\n      throw new Error(\n        'MagnifyTool: No referenced image id found, reconstructed planes not supported yet'\n      );\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      referencedImageId,\n      viewportIdsToRender,\n      enabledElement,\n      renderingEngine,\n      currentPoints,\n    };\n\n    this._createMagnificationViewport();\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType) => {\n    this.preMouseDownCallback(evt);\n  };\n\n  _createMagnificationViewport = () => {\n    const {\n      enabledElement,\n      referencedImageId,\n      viewportIdsToRender,\n      renderingEngine,\n      currentPoints,\n    } = this.editData;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const { voiRange } = viewport.getProperties();\n\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\n\n    let magnifyToolElement: HTMLDivElement;\n\n    magnifyToolElement = element.querySelector('.magnifyTool');\n    if (magnifyToolElement === null) {\n      const magnifyElement = document.createElement('div');\n\n      magnifyElement.classList.add('magnifyTool');\n\n      magnifyElement.style.display = 'block';\n      magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n      magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n      magnifyElement.style.position = 'absolute';\n\n      magnifyToolElement = magnifyElement;\n\n      const viewportElement = element.querySelector('.viewport-element');\n      viewportElement.appendChild(magnifyElement);\n\n      const viewportInput = {\n        viewportId: MAGNIFY_VIEWPORT_ID,\n        type: Enums.ViewportType.STACK,\n        element: magnifyToolElement as HTMLDivElement,\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n\n    // Todo: use CSS transform instead of setting top and left for better performance\n    magnifyToolElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyToolElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const magnifyViewport = renderingEngine.getViewport(\n      MAGNIFY_VIEWPORT_ID\n    ) as Types.IStackViewport;\n\n    magnifyViewport.setStack([referencedImageId]).then(() => {\n      // match the original viewport voi range\n      magnifyViewport.setProperties({ voiRange });\n\n      // Use the original viewport for the base for parallelScale\n      const { parallelScale } = viewport.getCamera();\n\n      const { focalPoint, position, viewPlaneNormal } =\n        magnifyViewport.getCamera();\n\n      const distance = Math.sqrt(\n        Math.pow(focalPoint[0] - position[0], 2) +\n          Math.pow(focalPoint[1] - position[1], 2) +\n          Math.pow(focalPoint[2] - position[2], 2)\n      );\n\n      const updatedFocalPoint = <Types.Point3>[\n        worldPos[0],\n        worldPos[1],\n        worldPos[2],\n      ];\n\n      const updatedPosition = <Types.Point3>[\n        updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n        updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n        updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n      ];\n\n      magnifyViewport.setCamera({\n        parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n        focalPoint: updatedFocalPoint,\n        position: updatedPosition,\n      });\n      magnifyViewport.render();\n    });\n\n    magnifyToolElement.style.display = 'block';\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n\n    const { deltaPoints, element, currentPoints } = eventDetail;\n    const deltaPointsWorld = deltaPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n\n    const magnifyElement = element.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    if (!magnifyElement) {\n      return;\n    }\n\n    magnifyElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const { focalPoint, position } = magnifyViewport.getCamera();\n\n    const updatedPosition = <Types.Point3>[\n      position[0] + deltaPointsWorld[0],\n      position[1] + deltaPointsWorld[1],\n      position[2] + deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] + deltaPointsWorld[0],\n      focalPoint[1] + deltaPointsWorld[1],\n      focalPoint[2] + deltaPointsWorld[2],\n    ];\n\n    magnifyViewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    magnifyViewport.render();\n  };\n\n  _dragEndCallback = (evt: EventTypes.InteractionEventType) => {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n\n    const viewportElement = element.querySelector('.viewport-element');\n\n    const magnifyToolElement = viewportElement.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    viewportElement.removeChild(magnifyToolElement);\n\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n}\n\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  Annotations,\n} from '../types';\nimport { ReferenceCursor } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * ReferenceCursors is a tool that will show your cursors position in all other elements in the toolGroup if they have a matching FrameOfReference relative to its position in world space.\n * Also when positionSync is enabled, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n *\n * Configuration:\n * - positionSync: boolean, if true, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n * - disableCursor: boolean, if true, it will hide the cursor in all viewports. You need to disable and reactivate the tool for this to apply.\n * - displayThreshold: number, if the distance of the cursor in a viewport is bigger than this threshold the cursor will not be displayed.\n *\n * Only uses Active and Disabled state\n */\nclass ReferenceCursors extends AnnotationDisplayTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing = false;\n  isHandleOutsideImage = false;\n  _elementWithCursor: null | HTMLDivElement = null;\n  _currentCursorWorldPosition: null | Types.Point3 = null;\n  _currentCanvasPosition: null | Types.Point2 = null;\n  //need to keep track if this was enabled when tool was enabled because we need to know if we should reset cursors\n  _disableCursorEnabled = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        displayThreshold: 5,\n        positionSync: true,\n        disableCursor: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this._disableCursorEnabled = this.configuration.disableCursor;\n  }\n\n  /**\n   * Overwritten mouseMoveCallback since we want to keep track of the current mouse position and redraw on mouseMove\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const { detail } = evt;\n    const { element, currentPoints } = detail;\n\n    //save current positions and current element the curser is hovering over\n    this._currentCursorWorldPosition = currentPoints.world;\n    this._currentCanvasPosition = currentPoints.canvas;\n    this._elementWithCursor = element;\n\n    const annotation = this.getActiveAnnotation(element);\n    if (annotation === null) {\n      this.createInitialAnnotation(currentPoints.world, element);\n      return false;\n    }\n    this.updateAnnotationPosition(element, annotation);\n    return false;\n  };\n\n  onSetToolActive(): void {\n    this._disableCursorEnabled = this.configuration.disableCursor;\n    if (!this._disableCursorEnabled) return;\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) return;\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    enabledElements.forEach((element) => {\n      if (element) hideElementCursor(element.viewport.element);\n    });\n  }\n  onSetToolDisabled(): void {\n    if (!this._disableCursorEnabled) return;\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) return;\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n    enabledElements.forEach((element) => {\n      if (element) resetElementCursor(element.viewport.element);\n    });\n  }\n\n  createInitialAnnotation = (\n    worldPos: Types.Point3,\n    element: HTMLDivElement\n  ): void => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) throw new Error('No enabled element found');\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    if (!viewPlaneNormal || !viewUp) throw new Error('Camera not found');\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [[...worldPos]] as [Types.Point3],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n      },\n    };\n\n    const annotations = getAnnotations(this.getToolName(), element);\n\n    if (annotations.length > 0) return null;\n    const annotationId = addAnnotation(annotation, element);\n\n    if (annotationId === null) return;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  getActiveAnnotation(element: HTMLDivElement): null | Annotation {\n    const annotations = getAnnotations(this.getToolName(), element);\n    if (!annotations.length) {\n      return null;\n    }\n    const targetAnnotation = annotations[0];\n    return targetAnnotation;\n  }\n\n  /**\n   * updates the position of the annotation to match the currently set world position\n   */\n  updateAnnotationPosition(\n    element: HTMLDivElement,\n    annotation: Annotation\n  ): void {\n    const worldPos = this._currentCursorWorldPosition;\n    if (!worldPos) return;\n    if (!annotation.data?.handles?.points) return;\n    annotation.data.handles.points = [[...worldPos]];\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) return;\n    const { renderingEngine } = enabledElement;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  //checks if we need to update the annotation position due to camera changes\n  onCameraModified = (evt: any): void => {\n    const eventDetail = evt.detail;\n    const { element, previousCamera, camera } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const viewport = enabledElement.viewport as\n      | Types.IVolumeViewport\n      | Types.IStackViewport;\n\n    //only react to changes for element with cursor, otherwise would cause infinite loop\n    if (element !== this._elementWithCursor) return;\n    //check if camera moved along its normal\n    const oldFocalPoint = previousCamera.focalPoint;\n    const cameraNormal = camera.viewPlaneNormal;\n    const newFocalPoint = camera.focalPoint;\n\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n    //check if focal point changed\n    if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) return;\n    //if nomrmal is perpendicular to focal point change, then we are not moving along the normal\n    const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n    //dot product is 0 -> perpendicular\n    if (Math.abs(dotProduct) < 1e-2) return;\n\n    //need to update the position of the annotation since camera changed\n    if (!this._currentCanvasPosition) return;\n\n    const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n    this._currentCursorWorldPosition = newWorldPos;\n    this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n  };\n\n  //display annotation if current viewing plane has a max distance of \"displayThreshold\" from the annotation\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations {\n    //calculate distance of current viewport to annotation\n    if (!(annotations instanceof Array) || annotations.length === 0) return [];\n    const annotation = annotations[0];\n    const viewport = getEnabledElement(element)?.viewport;\n    if (!viewport) return [];\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, focalPoint } = camera;\n    if (!viewPlaneNormal || !focalPoint) return [];\n    const points = annotation.data?.handles?.points;\n    if (!(points instanceof Array) || points.length !== 1) return [];\n    const worldPos = points[0];\n    const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n    const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n    return distance < this.configuration.displayThreshold ? [annotation] : [];\n  }\n\n  /**\n   * Draws the cursor representation on the enabledElement\n   * Checks if a stack change has happened and updates annotation in that case\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    const isElementWithCursor = this._elementWithCursor === viewport.element;\n\n    //update stack position if position sync is enabled\n    if (this.configuration.positionSync && !isElementWithCursor) {\n      this.updateViewportImage(viewport);\n    }\n\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    //the viewport change from updateStackPosition might not be applied yet, so sometimes the annotation might not be immediately visible\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as Annotations;\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ReferenceCursor;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points } = handles;\n\n      if (!annotationUID) return renderStatus;\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidthBase = parseFloat(\n        this.getStyle('lineWidth', styleSpecifier, annotation) as string\n      );\n\n      const lineWidth =\n        typeof lineWidthBase === 'number' && isElementWithCursor\n          ? lineWidthBase\n          : lineWidthBase;\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (points[0].some((e) => isNaN(e))) return renderStatus;\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2];\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      const crosshairUIDs = {\n        upper: 'upper',\n        right: 'right',\n        lower: 'lower',\n        left: 'left',\n      };\n      const [x, y] = canvasCoordinates[0];\n      const centerSpace = isElementWithCursor ? 20 : 7;\n      const lineLength = isElementWithCursor ? 5 : 7;\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.upper,\n        [x, y - (centerSpace / 2 + lineLength)],\n        [x, y - centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.lower,\n        [x, y + (centerSpace / 2 + lineLength)],\n        [x, y + centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.right,\n        [x + (centerSpace / 2 + lineLength), y],\n        [x + centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.left,\n        [x - (centerSpace / 2 + lineLength), y],\n        [x - centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  updateViewportImage(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const currentMousePosition = this._currentCursorWorldPosition;\n\n    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e)))\n      return;\n\n    if (viewport instanceof StackViewport) {\n      const closestIndex = utilities.getClosestStackImageIndexForPoint(\n        currentMousePosition,\n        viewport\n      );\n\n      if (closestIndex === null) return;\n      if (closestIndex !== viewport.getCurrentImageIdIndex())\n        viewport.setImageIdIndex(closestIndex);\n    } else if (viewport instanceof VolumeViewport) {\n      const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n      if (!focalPoint || !viewPlaneNormal) return;\n      const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n      const currentDistance = utilities.planar.planeDistanceToPoint(\n        plane,\n        currentMousePosition,\n        true\n      );\n\n      if (Math.abs(currentDistance) < 0.5) return;\n      const normalizedViewPlane = vec3.normalize(\n        vec3.create(),\n        vec3.fromValues(...viewPlaneNormal)\n      );\n      const scaledPlaneNormal = vec3.scale(\n        vec3.create(),\n        normalizedViewPlane,\n        currentDistance\n      );\n      const newFocalPoint = vec3.add(\n        vec3.create(),\n        vec3.fromValues(...focalPoint),\n        scaledPlaneNormal\n      ) as Types.Point3;\n      //TODO: make check if new focal point is within bounds of volume\n      const isInBounds = true;\n      if (isInBounds) {\n        viewport.setCamera({ focalPoint: newFocalPoint });\n        const renderingEngine = viewport.getRenderingEngine();\n        if (renderingEngine) renderingEngine.renderViewport(viewport.id);\n      }\n    }\n  }\n}\n\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElementByIds,\n  getRenderingEngines,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { ScaleOverlayAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport {\n  drawLine as drawLineSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../drawingSvg';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\nconst viewportsWithAnnotations = [];\n\n/**\n * @public\n * @class ScaleOverlayTool\n * @memberof Tools\n *\n * @classdesc Tool for displaying a scale overlay on the image.\n * @extends Tools.Base.BaseTool\n */\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    viewport: any;\n    annotation: ScaleOverlayAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        viewportId: '',\n        scaleLocation: 'bottom',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    // get viewports with tool enabled\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportIds) return;\n\n    // get enabled elements\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    let { viewport } = enabledElements[0];\n    const { FrameOfReferenceUID } = enabledElements[0];\n\n    // onCameraModified, configuration.viewportId is set to the active\n    // viewport Id, here we are setting the viewport variable to the\n    // viewport with the matching Id\n    if (this.configuration.viewportId) {\n      enabledElements.forEach((element) => {\n        if (element.viewport.id == this.configuration.viewportId) {\n          viewport = element.viewport;\n        }\n      });\n    }\n\n    if (!viewport) {\n      return;\n    }\n\n    const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n    const viewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(viewport);\n\n    let annotation = this.editData.annotation;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    // if annotations have been created, get the annotation for the\n    // current viewport Id\n    if (annotations.length) {\n      annotation = annotations.filter(\n        (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n      )[0] as ScaleOverlayAnnotation;\n    }\n\n    // viewportsWithAnnotations stores which viewports have an annotation,\n    // if the viewport does not have an annotation, create a new one\n    if (!viewportsWithAnnotations.includes(viewport.id)) {\n      const newAnnotation: ScaleOverlayAnnotation = {\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: viewportCanvasCornersInWorld,\n          },\n          viewportId: viewport.id,\n        },\n      };\n\n      viewportsWithAnnotations.push(viewport.id);\n\n      addAnnotation(newAnnotation, viewport.element);\n      annotation = newAnnotation;\n    } else if (this.editData.annotation.data.viewportId == viewport.id) {\n      this.editData.annotation.data.handles.points =\n        viewportCanvasCornersInWorld;\n      this.editData.annotation.data.viewportId = viewport.id;\n    }\n\n    this.editData = {\n      viewport,\n      renderingEngine,\n      annotation,\n    };\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the viewport\n    // that the camera was modified on\n    this.configuration.viewportId = evt.detail.viewportId;\n    this._init();\n  };\n\n  /**\n   * Used to draw the scale annotation in each request animation\n   * frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   * @returns\n   */\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ) {\n    if (!this.editData.viewport) {\n      return;\n    }\n    const location = this.configuration.scaleLocation;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n    const annotation = annotations.filter(\n      (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n    )[0];\n    const canvas = enabledElement.viewport.canvas;\n\n    const renderStatus = false;\n\n    if (!viewport) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const canvasSize = {\n      width: canvas.width,\n      height: canvas.height,\n    };\n\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n\n    const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n    const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n\n    // hscaleBounds and vscaleBounds compute the max bound for scales on the image\n    const hscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    const vscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    // Computes which scale size to use, ex: 100mm, 50mm\n    const scaleSize = this.computeScaleSize(\n      worldWidthViewport,\n      worldHeightViewport,\n      location\n    );\n\n    // Applies the scale with the predetermined size to the image in\n    // world coordinates, then converts them to canvas coordinates\n    const canvasCoordinates = this.computeWorldScaleCoordinates(\n      scaleSize,\n      location,\n      pointSet1\n    ).map((world) => viewport.worldToCanvas(world));\n\n    // Uses the bounds and canvas size to center the scale\n    // based on the location\n    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(\n      canvasSize,\n      canvasCoordinates,\n      vscaleBounds,\n      hscaleBounds,\n      location\n    );\n\n    // Computes the end scale ticks coordinates\n    const scaleTicks = this.computeEndScaleTicks(\n      scaleCanvasCoordinates,\n      location\n    );\n\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    const scaleId = `${annotationUID}-scaleline`;\n    const scaleLineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      scaleLineUID,\n      scaleCanvasCoordinates[0],\n      scaleCanvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      scaleId\n    );\n    const leftTickId = `${annotationUID}-left`;\n    const leftTickUID = '2';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      leftTickUID,\n      scaleTicks.endTick1[0] as Types.Point2,\n      scaleTicks.endTick1[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      leftTickId\n    );\n    const rightTickId = `${annotationUID}-right`;\n    const rightTickUID = '3';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rightTickUID,\n      scaleTicks.endTick2[0] as Types.Point2,\n      scaleTicks.endTick2[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      rightTickId\n    );\n\n    const locationTextOffest = {\n      bottom: [-10, -42],\n      top: [-12, -35],\n      left: [-40, -20],\n      right: [-50, -20],\n    };\n\n    const textCanvasCoordinates = [\n      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n    ];\n    const textBoxLines = this._getTextLines(scaleSize);\n\n    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(\n      scaleSize,\n      location,\n      annotationUID,\n      scaleTicks.endTick1,\n      scaleTicks.endTick2\n    );\n\n    // draws inner ticks for scale\n    for (let i = 0; i < tickUIDs.length; i++) {\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        tickUIDs[i],\n        tickCoordinates[i][0],\n        tickCoordinates[i][1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        tickIds[i]\n      );\n    }\n\n    const textUID = 'text0';\n    drawTextBoxSvg(\n      svgDrawingHelper,\n      annotationUID,\n      textUID,\n      textBoxLines,\n      [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n      {\n        fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        lineDash: '2,3',\n        lineWidth: '1',\n        shadow: true,\n        color: color,\n      }\n    );\n\n    return renderStatus;\n  }\n\n  _getTextLines(scaleSize: number): string[] | undefined {\n    let scaleSizeDisplayValue;\n    let scaleSizeUnits;\n    if (scaleSize >= 50) {\n      scaleSizeDisplayValue = scaleSize / 10; //convert to cm\n      scaleSizeUnits = ' cm';\n    } else {\n      scaleSizeDisplayValue = scaleSize; //convert to cm\n      scaleSizeUnits = ' mm';\n    }\n\n    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n\n    return textLines;\n  }\n\n  /**\n   *\n   * @param worldWidthViewport\n   * @returns currentScaleSize\n   */\n  computeScaleSize = (\n    worldWidthViewport: number,\n    worldHeightViewport: number,\n    location: any\n  ) => {\n    const scaleSizes = [\n      16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n    ];\n    let currentScaleSize;\n    if (location == 'top' || location == 'bottom') {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldWidthViewport * 0.6 &&\n          scaleSize > worldWidthViewport * 0.2\n      );\n    } else {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldHeightViewport * 0.6 &&\n          scaleSize > worldHeightViewport * 0.2\n      );\n    }\n\n    return currentScaleSize[0];\n  };\n\n  /**\n   *  calculates scale ticks for ends of the scale\n   * @param canvasCoordinates\n   * @returns leftTick, rightTick\n   */\n  computeEndScaleTicks = (canvasCoordinates, location) => {\n    const locationTickOffset = {\n      bottom: [\n        [0, -10],\n        [0, -10],\n      ],\n      top: [\n        [0, 10],\n        [0, 10],\n      ],\n      left: [\n        [0, 0],\n        [10, 0],\n      ],\n      right: [\n        [0, 0],\n        [-10, 0],\n      ],\n    };\n\n    const endTick1 = [\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n    const endTick2 = [\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n\n    return {\n      endTick1: endTick1,\n      endTick2: endTick2,\n    };\n  };\n\n  computeInnerScaleTicks = (\n    scaleSize: number,\n    location: string,\n    annotationUID: string,\n    leftTick: any[][],\n    rightTick: any[][]\n  ) => {\n    let canvasScaleSize;\n    if (location == 'bottom' || location == 'top') {\n      canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n    } else if (location == 'left' || location == 'right') {\n      canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n    }\n    const tickIds = [];\n    const tickUIDs = [];\n    const tickCoordinates = [];\n    let numberSmallTicks = scaleSize;\n\n    if (scaleSize >= 50) {\n      numberSmallTicks = scaleSize / 10;\n    }\n\n    const tickSpacing = canvasScaleSize / numberSmallTicks;\n\n    for (let i = 0; i < numberSmallTicks - 1; i++) {\n      const locationOffset = {\n        bottom: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), 5],\n        ],\n        top: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), -5],\n        ],\n        left: [\n          [0, tickSpacing * (i + 1)],\n          [-5, tickSpacing * (i + 1)],\n        ],\n        right: [\n          [0, tickSpacing * (i + 1)],\n          [5, tickSpacing * (i + 1)],\n        ],\n      };\n      tickIds.push(`${annotationUID}-tick${i}`);\n      tickUIDs.push(`tick${i}`);\n      if ((i + 1) % 5 == 0) {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][0][0],\n            leftTick[1][1] + locationOffset[location][0][1],\n          ],\n        ]);\n      } else {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][1][0],\n            leftTick[1][1] + locationOffset[location][1][1],\n          ],\n        ]);\n      }\n    }\n\n    return { tickIds, tickUIDs, tickCoordinates };\n  };\n\n  computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n    let worldCoordinates;\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const midpointLocation = {\n      bottom: [pointSet[1], pointSet[2]],\n      top: [pointSet[0], pointSet[3]],\n      right: [pointSet[2], pointSet[3]],\n      left: [pointSet[0], pointSet[1]],\n    };\n\n    const midpoint = vec3\n      .add(\n        vec3.create(),\n        midpointLocation[location][0],\n        midpointLocation[location][0]\n      )\n      .map((i) => i / 2) as Types.Point3;\n\n    const offset =\n      scaleSize /\n      2 /\n      Math.sqrt(\n        Math.pow(topBottomVec[0], 2) +\n          Math.pow(topBottomVec[1], 2) +\n          Math.pow(topBottomVec[2], 2)\n      );\n\n    if (location == 'top' || location == 'bottom') {\n      worldCoordinates = [\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    } else if (location == 'left' || location == 'right') {\n      worldCoordinates = [\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    }\n\n    return worldCoordinates;\n  };\n\n  /**\n   * Computes the centered canvas coordinates for scale\n   * @param canvasSize\n   * @param canvasCoordinates\n   * @param vscaleBounds\n   * @returns scaleCanvasCoordinates\n   */\n  computeCanvasScaleCoordinates = (\n    canvasSize,\n    canvasCoordinates,\n    vscaleBounds,\n    hscaleBounds,\n    location\n  ) => {\n    let scaleCanvasCoordinates;\n    if (location == 'top' || location == 'bottom') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][0] - canvasCoordinates[1][0];\n      scaleCanvasCoordinates = [\n        [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n        [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n      ];\n    } else if (location == 'left' || location == 'right') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][1] - canvasCoordinates[1][1];\n      scaleCanvasCoordinates = [\n        [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n        [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n      ];\n    }\n\n    return scaleCanvasCoordinates;\n  };\n\n  /**\n   * Computes the max bound for scales on the image\n   * @param  {{width: number, height: number}} canvasSize\n   * @param  {number} horizontalReduction\n   * @param  {number} verticalReduction\n   * @returns {Object.<string, { x:number, y:number }>}\n   */\n  computeScaleBounds = (\n    canvasSize,\n    horizontalReduction,\n    verticalReduction,\n    location\n  ) => {\n    const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n    const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n    const locationBounds = {\n      bottom: [-vReduction, -hReduction],\n      top: [vReduction, hReduction],\n      left: [vReduction, hReduction],\n      right: [-vReduction, -hReduction],\n    };\n    const canvasBounds = {\n      bottom: [canvasSize.height, canvasSize.width],\n      top: [0, canvasSize.width],\n      left: [canvasSize.height, 0],\n      right: [canvasSize.height, canvasSize.width],\n    };\n\n    return {\n      height: canvasBounds[location][0] + locationBounds[location][0],\n      width: canvasBounds[location][1] + locationBounds[location][1],\n    };\n  };\n}\n\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { ImageVolume, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { pointInShapeCallback } from '../../../utilities';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype OperationData = {\n  segmentationId: string;\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n  volume: ImageVolume;\n  constraintFn: (x: [number, number, number]) => boolean;\n  segmentIndex: number;\n  segmentsLocked: number[];\n};\n\n/**\n * For each point in the bounding box around the rectangle, if the point is inside\n * the rectangle, set the scalar value to the segmentIndex\n * @param toolGroupId - string\n * @param operationData - OperationData\n * @param constraintFn - can be used to perform threshold segmentation\n * @param inside - boolean\n */\n// Todo: why we have another constraintFn? in addition to the one in the operationData?\nfunction fillRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  inside = true\n): void {\n  const {\n    volume: segmentation,\n    points,\n    segmentsLocked,\n    segmentIndex,\n    segmentationId,\n    constraintFn,\n  } = operationData;\n  const { imageData, dimensions } = segmentation;\n  const scalarData = segmentation.getScalarData();\n\n  let rectangleCornersIJK = points.map((world) => {\n    return transformWorldToIndex(imageData, world);\n  });\n\n  // math round\n  rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n    return point.map((coord) => {\n      return Math.round(coord);\n    });\n  });\n\n  const boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n\n  if (boundsIJK.every(([min, max]) => min !== max)) {\n    throw new Error('Oblique segmentation tools are not supported yet');\n  }\n\n  // Since always all points inside the boundsIJK is inside the rectangle...\n  const pointInRectangle = () => true;\n\n  const callback = ({ value, index, pointIJK }) => {\n    if (segmentsLocked.includes(value)) {\n      return;\n    }\n\n    if (!constraintFn) {\n      scalarData[index] = segmentIndex;\n      return;\n    }\n\n    if (constraintFn(pointIJK)) {\n      scalarData[index] = segmentIndex;\n    }\n  };\n\n  pointInShapeCallback(imageData, pointInRectangle, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationId);\n}\n\n/**\n * Fill the inside of a rectangle\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n * @param constraintFn - can be used to perform threshold segmentation\n */\nexport function fillInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Fill the area outside of a rectangle for the toolGroupId and segmentationRepresentationUID.\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n * @param constraintFn - can be used to perform threshold segmentation\n */\nexport function fillOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, false);\n}\n","import { ImageVolume, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInShapeCallback } from '../../../utilities';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype EraseOperationData = {\n  segmentationId: string;\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n  volume: ImageVolume;\n  constraintFn: (x: [number, number, number]) => boolean;\n  segmentsLocked: number[];\n};\n\nfunction eraseRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: EraseOperationData,\n  inside = true\n): void {\n  const {\n    volume: segmentation,\n    points,\n    segmentsLocked,\n    segmentationId,\n  } = operationData;\n  const { imageData, dimensions } = segmentation;\n  const scalarData = segmentation.getScalarData();\n\n  const rectangleCornersIJK = points.map((world) => {\n    return transformWorldToIndex(imageData, world);\n  });\n\n  const boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n\n  if (boundsIJK.every(([min, max]) => min !== max)) {\n    throw new Error('Oblique segmentation tools are not supported yet');\n  }\n\n  // Since always all points inside the boundsIJK is inside the rectangle...\n  const pointInShape = () => true;\n\n  const callback = ({ value, index }) => {\n    if (segmentsLocked.includes(value)) {\n      return;\n    }\n    scalarData[index] = 0;\n  };\n\n  pointInShapeCallback(imageData, pointInShape, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationId);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels inside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function eraseInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: EraseOperationData\n): void {\n  eraseRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels outside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function eraseOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: EraseOperationData\n): void {\n  eraseRectangle(enabledElement, operationData, false);\n}\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\n\nimport { Events } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\n/**\n * Tool for manipulating segmentation data by drawing a rectangle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass RectangleScissorsTool extends BaseTool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    segmentationId: string;\n    segmentation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideRectangle,\n          ERASE_INSIDE: eraseInsideRectangle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      segmentation,\n      segmentIndex,\n      segmentsLocked,\n      segmentColor,\n      segmentationId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle.\n    const { currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n    const worldPos = currentPoints.world;\n\n    const { points } = data.handles;\n\n    // Move this handle.\n    points[handleIndex] = [...worldPos];\n\n    let bottomLeftCanvas;\n    let bottomRightCanvas;\n    let topLeftCanvas;\n    let topRightCanvas;\n\n    let bottomLeftWorld;\n    let bottomRightWorld;\n    let topLeftWorld;\n    let topRightWorld;\n\n    switch (handleIndex) {\n      case 0:\n      case 3:\n        // Moving bottomLeft or topRight\n\n        bottomLeftCanvas = worldToCanvas(points[0]);\n        topRightCanvas = worldToCanvas(points[3]);\n\n        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n        topLeftWorld = canvasToWorld(topLeftCanvas);\n\n        points[1] = bottomRightWorld;\n        points[2] = topLeftWorld;\n\n        break;\n      case 1:\n      case 2:\n        // Moving bottomRight or topLeft\n        bottomRightCanvas = worldToCanvas(points[1]);\n        topLeftCanvas = worldToCanvas(points[2]);\n\n        bottomLeftCanvas = <Types.Point2>[\n          topLeftCanvas[0],\n          bottomRightCanvas[1],\n        ];\n        topRightCanvas = <Types.Point2>[bottomRightCanvas[0], topLeftCanvas[1]];\n\n        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n        topRightWorld = canvasToWorld(topRightCanvas);\n\n        points[0] = bottomLeftWorld;\n        points[3] = topRightWorld;\n\n        break;\n    }\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentation,\n      segmentationId,\n      segmentIndex,\n      segmentsLocked,\n    } = this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation,\n      segmentationId,\n      segmentIndex,\n      segmentsLocked,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const rectangleUID = '0';\n    drawRectSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rectangleUID,\n      canvasCoordinates[0],\n      canvasCoordinates[3],\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n  config as segmentationConfig,\n} from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\n/**\n * Tool for manipulating segmentation data by drawing a circle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass CircleScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentation: any;\n    segmentIndex: number;\n    segmentationId: string;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideCircle,\n          // ERASE_INSIDE: eraseInsideCircle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        isDrawing: true,\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      segmentation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    // Center of circle in canvas Coordinates\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentation,\n      segmentIndex,\n      segmentsLocked,\n      segmentationId,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation,\n      segmentIndex,\n      segmentsLocked,\n      viewPlaneNormal,\n      segmentationId,\n      viewUp,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\n/**\n * Tool for manipulating segmentation data by drawing a sphere in 3d space. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex. Todo: sphere scissor has some memory problem which\n * lead to ui blocking behavior that needs to be fixed.\n */\nclass SphereScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentationId: string;\n    toolGroupId: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideSphere,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): true => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n\n    this.isDrawing = true;\n\n    // Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        highlighted: true,\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      segmentation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentsLocked,\n      segmentColor,\n      segmentationId,\n      toolGroupId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentation,\n      segmentIndex,\n      segmentsLocked,\n      segmentationId,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation,\n      segmentIndex,\n      segmentsLocked,\n      segmentationId,\n      viewPlaneNormal,\n      viewUp,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the sphereScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import {\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport { PublicToolProps, ToolProps, EventTypes } from '../../types';\n\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n} from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { FloodFillResult, FloodFillGetter } from '../../types';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\ntype PaintFillToolHelpers = {\n  getScalarDataPositionFromPlane: (x: number, y: number) => number;\n  getLabelValue: (x: number, y: number, z: number) => number;\n  floodFillGetter: FloodFillGetter;\n  inPlaneSeedPoint: Types.Point2;\n  fixedDimensionValue: number;\n};\n\n/**\n * Tool for manipulating segmentation data by filling in regions. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will fill a given labelled\n * or empty region with the the activeSegmentIndex label. You can use the\n * SegmentationModule to set the active segmentation and segmentIndex.\n */\nclass PaintFillTool extends BaseTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked: number[] =\n      segmentLocking.getLockedSegments(segmentationId);\n    const { representationData } = getSegmentation(segmentationId);\n\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n    const { dimensions, direction } = segmentation;\n    const scalarData = segmentation.getScalarData();\n\n    const index = transformWorldToIndex(segmentation.imageData, worldPos);\n\n    const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);\n\n    if (fixedDimension === undefined) {\n      console.warn('Oblique paint fill not yet supported');\n      return;\n    }\n\n    const {\n      floodFillGetter,\n      getLabelValue,\n      getScalarDataPositionFromPlane,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\n\n    // Check if within volume\n    if (\n      index[0] < 0 ||\n      index[0] >= dimensions[0] ||\n      index[1] < 0 ||\n      index[1] >= dimensions[1] ||\n      index[2] < 0 ||\n      index[2] >= dimensions[2]\n    ) {\n      // Clicked outside segmentation volume, no good way to fill.\n      return;\n    }\n    //@ts-ignore // todo type\n    const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n\n    if (segmentsLocked.includes(clickedLabelValue)) {\n      // Label is locked, cannot fill.\n      return;\n    }\n\n    const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n\n    const { flooded } = floodFillResult;\n\n    flooded.forEach((index) => {\n      const scalarDataPosition = getScalarDataPositionFromPlane(\n        index[0],\n        index[1]\n      );\n\n      scalarData[scalarDataPosition] = segmentIndex;\n    });\n\n    const framesModified = this.getFramesModified(\n      fixedDimension,\n      fixedDimensionValue,\n      floodFillResult\n    );\n\n    triggerSegmentationDataModified(segmentationId, framesModified);\n\n    return true;\n  };\n\n  private getFramesModified = (\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    floodFillResult: FloodFillResult\n  ): number[] => {\n    const { boundaries } = floodFillResult;\n\n    if (fixedDimension === 2) {\n      return [fixedDimensionValue];\n    }\n\n    // For both the fixedDimensions being 0 and 1, the Z (stack) direction is j,\n    // so we don't need to find min/max i.\n\n    let minJ = Infinity;\n    let maxJ = -Infinity;\n\n    for (let b = 0; b < boundaries.length; b++) {\n      const j = boundaries[b][1];\n\n      if (j < minJ) minJ = j;\n      if (j > maxJ) maxJ = j;\n    }\n\n    const framesModified = [];\n\n    for (let frame = minJ; frame <= maxJ; frame++) {\n      framesModified.push(frame);\n    }\n\n    return framesModified;\n  };\n\n  private generateHelpers = (\n    scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array,\n    dimensions: Types.Point3,\n    seedIndex3D: Types.Point3,\n    fixedDimension = 2\n  ): PaintFillToolHelpers => {\n    let fixedDimensionValue: number;\n    let inPlaneSeedPoint: Types.Point2;\n\n    switch (fixedDimension) {\n      case 0:\n        fixedDimensionValue = seedIndex3D[0]; // X\n        inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]]; // Y,Z\n        break;\n      case 1:\n        fixedDimensionValue = seedIndex3D[1]; // Y\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]]; // X,Z\n        break;\n      case 2:\n        fixedDimensionValue = seedIndex3D[2]; // Z\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]]; // X, Y\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    const getScalarDataPosition = (x: number, y: number, z: number): number => {\n      return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\n    };\n\n    const getLabelValue = (x: number, y: number, z: number): number => {\n      return scalarData[getScalarDataPosition(x, y, z)];\n    };\n\n    const floodFillGetter = this.generateFloodFillGetter(\n      dimensions,\n      fixedDimension,\n      fixedDimensionValue,\n      getLabelValue\n    );\n\n    const getScalarDataPositionFromPlane =\n      this.generateGetScalarDataPositionFromPlane(\n        getScalarDataPosition,\n        fixedDimension,\n        fixedDimensionValue\n      );\n\n    return {\n      getScalarDataPositionFromPlane,\n      getLabelValue,\n      floodFillGetter,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    };\n  };\n\n  private getFixedDimension(\n    viewPlaneNormal: Types.Point3,\n    direction: number[]\n  ): number | undefined {\n    const xDirection = direction.slice(0, 3);\n    const yDirection = direction.slice(3, 6);\n    const zDirection = direction.slice(6, 9);\n\n    const absoluteOfViewPlaneNormal = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n\n    const absoluteOfXDirection = [\n      Math.abs(xDirection[0]),\n      Math.abs(xDirection[1]),\n      Math.abs(xDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n      return 0;\n    }\n\n    const absoluteOfYDirection = [\n      Math.abs(yDirection[0]),\n      Math.abs(yDirection[1]),\n      Math.abs(yDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n      return 1;\n    }\n\n    const absoluteOfZDirection = [\n      Math.abs(zDirection[0]),\n      Math.abs(zDirection[1]),\n      Math.abs(zDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n      return 2;\n    }\n  }\n\n  // Define a getter for the fill routine to access the working label map.\n  private generateFloodFillGetter = (\n    dimensions: Types.Point3,\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    getLabelValue: PaintFillToolHelpers['getLabelValue']\n  ): FloodFillGetter => {\n    let floodFillGetter;\n\n    // In each helper we first check if out of bounds, as the flood filler\n    // doesn't know about the dimensions of the data structure that sits on top\n    // of the scalarData. E.g. if cols is 10, (0,1) and (10, 0) would point to\n    // the same position in these getters.\n\n    switch (fixedDimension) {\n      case 0:\n        floodFillGetter = (y, z) => {\n          if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(fixedDimensionValue, y, z);\n        };\n        break;\n\n      case 1:\n        floodFillGetter = (x, z) => {\n          if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(x, fixedDimensionValue, z);\n        };\n        break;\n\n      case 2:\n        floodFillGetter = (x, y) => {\n          if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n            return;\n          }\n\n          return getLabelValue(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return floodFillGetter;\n  };\n\n  private generateGetScalarDataPositionFromPlane = (\n    getScalarDataPosition: (x: number, y: number, z: number) => number,\n    fixedDimension: number,\n    fixedDimensionValue: number\n  ): PaintFillToolHelpers['getScalarDataPositionFromPlane'] => {\n    let getScalarDataPositionFromPlane;\n\n    switch (fixedDimension) {\n      case 0:\n        getScalarDataPositionFromPlane = (y, z) => {\n          return getScalarDataPosition(fixedDimensionValue, y, z);\n        };\n        break;\n      case 1:\n        getScalarDataPositionFromPlane = (x, z) => {\n          return getScalarDataPosition(x, fixedDimensionValue, z);\n        };\n        break;\n      case 2:\n        getScalarDataPositionFromPlane = (x, y) => {\n          return getScalarDataPosition(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return getScalarDataPositionFromPlane;\n  };\n}\n\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__953__","__WEBPACK_EXTERNAL_MODULE__441__","__WEBPACK_EXTERNAL_MODULE__795__","__WEBPACK_EXTERNAL_MODULE__785__","__WEBPACK_EXTERNAL_MODULE__127__","__WEBPACK_EXTERNAL_MODULE__396__","__WEBPACK_EXTERNAL_MODULE__348__","__WEBPACK_EXTERNAL_MODULE__70__","__WEBPACK_EXTERNAL_MODULE__474__","__WEBPACK_EXTERNAL_MODULE__610__","__WEBPACK_EXTERNAL_MODULE__976__","__WEBPACK_EXTERNAL_MODULE__807__","__WEBPACK_EXTERNAL_MODULE__847__","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","boolTag","dateTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","g","Object","freeSelf","Function","freeExports","nodeType","freeModule","moduleExports","addMapEntry","map","pair","set","addSetEntry","value","add","arrayReduce","array","iteratee","accumulator","initAccum","index","length","isHostObject","result","toString","e","mapToArray","Array","size","forEach","key","overArg","func","transform","arg","setToArray","uid","arrayProto","prototype","funcProto","objectProto","coreJsData","maskSrcKey","exec","keys","IE_PROTO","funcToString","hasOwnProperty","objectToString","reIsNative","RegExp","call","replace","Buffer","undefined","Symbol","Uint8Array","getPrototype","getPrototypeOf","objectCreate","create","propertyIsEnumerable","splice","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeKeys","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","Hash","entries","this","clear","entry","ListCache","MapCache","Stack","__data__","assignValue","object","objValue","eq","assocIndexOf","baseClone","isDeep","isFull","customizer","stack","isObject","isArr","isArray","constructor","input","initCloneArray","source","copyArray","tag","getTag","isFunc","buffer","slice","copy","cloneBuffer","isPrototype","proto","initCloneObject","copyObject","getSymbols","copySymbols","baseAssign","cloneFunc","symbol","Ctor","cloneArrayBuffer","dataView","byteOffset","byteLength","cloneDataView","typedArray","cloneTypedArray","cloneMap","regexp","lastIndex","cloneRegExp","cloneSet","initCloneByTag","stacked","get","props","keysFunc","symbolsFunc","values","offset","arrayPush","baseGetAllKeys","getAllKeys","arrayEach","subValue","arrayBuffer","newValue","getMapData","type","data","getValue","isFunction","test","baseIsNative","has","pop","push","cache","pairs","LARGE_ARRAY_SIZE","isIndex","other","ArrayBuffer","resolve","ctorString","isArrayLike","isLength","inherited","isObjectLike","isArrayLikeObject","isArguments","n","baseTimes","String","skipIndexes","arrayLikeKeys","baseKeys","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","symbolToString","pattern","stringToPath","memoize","string","isSymbol","baseToString","match","number","quote","toKey","resolver","TypeError","memoized","args","arguments","apply","Cache","path","defaultValue","isKey","baseGet","runtime","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","obj","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","GenStateSuspendedStart","method","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","done","GenStateSuspendedYield","makeInvokeMethod","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","reject","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","info","resultName","next","nextLoc","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","i","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","reverse","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","globalThis","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","getter","__esModule","d","a","definition","o","window","prop","r","nmd","paths","children","Events","_defineProperties","target","descriptor","_createClass","Constructor","protoProps","staticProps","_classCallCheck","instance","_defineProperty","globalLockedAnnotationsSet","setAnnotationLocked","annotation","locked","detail","makeEventDetail","lock","unlock","publish","unlockAllAnnotations","lockedAnnotationsSet","clearLockedAnnotationsSet","getAnnotationsLocked","from","isAnnotationLocked","getAnnotationsLockedCount","checkAndDefineIsLockedProperty","isLocked","getOwnPropertyDescriptor","setIsLocked","getIsLocked","isExtensible","shouldDefineIsLockedProperty","freeze","added","removed","delete","item","triggerEvent","eventTarget","selectedAnnotationUIDs","setAnnotationSelected","annotationUID","selected","preserveSelected","selectAnnotation","deselectAnnotation","clearSelectionSet","getAnnotationsSelected","getAnnotationsSelectedByToolName","toolName","filter","getAnnotation","metadata","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","hide","showAllAnnotations","isAnnotationVisible","checkAndDefineIsVisibleProperty","isVisible","setIsVisible","getIsVisible","shouldDefineIsVisibleProperty","lastVisible","lastHidden","hidden","annotationUIDsSet","ToolModes","FrameOfReferenceSpecificAnnotationManager","annotationGroupSelector","element","enabledElement","getEnabledElement","FrameOfReferenceUID","evt","frameOfReferenceSpecificAnnotations","annotations","invalidated","groupKey","frameOfReferenceUID","frameOfReferenceAnnotations","getAnnotations","total","toolSpecificAnnotations","groupAnnotations","toolAnnotations","findIndex","cloneDeep","count","utilities","Enums","_imageVolumeModifiedHandler","defaultFrameOfReferenceSpecificAnnotationManager","svgNodeCache","defaultState","isInteractingWithTool","isMultiPartToolActive","tools","toolGroups","synchronizers","enabledElements","handleRadius","MODES","toolOptions","toolGroupToolNames","includes","mode","defaultManager","getAnnotationManager","setAnnotationManager","annotationManager","resetAnnotationManager","manager","getGroupKey","addAnnotation","csUtils","HTMLDivElement","renderingEngine","viewportId","eventType","eventDetail","renderingEngineId","triggerAnnotationAddedForElement","getToolGroupsWithToolName","viewportsToRender","toolGroup","viewportsInfo","viewportInfo","getEnabledElementByIds","triggerAnnotationAddedForFOR","getNumberOfAnnotations","removeAnnotation","annotationManagerUID","removeAllAnnotations","SegmentationRepresentations","defaultContourConfig","renderOutline","outlineWidthActive","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","defaultLabelmapConfig","renderFill","renderFillInactive","fillAlpha","fillAlphaInactive","getDefaultLabelmapConfig","initialDefaultState","colorLUT","segmentations","globalConfig","renderInactiveSegmentations","representations","defaultSegmentationStateManager","SegmentationStateManager","lutIndex","segmentationId","find","segmentation","_initDefaultColorLUTIfNecessary","getSegmentation","toolGroupId","toolGroupSegRepresentationsWithConfig","segmentationRepresentations","segmentationRepresentation","config","_handleActiveSegmentation","segmentationRepresentationUID","getSegmentationRepresentations","representation","toolGroupSegmentationRepresentations","segData","console","warn","removedSegmentationRepresentation","toolGroupSegmentations","segmentationData","active","toolGroupStateWithConfig","getSegmentationRepresentationByUID","segmentationRepresentationSpecificConfig","segmentIndex","segmentSpecificConfig","log","colorLUTIndex","recentlyAddedOrRemovedSegmentationRepresentation","addColorLUT","CORNERSTONE_COLOR_LUT","triggerSegmentationRemoved","triggerSegmentationRepresentationRemoved","triggerSegmentationRepresentationModified","triggerSegmentationModified","getSegmentations","triggerSegmentationDataModified","modifiedSlicesToUse","getDefaultSegmentationStateManager","getState","addSegmentation","segmentationInput","suppressEvents","segmentationStateManager","cachedStats","segmentLabels","label","segmentsLocked","activeSegmentIndex","representationData","normalizeSegmentationInput","getToolGroupIdsWithSegmentation","toolGroupIds","foundToolGroupIds","getToolGroupSpecificConfig","setToolGroupSpecificConfig","setSegmentationRepresentationConfig","setSegmentationRepresentationSpecificConfig","getSegmentationRepresentationSpecificConfig","getSegmentSpecificRepresentationConfig","getSegmentSpecificConfig","setSegmentSpecificRepresentationConfig","setSegmentSpecificConfig","addSegmentationRepresentation","getGlobalConfig","setGlobalConfig","removeSegmentation","removeSegmentationRepresentation","removeColorLUT","getColorLUT","getMouseEventPoints","elementToUse","currentTarget","viewport","clientPoint","clientX","clientY","_clientToPoint","pagePoint","pageX","pageY","_pageToPoint","canvasPoint","rect","getBoundingClientRect","left","pageXOffset","top","pageYOffset","_pagePointsToCanvasPoints","page","client","canvas","world","canvasToWorld","startPoints","event","eventName","camera","lastPoints","currentPoints","deltaPoints","stopImmediatePropagation","preventDefault","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_CLICK","MOUSE_UP","MOUSE_DRAG","mouseButton","isClickEvent","clickDelay","preventClickTimeout","doubleClickState","doubleClickTimeout","mouseDownEvent","mouseUpEvent","ignoreDoubleClick","_onMouseDrag","_updateMouseEventsLastPoints","_getDeltaPoints","_isDragPastDoubleClickTolerance","_doStateMouseDownAndUp","_copyPoints","_onMouseUp","clearTimeout","_cleanUp","addEventListener","_onMouseMove","document","removeEventListener","mouseMoveListener","delta","Math","abs","_preventClickHandler","_clearDoubleClickTimeoutAndEvents","JSON","parse","stringify","points","_subtractPoints2D","point0","point1","mouseDoubleClickIgnoreListener","setTimeout","button","disable","mouseDoubleClickListener","mouseDownListener","capture","enable","deltaY","spinX","spinY","pixelX","pixelY","wheelDelta","wheelDeltaY","wheelDeltaX","deltaX","deltaMode","normalizeWheel","direction","wheel","wheelListener","lastInteractionType","lastInteractionTime","passive","handleTap","now","Date","stopPropagation","handleTapMouse","bind","handleTapTouch","attachEvents","eventList","interactionType","tapHandler","removeEvents","mouseEvents","touchEvents","Swipe","arr","len","arr2","minLen","_slicedToArray","_i","_s","_e","_arr","_n","_d","getTouchEventPoints","touches","changedTouches","touch","identifier","radiusX","radiusY","force","rotationAngle","getDeltaPoints","curr","getMeanPoints","last","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","reduce","getMeanTouchPoints","pairedDistance","j","sqrt","pow","runtimeSettings","Settings","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_PRESS","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_SWIPE","zeroIPoint","zeroIDistance","startPointsList","lastPointsList","isTouchStart","startTime","pressTimeout","pressDelay","pressMaxDistance","accumulatedDistance","swipeDistanceThreshold","swiped","swipeToleranceMs","defaultTapState","taps","tapTimeout","tapMaxDistance","tapToleranceMs","tapState","triggerEventCallback","ele","debug","_onTouchDrag","currentPointsList","_updateTouchEventsLastPoints","deltaDistance","totalDistance","currentTime","getTime","x","y","swipe","RIGHT","LEFT","DOWN","UP","_checkTouchSwipe","_onTouchEnd","_checkTouchTap","lp","_onTouchPress","_onTouchStart","preventGhostClick","touchStartListener","keyCode","keyListener","_onKeyUp","_cloneDeep","keyDownListener","getModifierKey","_toConsumableArray","getSvgNode","canvasHash","cacheKey","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","cacheEntry","removeChild","svgDrawingHelper","viewportElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","getSvgDrawingHelper","toolGroupFilteredByIds","tg","some","vp","getToolsWithModesForElement","modesFilter","ToolGroupManager","enabledTools","toolInstance","getToolInstance","Active","Passive","Enabled","AnnotationRenderingEngine","_throwIfDestroyed","elements","_viewportElements","_needsRender","_triggerRender","_animationFrameSet","_animationFrameHandle","_reset","_setViewportsToBeRenderedNextFrame","hasBeenDestroyed","_renderFlaggedViewports","elementsEnabled","indexOf","_render","requestAnimationFrame","getRenderingEngine","drawSvg","anyRendered","tool","renderAnnotation","rendered","cancelAnimationFrame","_setAllViewportsToBeRenderedNextFrame","annotationRenderingEngine","renderViewport","onImageRendered","triggerAnnotationRender","getToolsWithModesForMouseEvent","evtButton","correctBinding","bindings","binding","onCameraModified","onImageSpacingCalibrated","customCallbackHandler","handlerType","customFunction","activeTool","MouseBindings","KeyboardBindings","filterToolsWithMoveableHandles","ToolAndAnnotations","canvasCoords","proximity","toolsWithMoveableHandles","getHandleNearImagePoint","filterToolsWithAnnotationsForElement","filterInteractableAnnotationsForElement","filterMoveableAnnotationTools","moveableAnnotationTools","isPointNearTool","shiftKey","ctrlKey","kb","altKey","metaKey","getActiveToolForMouseEvent","mouseEvent","modifierKey","keyEventListener","getMouseModifier","buttons","Primary","mouseDown","preMouseDownCallback","isPrimaryClick","activeToolsWithEventBinding","passiveToolsIfEventWasPrimaryMouseButton","applicableTools","annotationToolsWithAnnotations","annotationToolsWithMoveableHandles","isMultiSelect","getAnnotationForSelection","toggleAnnotationSelection","handleSelectedCallback","toolSelectedCallback","postMouseDownCallback","toolsWithMovableHandles","mouseDownActivate","addNewAnnotation","mouseDrag","mouseDragCallback","mouseMove","activeAndPassiveTools","toolsWithAnnotations","toolsWithoutAnnotations","toolAndAnnotation","getToolName","annotationsNeedToBeRedrawn","mouseMoveCallback","mouseClick","mouseDoubleClick","mouseUp","mouseWheel","getActiveToolForKeyboardEvent","keyDown","setViewportsCursorByToolName","keyUp","getActiveToolForTouchEvent","touchEvent","numTouchPoints","getToolsWithModesForTouchEvent","touchStart","preTouchStartCallback","passiveToolsIfEventWasPrimaryTouchButton","postTouchStartCallback","touchStartActivate","touchDrag","touchDragCallback","touchEnd","touchTap","touchPress","addEnabledElement","newNode","svgLayer","svgns","createElementNS","svgLayerId","classList","setAttribute","style","width","height","pointerEvents","position","defs","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","dataset","viewportUid","renderingEngineUid","elementHash","_setSvgNodeCache","addViewportElement","mouseEventListeners","wheelEventListener","touchEventListeners","imageRenderedEventDispatcher","cameraModifiedEventDispatcher","imageSpacingCalibratedEventDispatcher","mouseToolEventDispatcher","keyboardToolEventDispatcher","touchToolEventDispatcher","synchronizersFilteredByIds","synchronizer","notDisabled","isDisabled","hasSourceViewport","hasTargetViewport","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","removeViewportElement","getSynchronizersForViewport","sync","remove","_removeViewportFromSynchronizers","getToolGroupForViewport","removeViewports","_removeViewportFromToolGroup","foundElementIndex","el","_removeEnabledElement","viewportIdsToRender","getViewport","triggerAnnotationRenderForViewportIds","getRenderingEngines","viewportIds","getViewports","s","_assertThisInitialized","ReferenceError","_setPrototypeOf","p","_inherits","subClass","superClass","_typeof","_possibleConstructorReturn","_getPrototypeOf","SegmentationState","segmentationConfig","getGlobalRepresentationConfig","representationType","setGlobalRepresentationConfig","segmentationRepresentationConfig","setSegmentationVisibility","visibility","segmentsHidden","indices","scalarData","getScalarData","keySet","it","parseInt","geometryIds","CONTOUR","geometryId","getSegmentIndex","getSegmentationIndices","getSegmentationVisibility","setSegmentsVisibility","segmentIndices","segRepresentation","setSegmentVisibility","BaseTool","toolProps","defaultToolProps","initialProps","configuration","supportedInteractionTypes","strategies","defaultStrategy","activeStrategy","strategyOptions","assign","operationData","newConfiguration","strategyName","setConfiguration","volumeId","actorEntries","getActors","actorEntry","actor","getClassName","targetId","startsWith","imageId","split","imageURI","viewports","getCurrentImageId","getImageData","StackViewport","VolumeViewport","getTargetVolumeId","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","getPolyData","contourSet","pointArray","vtkPoints","lines","vtkCellArray","pointIndex","getContours","contour","pointList","getPoints","flatPoints","getFlatPointsArray","getType","pointIndexes","_","pointListIndex","linePoints","Float32Array","insertNextCell","setData","polygon","vtkPolyData","setPoints","setLines","configCachePerSegmentationRepresentationUID","getConfigCache","setConfigCache","addContourSetsToElement","contourRepresentation","contourRepresentationConfig","contourActorUID","appendPolyData","vtkAppendPolyData","scalarToColorMap","segmentSpecificMap","geometry","validateGeometry","segmentId","polyData","color","getColor","getNumberOfPoints","scalars","vtkDataArray","numberOfComponents","dataType","setTuple","getPointData","setScalars","setInputData","addInputData","polyDataOutput","getOutputData","mapper","vtkMapper","vtkActor","setMapper","getProperty","setLineWidth","setForceOpaque","addActor","resetCamera","render","updateContourSets","newContourConfig","cachedConfig","contourSetsActor","getActor","newOutlineWithActive","getMapper","lut","getLookupTable","segmentsToSetToInvisible","segmentsToSetToVisible","setLookupTable","addOrUpdateContourSets","actorUID","actorUIDsToRemove","Boolean","removeActors","representationInput","toolGroupSpecificConfig","toolGroupSpecificRepresentation","Representations","currentToolGroupConfig","SegmentationConfig","mergedConfig","representationConfig","toolGroupConfig","contourData","_removeContourFromToolGroupViewports","getToolGroup","removeContourFromElement","renderImmediate","getViewportsInfo","volumeInputs","blendMode","addVolumesToViewports","addLabelmapToElement","removeVolumeActors","labelMapConfigCache","cfun","vtkColorTransferFunction","ofun","vtkPiecewiseFunction","addPoint","renderingConfig","labelmapData","labelmapUID","_addLabelmapToViewport","_setLabelmapColorAndOpacity","toolGroupLabelmapConfig","isActiveLabelmap","segmentationRepresentationLabelmapConfig","numColors","min","volumeActor","_getLabelmapConfig","outlineWidth","segmentColor","_needsTransferFunctionUpdate","forceOpacityUpdate","forceColorUpdate","addRGBPoint","segmentOpacity","removePoint","addPointLong","setRGBTransferFunction","setClamping","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","setLabelOutlineThickness","setVisibility","segmentsLabelmapConfig","segmentLabelmapConfig","configToUse","cacheUID","oldConfig","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","_removeLabelmapFromToolGroupViewports","removeLabelmapFromElement","SegmentationDisplayTool","toolGroupViewports","segmentationRenderList","_getMergedRepresentationsConfig","viewportsRenderList","labelmapDisplay","contourDisplay","allSettled","SegmentationRenderingEngine","_setToolGroupSegmentationToBeRenderedNextFrame","_renderFlaggedToolGroups","segmentationDisplayToolInstance","onSegmentationRender","renderSegmentation","csToolsEvents","segmentationRenderingEngine","triggerSegmentationRender","renderToolGroupSegmentations","segmentationVolume","slicesToUpdate","imageData","vtkOpenGLTexture","numSlices","getDimensions","setUpdatedFrame","modified","segmentationRepresentationUIDs","immediate","toolGroupSegRepresentations","toolGroupSegRepresentationUIDs","segRepresentationUIDsToRemove","invalidSegRepresentationUIDs","segRepresentationUID","segmentationDataUID","_removeSegmentation","toolGroupIndex","removeToolGroup","removeSegmentationsFromToolGroup","csToolsState","destroyToolGroup","csToolsInitialized","init","_removeCornerstoneEventListeners","elementEnabledEvent","elementDisabledEvent","removeEnabledElement","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","TOOLS_EVENTS","annotationModifiedListener","annotationSelectionListener","segmentationModifiedListener","segmentationDataModifiedEventListener","segmentationRepresentationModifiedEventListener","segmentationRepresentationRemovedEventListener","destroy","restoreAnnotations","resetState","addTool","ToolClass","toolAlreadyAdded","toolClass","removeTool","cancelActiveManipulations","cancel","Synchronizer","synchronizerId","eventHandler","_ignoreFiredEvents","_targetViewports","_sourceViewports","fireEvent","_enabled","_eventName","_eventHandler","_hasSourceElements","options","_viewportOptions","addTarget","addSource","_containsViewport","_onEvent","_updateDisableHandlers","removeSource","t","removeTarget","_getViewportIndex","_getViewportElement","sourceViewport","sourceEvent","targetViewport","ex","vp1","vp2","unique","vps","concat","u","_getUniqueViewports","_remove","disableHandler","vUid","ar","synchronizerIndex","DEFINED_CURSORS","STANDARD_CURSORS","MouseCursor","fallback","getStyleProperty","addFallbackStyleProperty","definedCursors","getDefinedCursors","mouseCursor","cursor","AnnotationStyleStates","standardCursorNames","_superPropBase","property","_get","Reflect","receiver","base","desc","ImageMouseCursor","url","getUniqueInstanceName","Number","prefix","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","registerCursor","getDefinedSVGCursorDescriptor","svgCursorNames","ToolStyle","_initializeConfig","colorHighlighted","colorSelected","colorLocked","lineWidth","lineDash","shadow","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","default","styles","annotationSpecificStyles","viewportSpecificStyles","toolGroupSpecificStyles","toolStyle","specifications","_getToolStyle","getAnnotationToolStyles","getViewportToolStyles","global","getToolGroupToolStyles","globalStyles","getDefaultToolStyles","toolStyles","styleSpecifier","alternatives","list","getHierarchalPropertyStyles","PROPERTY","STATE","MODE","SVGMouseCursor","pointer","urn","getCursorURN","createSVGMouseCursor","format","template","dictionary","dict","defined","URL","createObjectURL","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","createSVGIconUrl","scale","max","svgSize","ELEMENT_CURSORS_MAP","initElementCursor","_getElementCursors","_setElementCursor","cursors","getDefinedCursor","resetElementCursor","hideElementCursor","Disabled","ToolGroup","toolInstanceName","_toolInstances","toolDefinition","hasToolName","localToolInstance","instantiatedTool","parentClassName","ToolClassToUse","ParentClass","ToolInstance","renderingEngines","renderingEngineUIDToUse","getActivePrimaryMouseButtonTool","vpInfo","setActiveStrategy","setToolDisabled","setToolEnabled","setToolPassive","setToolActive","toolBindingsOptions","prevBindings","newBindings","bindingsToUse","TouchBinding","MouseBinding","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","activeToolIdentifier","_setCursorForViewports","onSetToolActive","_renderViewports","prevToolOptions","getToolOptions","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","_getCursor","cursorName","overwrite","_configuration","configurationPath","binding1","binding2","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","setCamera","CAMERA_MODIFIED","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","voiSyncCallback","voiModifiedEvent","range","setProperties","voiRange","createVOISynchronizer","zoomPanSyncCallback","getOptions","sViewport","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createZoomPanSynchronizer","val","low","high","scroll","viewportType","debounceLoading","loop","scrollVolume","numScrollSteps","currentStepIndex","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","viewPlaneNormal","newFocalPoint","newPosition","desiredStepIndex","VolumeScrollEventDetail","currentImageId","EVENTS","imageIndex","_getImageSliceData","currentImageIndex","numberOfSlices","imageIndexToJump","_getImageIndexToJump","getImageIds","getTargetImageIdIndex","getCurrentImageIdIndex","clip","areViewportsCoplanar","viewport1","viewport2","viewPlaneNormal1","getCamera","viewPlaneNormal2","dotProducts","vec3","stackImageSyncCallback","frameOfReferenceUID1","getFrameOfReferenceUID","frameOfReferenceUID2","imageId1","imagePlaneModule1","metaData","sourceImagePositionPatient","imagePositionPatient","targetImageIds","closestImageIdIndex","_getClosestImageIdIndex","jumpToSlice","registrationMatrixMat4","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","targetPoint","imageIds","distance","Infinity","STACK_NEW_IMAGE","createStackImageSynchronizer","drawingElementType","nodeUID","attributes","currentValue","getAttribute","removeAttribute","circleUID","center","radius","dataId","fill","strokeWidth","svgNodeHash","_getHash","existingCircleElement","cx","cy","stroke","_setAttributesIfNecessary","newCircleElement","_setNewAttributesIfValid","ellipseUID","corner1","corner2","existingEllipse","w","h","xMin","yMin","rx","ry","svgEllipseElement","handleGroupUID","handlePoints","opacity","handleRadiusFloat","parseFloat","side","existingHandleElement","newHandleElement","drawLine","lineUID","start","end","existingLine","dropShadowStyle","x1","y1","x2","y2","newLine","drawPolyline","polylineUID","connectLastToFirst","existingPolyLine","pointsAttribute","point","firstPoint","newPolyLine","_drawTextGroup","textUID","textGroupBoundingBox","textLines","padding","fontFamily","fontSize","background","existingTextGroup","textElement","textSpans","textSpanElement","text","textContent","textLine","textSpan","_createTextSpan","textAttributes","textGroupAttributes","_drawTextBackground","textGroup","_createTextElement","combinedStyle","group","getBBox","insertBefore","firstChild","bBox","mergedOptions","centerX","centerY","findClosestPoint","sourcePoints","minPoint","minDistance","sourcePoint","p2","_boundingBoxPoints","boundingBox","halfWidth","halfHeight","linkUID","annotationAnchorPoints","refPoint","boundingBoxPoints","textBoxUID","textBoxPosition","textBox","centering","canvasBoundingBox","drawTextBox","drawLink","drawRect","rectangleUID","_width","existingRect","tlhc","svgRectElement","drawArrow","arrowUID","headLength","angle","atan2","firstLine","cos","PI","sin","secondLine","getAnnotationNearPoint","getAnnotationNearPointOnEnabledElement","found","findAnnotationNearPointByTool","currentId","referencedImageId","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","invokeFunc","time","thisArg","startTimer","pendingFunc","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","cancelTimer","flush","pending","debounce","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","rowPixelSpacing","columnPixelSpacing","getStackViewports","calibrateSpacing","pointInShapeCallback","pointInShapeFn","callback","boundsIJK","iMin","iMax","jMin","jMax","kMin","kMax","getScalars","getData","dimensions","getDirection","rowCosines","columnCosines","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","yMultiple","zMultiple","k","pointIJK","dI","dJ","dK","startWorld","pointLPS","xMax","yMax","zMin","zMax","floor","depth","transformWorldToIndex","pointInSurroundingSphereCallback","circlePoints","bottom","centerWorld","radiusWorld","centerIJK","spacings","minSpacing","maxRadiusIJK","ceil","viewUp","viewRight","topLeftWorld","bottomRightWorld","sphereCornersIJK","getBoundingBoxAroundShape","_computeBoundsIJKWithCamera","_getBounds","sphereObj","sphere","pointInSphere","fillInsideSphere","volume","scalarIndex","minSlice","maxSlice","v","fillSphere","eraseInsideSphere","getCanvasEllipseCorners","ellipseCanvasPoints","right","pointInEllipse","ellipse","circleCenterWorld","xRadius","yRadius","zRadius","z","x0","y0","z0","inside","fillCircle","threshold","imageVolume","strategySpecificConfiguration","canvasCoordinates","worldToCanvas","topLeftCanvas","bottomRightCanvas","ellipsoidCornersIJK","every","ellipseObj","isWithinThreshold","arrayOfSlices","THRESHOLD_INSIDE_CIRCLE","voxelValue","fillInsideCircle","thresholdInsideCircle","eraseInsideCircle","getActiveSegmentationRepresentation","setActiveSegmentationRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","getLockedSegments","setActiveSegmentIndex","getActiveSegmentIndex","unshift","setColorLUT","getColorForSegmentIndex","setColorForSegmentIndex","colorReference","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","brushSize","disableCursor","activeSegmentationRepresentation","activeSegmentation","segmentLocking","segmentationState","firstVolumeActorUID","_editData","_activateDraw","triggerAnnotationRenderForViewportUIDs","updateCursor","_hoverData","brushCursor","handles","applyActiveStrategy","_deactivateDraw","_endCallback","_dragCallback","eventData","centerCanvas","segmentIndexController","_calculateCursor","bottomCanvas","topCanvas","leftCanvas","rightCanvas","toolMetadata","brushCursorUID","drawCircleSvg","getBrushToolInstances","toolInstances","getVoxelOverlap","voxelSpacing","voxelCenter","voxelCornersWorld","voxelCornersIJK","processVolumes","thresholdVolumeInformation","b","segmentationSpacing","spacing","volumeInfoList","baseVolumeIdx","volumeSize","referenceValues","lower","upper","segmentationImageData","overlapType","overlaps","testOverlapRange","volumeInfo","overlapBounds","overlapTest","testRange","computeOffsetIndex","insert","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolMode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","filterViewportsWithParallelNormals","PARALLEL_THRESHOLD","CONSTANTS","filterAnnotationsWithinSlice","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","rowCosineVec","colCosineVec","isParallel","halfSpacingInNormalDirection","annotationsWithinSlice","dir","dot","filterAnnotationsForDisplay","colonIndex","substring","highlighted","AnnotationDisplayTool","rowScale","columnScale","calibratedImageData","noneCalibratedWorldToIndex","worldToIndex","calibratedIndexToWorld","getIndexToWorld","stateManager","getFramesOfReference","frameOfReference","vec4","pCalibrated","nonCalibratedIndexVec4","calibratedIndex","worldPos","getTargetId","AnnotationTool","filteredAnnotations","activateHandleIndex","activeHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","annotationCanvasCoordinate","vec2","getStyle","dist2","p1","distanceToPointSquared","lineStart","lineEnd","d2","distanceToPoint","lineSegments","rectToLineSegments","segment","lineSegment","getTextBoxCoordsCanvas","annotationCanvasPoints","canvasPoints","handlesLeftToRight","handlesTopToBottom","corners","sort","getWorldWidthAndHeightFromCorners","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getModalityUnit","modality","isPreScaled","isViewportPreScaled","BaseVolumeViewport","scaling","preScale","scaled","RectangleROITool","preventHandleOutsideImage","isDrawing","getReferencedImageId","hasMoved","worldPosition","editData","handleIndex","movingTextBox","newAnnotation","canvasPoint1","canvasPoint2","_getRectangleImageCoordinates","rectangle","_activateModify","_deactivateModify","isHandleOutsideImage","worldPosDelta","bottomLeftCanvas","topRightCanvas","bottomLeftWorld","topRightWorld","renderStatus","unit","_throttledCalculateCachedStats","referencedImageURI","hasImageURI","currentImageURI","Modality","area","mean","stdDev","areaUnit","_calculateCachedStats","activeHandleCanvasCoords","drawHandlesSvg","drawRectSvg","_getTextLines","canvasTextBoxCoords","drawLinkedTextBoxSvg","getLinkedTextBoxStyle","cachedVolumeStats","toFixed","worldPos1","worldPos2","targetIds","image","getTargetIdImage","hasPixelSpacing","worldPos1Index","worldPos2Index","_isInsideVolume","valueMinusMean","index1","index2","throttle","RectangleROIThresholdTool","RectangleROIStartEndThresholdTool","numSlicesToPropagate","startIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","projectionPoints","projectionPointsImageIds","_computeProjectionPoints","sliceIndex","firstOrLastSlice","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","indexToWorldVec3","endWorld","newProjectionPoints","dist","newPoint","RectanglePoints","endPos","imageIdIndex","numSlicesToProject","sliceNormalIndex","referenceVolume","AllBoundsIJK","pointsToUse","rectangleCornersIJK","extend2DBoundingBoxInViewAxis","annotationUIDs","validToolNames","_validateAnnotations","getBoundsIJKFromRectangleAnnotations","thresholdVolumeByRange","labelmaps","origin","labelmap","arrayType","outputData","preventCache","mergedVolume","volumeLoader","isValidRepresentationConfig","SegmentationRepresentation","isValidLabelmapConfig","getDefaultRepresentationConfig","createLabelmapVolumeForViewport","getDefaultActor","properties","defaultEquals","countNonZeroes","lpad","character","join","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","prunedPermutations","flooded","visits","bounds","currentArgs","flood","boundaries","job","getArgs","prevArgs","previousArgs","visited","markAsVisited","member","markAsFlooded","pushAdjacent","markAsBoundary","node","safely","perm","nextArgs","f","permute","perms","permutation","c","setBrushSizeForToolGroup","invalidateBrushCursor","viewportsInfoArray","getViewportIds","getBrushSizeForToolGroup","brushToolInstance","setBrushThresholdForToolGroup","getBrushThresholdForToolGroup","segmentationIndex","_handleSameSizeVolume","getPoint","_handleDifferentSizeVolume","EPSILON","clipT","num","denom","tE","tL","box","da","db","dx","dy","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","getFirstIntersectionWithPolyline","q1","initialI","closed","q2","doesIntersect","getClosestIntersectionWithPolyline","intersections","distances","intersection","intersectionPoints","midpoint","indexOfMinDistance","orient","orientation","onSegment","q","orientationValue","subPixelResolution","xDir","yDir","volumeSpacing","iVector","jVector","kVector","xSpacing","absViewRightDotI","absViewRightDotJ","absViewRightDotK","ySpacing","absViewPlaneNormalDotI","absViewPlaneNormalDotJ","absViewPlaneNormalDotK","closeContourProximity","newCanvasPoint","commonData","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","calculateAreaOfPoints","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","pickedPoint","stepSize","cameraPosition","step","getBounds","vector","vtkMath","pointT","_inBounds","intensity","getIntensityFromWorld","pointToPick","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","toUpperCase","addToolState","getToolState","dynamicVolumesPlayingMap","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","frameTimeVectorEnabled","_createStackViewportCinePlayContext","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","volumeViewPlaneNormal","glMatrix","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","sample","delay","sum","limit","timeouts","isTimeVarying","_getPlayClipTimeouts","playClipAction","newStepIndex","playClipTimeoutHandler","setInterval","CINE_EVENTS","stopClip","stopDynamicCine","cineToolData","clearInterval","dynamicCineElement","v1","v2","v0","v3","t1","t2","t3","basis","interpolator","samples","transpose","matrix","m","valueof","row","zip","interpolateSegmentPoints","iniIndex","knotsRatioPercentage","segmentSize","amountOfKnots","minKnotDistance","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","interpolatedPoints","originalPoints","knotsIndexes","xInterpolator","d3InterpolateBasis","yInterpolator","zInterpolator","d3Zip","d3Quantize","interpolatePoints","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","continuosDistributionValue","round","getContinuousUniformDistributionValues","shouldInterpolate","interpolation","interpolateOnAdd","interpolateOnEdit","followingIndex","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","previousPoints","findMatchIndexes","firstMatchIndex","previousFirstMatchIndex","toBeNotEqualCriteria","pointA","pointB","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","findChangedSegment","changedIniIndex","changedEndIndex","findOpenUShapedContourVectorToPeak","first","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","addCanvasPointsToArray","polyline","pointsAreWithinCloseContourProximity","getSubPixelSpacingAndXYDirections","activateDraw","canvasPos","drawData","polylineIndex","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","lastWorldPoint","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","allowOpenContours","lastPoint","completeDrawOpenContour","completeDrawClosedContour","removeCrossedLinesOnCompleteDraw","haltDrawing","worldPoints","isOpenContour","triggerAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","indexToRemoveUpTo","isOpenUShapeContour","openUShapeContourVectorToPeak","pointsLessLastOne","shift","activateClosedContourEdit","cancelDrawing","minPoints","shouldHaltDrawing","checkForFirstCrossing","isClosedContour","editCanvasPoints","prevCanvasPoints","crossedLineSegment","startCrossingIndex","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","twoClosestDistanceIndexPairs","lowestIndex","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","editIndex","numPointsToRemove","checkForSecondCrossing","removePointsAfterSecondCrossing","lastLine","didCrossLine","findSnapIndex","lastEditCanvasPoint","editCanvasPointsLessLastOne","snapCanvasPosition","checkAndRemoveCrossesOnEditLine","editIndexCrossed","isEditingClosed","mouseUpClosedContourEditCallback","mouseDragClosedContourEditCallback","deactivateClosedContourEdit","currentEditIndex","snapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","finishEditAndStartNewEdit","triggerAnnotationModified","lowIndex","highIndex","augmentedEditCanvasPoints","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","cancelClosedContourEdit","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activateOpenContourEndEdit","lastCanvasPos","p3","aDotb","magA","magB","acos","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","_getRenderingOptions","renderContour","findOpenUShapedContourVectorToPeakOnRender","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","renderClosedContour","drawPolylineSvg","alwaysRenderOpenContourHandles","enabled","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","pointCanProjectOnLine","PlanarFreehandROITool","previousPoint","pStart","pEnd","activeAnnotationUID","registerDrawLoop","registerEditLoopCommon","registerClosedContourEditLoop","registerOpenContourEditLoop","registerOpenContourEndEditLoop","registerRenderMethods","annotationsToDisplay","interpolateAnnotation","shouldPreventInterpolation","interpolatedCanvasPoints","resetPrefetchTimeout","requestType","maxImagesToPrefetch","preserveExistingPool","lowEnd","highEnd","getStackData","currentImageIdIndex","prefetch","stackPrefetchData","stackPrefetch","indicesToRequest","removeFromList","imageLoadPoolManager","nextImageIdIndex","nearest","idx","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","imageLoader","useNorm16Texture","getCoreConfiguration","rendering","targetBuffer","getPromiseRemovedHandler","stackData","onImageUpdated","indexOfCurrentImage","promiseRemovedHandler","getConfiguration","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","dynamicVolume","frames","frameNumbers","maskVolumeId","imageCoordinate","dataInTime","indexArray","allScalarData","getScalarDataArrays","indexValues","frame","activeScalarData","_getTimePointDataMask","coordinate","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","currentArray","setElementCursor","CursorNames","segmentationInputArray","validateLabelmap","validateSegmentationInput","segInput","addSegmentationToState","representationInputArray","toolGroupSpecificRepresentationConfig","promises","_addSegmentationRepresentation","all","addSegmentationRepresentations","PanTool","deltaPointsWorld","updatedPosition","updatedFocalPoint","TrackballRotateTool","rotateIncrementDegrees","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","mat4","currentPointsCanvas","lastPointsCanvas","clientWidth","clientHeight","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","upVec","atV","rightV","forwardV","rotateCamera","angleY","ProbeTool","eventDispatchDetail","textCanvasCoordinates","drawTextBoxSvg","SUVBw","SUVLbm","SUVBsa","PET","suvbwToSuvbsa","suvbwToSuvlbm","_getValueForModality","DragProbeTool","WindowLevelTool","bytesPerVoxel","TypedArrayConstructor","middleSliceIndex","frameLength","Uint16Array","Int16Array","_getMinMax","newRange","viewportsContainingVolumeUID","getProperties","getPTNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","windowWidth","windowCenter","imageDynamicRange","calculatedDynamicRange","_getImageDynamicRangeFromMiddleSlice","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","getRange","voxel","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","pinch","parallelScale","zoomScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","directionOfProjection","tmp","_pinchCallback","parallelProjection","_dragParallelProjection","_dragPerspectiveProjection","_panCallback","StackScrollTool","invert","debounceIfNotLoaded","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","_getNumberOfSlices","offsetHeight","angleBetweenLines","line1","line2","p4","PlanarRotateTool","currentPointWorld","startPointWorld","cross","rotAngle","rotMat","rotatedViewUp","rotation","StackScrollMouseWheelTool","DIRECTIONS","X","Y","Z","CUSTOM","VolumeRotateMouseWheelTool","cz","ax","ay","az","MIPJumpToClickTool","targetViewportIds","maxIntensity","brightestPoint","LengthTool","point2","line","drawLineSvg","dz","_calculateLength","RENDERING_DEFAULTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","CrosshairsTool","viewportIndicators","autoPan","panSize","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","mobile","_getAnnotations","cameraFocalPoint","rotationPoints","slabThicknessPoints","toolCenter","activeOperation","activeViewportIds","firstViewport","secondViewport","thirdViewport","initializeViewport","normal1","normal2","normal3","point3","firstPlane","secondPlane","thirdPlane","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","_autoPanViewportIfNecessary","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","_areViewportIdArraysEqual","canvasDiagonalLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","canvasBox","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","liangBarksyClip","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","vtkMatrixBuilder","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","getSlabThickness","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","handleUID","_getViewportsInfo","computeToolCenter","viewportIdArrayOne","viewportIdArrayTwo","itemFound","viewportsWithDifferentCameras","cameraOfTarget","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_getAnnotationsForViewportsWithDifferentCameras","actors","otherViewportActors","sameScene","viewportsAnnotationsToUpdate","_checkIfViewportsRenderingSameScene","_applyDeltaShiftToSelectedViewportCameras","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","translate","otherViewportsIds","renderViewports","referenceAnnotations","_filterViewportWithSameOrientation","viewportsIds","mod","currentPoint","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","setSlabThickness","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","_onNewVolume","topLefWorld","minX","maxX","minY","maxY","minZ","maxZ","slabThickness","actorUIDs","blendModeToUse","setBlendMode","_applyDeltaShiftToViewportCamera","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","ReferenceLines","sourceViewportId","sourceViewportCanvasCornersInWorld","_init","sourceViewPlaneNormal","targetViewportPlane","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","vec1","getWorldWidthAndHeightFromTwoPoints","EllipticalROITool","centerPointRadius","initialRotation","getRotation","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","currentCanvasPoints","dX","dY","_dragHandle","dYCanvas","canvasBottom","canvasTop","newHalfCanvasWidth","canvasLeft","canvasRight","dXCanvas","newHalfCanvasHeight","_dragModifyCallback","_dragDrawCallback","canvasCorners","drawEllipseSvg","centerPoint","_getCanvasEllipseCenter","isEmptyArea","areaLine","location","normalized","getCanvasCircleRadius","circleCanvasPoints","getCanvasCircleCorners","CircleROITool","radiusPoint","canvasCenter","canvasEnd","radiusUnit","perimeter","radiusLine","BidirectionalTool","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","shortAxis","currentShortAxisVector","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","dataId1","dataId2","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos3","worldPos4","dist1","index3","index4","vector1","vector2","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","drawArrowSvg","updatedText","doneChangingTextCallback","prompt","AngleTool","angleStartedNotYetCompleted","canvasPoint3","fromCharCode","midPoint2","ret","CobbAngleTool","point4","canvasPoint4","_mouseUpCallback","_mouseDragCallback","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_getReferencedImageId","_createMagnificationViewport","magnifyToolElement","magnifyElement","createElement","display","viewportInput","enableElement","magnifyViewport","setStack","disableElement","_dragEndCallback","ReferenceCursors","displayThreshold","positionSync","_currentCursorWorldPosition","_currentCanvasPosition","_elementWithCursor","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","previousCamera","oldFocalPoint","cameraNormal","dotProduct","isElementWithCursor","updateViewportImage","crosshairUIDs","centerSpace","lineLength","_disableCursorEnabled","plane","currentMousePosition","closestIndex","setImageIdIndex","normalizedViewPlane","scaledPlaneNormal","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","worldWidthViewport","worldHeightViewport","scaleSizes","scaleSize","locationTickOffset","endTick1","endTick2","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","pointSet","worldCoordinates","midpointLocation","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","computeScaleBounds","computeScaleSize","computeWorldScaleCoordinates","computeCanvasScaleCoordinates","scaleTicks","computeEndScaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textBoxLines","computeInnerScaleTicks","scaleSizeDisplayValue","scaleSizeUnits","fillInsideRectangle","constraintFn","coord","fillRectangle","eraseInsideRectangle","eraseRectangle","RectangleScissorsTool","FILL_INSIDE","ERASE_INSIDE","CircleScissorsTool","SphereScissorsTool","isEqual","PaintFillTool","fixedDimension","getFixedDimension","generateHelpers","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","clickedLabelValue","floodFillResult","floodFill","scalarDataPosition","getFramesModified","minJ","maxJ","framesModified","seedIndex3D","getScalarDataPosition","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection"],"sourceRoot":""}